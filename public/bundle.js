/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 52);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

eval("var markoGlobal = window.$MG || (window.$MG = {\n    uid: 0\n});\n\nvar runtimeId = markoGlobal.uid++;\n\nvar componentLookup = {};\n\nvar defaultDocument = document;\n\nfunction getComponentForEl(el, doc) {\n    if (el) {\n        var node = typeof el == 'string' ? (doc || defaultDocument).getElementById(el) : el;\n        if (node) {\n            var component = node._w;\n\n            while(component) {\n                var rootFor = component.$__rootFor;\n                if (rootFor)  {\n                    component = rootFor;\n                } else {\n                    break;\n                }\n            }\n\n            return component;\n        }\n    }\n}\n\nvar lifecycleEventMethods = {};\n\n[\n    'create',\n    'render',\n    'update',\n    'mount',\n    'destroy',\n].forEach(function(eventName) {\n    lifecycleEventMethods[eventName] = 'on' + eventName[0].toUpperCase() + eventName.substring(1);\n});\n\n/**\n * This method handles invoking a component's event handler method\n * (if present) while also emitting the event through\n * the standard EventEmitter.prototype.emit method.\n *\n * Special events and their corresponding handler methods\n * include the following:\n *\n * beforeDestroy --> onBeforeDestroy\n * destroy       --> onDestroy\n * beforeUpdate  --> onBeforeUpdate\n * update        --> onUpdate\n * render        --> onRender\n */\nfunction emitLifecycleEvent(component, eventType, eventArg1, eventArg2) {\n    var listenerMethod = component[lifecycleEventMethods[eventType]];\n\n    if (listenerMethod) {\n        listenerMethod.call(component, eventArg1, eventArg2);\n    }\n\n    component.emit(eventType, eventArg1, eventArg2);\n}\n\nfunction destroyComponentForEl(el) {\n    var componentToDestroy = el._w;\n    if (componentToDestroy) {\n        componentToDestroy.$__destroyShallow();\n        el._w = null;\n\n        while ((componentToDestroy = componentToDestroy.$__rootFor)) {\n            componentToDestroy.$__rootFor = null;\n            componentToDestroy.$__destroyShallow();\n        }\n    }\n}\nfunction destroyElRecursive(el) {\n    var curChild = el.firstChild;\n    while(curChild) {\n        if (curChild.nodeType == 1) {\n            destroyComponentForEl(curChild);\n            destroyElRecursive(curChild);\n        }\n        curChild = curChild.nextSibling;\n    }\n}\n\nfunction nextComponentId() {\n    // Each component will get an ID that is unique across all loaded\n    // marko runtimes. This allows multiple instances of marko to be\n    // loaded in the same window and they should all place nice\n    // together\n    return 'b' + ((markoGlobal.uid)++);\n}\n\nfunction getElementById(doc, id) {\n    return doc.getElementById(id);\n}\n\nfunction attachBubblingEvent(componentDef, handlerMethodName, extraArgs) {\n    if (handlerMethodName) {\n        var id = componentDef.id;\n\n        return extraArgs ?\n            [handlerMethodName, id, extraArgs] :\n            [handlerMethodName, id];\n    }\n}\n\nexports.$__runtimeId = runtimeId;\nexports.$__componentLookup = componentLookup;\nexports.$__getComponentForEl = getComponentForEl;\nexports.$__emitLifecycleEvent = emitLifecycleEvent;\nexports.$__destroyComponentForEl = destroyComponentForEl;\nexports.$__destroyElRecursive = destroyElRecursive;\nexports.$__nextComponentId = nextComponentId;\nexports.$__getElementById = getElementById;\nexports.$__attachBubblingEvent = attachBubblingEvent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vbWFya28vY29tcG9uZW50cy91dGlsLWJyb3dzZXIuanM/ZjFlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWFya29HbG9iYWwgPSB3aW5kb3cuJE1HIHx8ICh3aW5kb3cuJE1HID0ge1xuICAgIHVpZDogMFxufSk7XG5cbnZhciBydW50aW1lSWQgPSBtYXJrb0dsb2JhbC51aWQrKztcblxudmFyIGNvbXBvbmVudExvb2t1cCA9IHt9O1xuXG52YXIgZGVmYXVsdERvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudEZvckVsKGVsLCBkb2MpIHtcbiAgICBpZiAoZWwpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0eXBlb2YgZWwgPT0gJ3N0cmluZycgPyAoZG9jIHx8IGRlZmF1bHREb2N1bWVudCkuZ2V0RWxlbWVudEJ5SWQoZWwpIDogZWw7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gbm9kZS5fdztcblxuICAgICAgICAgICAgd2hpbGUoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3RGb3IgPSBjb21wb25lbnQuJF9fcm9vdEZvcjtcbiAgICAgICAgICAgICAgICBpZiAocm9vdEZvcikgIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ID0gcm9vdEZvcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBsaWZlY3ljbGVFdmVudE1ldGhvZHMgPSB7fTtcblxuW1xuICAgICdjcmVhdGUnLFxuICAgICdyZW5kZXInLFxuICAgICd1cGRhdGUnLFxuICAgICdtb3VudCcsXG4gICAgJ2Rlc3Ryb3knLFxuXS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgIGxpZmVjeWNsZUV2ZW50TWV0aG9kc1tldmVudE5hbWVdID0gJ29uJyArIGV2ZW50TmFtZVswXS50b1VwcGVyQ2FzZSgpICsgZXZlbnROYW1lLnN1YnN0cmluZygxKTtcbn0pO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGhhbmRsZXMgaW52b2tpbmcgYSBjb21wb25lbnQncyBldmVudCBoYW5kbGVyIG1ldGhvZFxuICogKGlmIHByZXNlbnQpIHdoaWxlIGFsc28gZW1pdHRpbmcgdGhlIGV2ZW50IHRocm91Z2hcbiAqIHRoZSBzdGFuZGFyZCBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgbWV0aG9kLlxuICpcbiAqIFNwZWNpYWwgZXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIGhhbmRsZXIgbWV0aG9kc1xuICogaW5jbHVkZSB0aGUgZm9sbG93aW5nOlxuICpcbiAqIGJlZm9yZURlc3Ryb3kgLS0+IG9uQmVmb3JlRGVzdHJveVxuICogZGVzdHJveSAgICAgICAtLT4gb25EZXN0cm95XG4gKiBiZWZvcmVVcGRhdGUgIC0tPiBvbkJlZm9yZVVwZGF0ZVxuICogdXBkYXRlICAgICAgICAtLT4gb25VcGRhdGVcbiAqIHJlbmRlciAgICAgICAgLS0+IG9uUmVuZGVyXG4gKi9cbmZ1bmN0aW9uIGVtaXRMaWZlY3ljbGVFdmVudChjb21wb25lbnQsIGV2ZW50VHlwZSwgZXZlbnRBcmcxLCBldmVudEFyZzIpIHtcbiAgICB2YXIgbGlzdGVuZXJNZXRob2QgPSBjb21wb25lbnRbbGlmZWN5Y2xlRXZlbnRNZXRob2RzW2V2ZW50VHlwZV1dO1xuXG4gICAgaWYgKGxpc3RlbmVyTWV0aG9kKSB7XG4gICAgICAgIGxpc3RlbmVyTWV0aG9kLmNhbGwoY29tcG9uZW50LCBldmVudEFyZzEsIGV2ZW50QXJnMik7XG4gICAgfVxuXG4gICAgY29tcG9uZW50LmVtaXQoZXZlbnRUeXBlLCBldmVudEFyZzEsIGV2ZW50QXJnMik7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3lDb21wb25lbnRGb3JFbChlbCkge1xuICAgIHZhciBjb21wb25lbnRUb0Rlc3Ryb3kgPSBlbC5fdztcbiAgICBpZiAoY29tcG9uZW50VG9EZXN0cm95KSB7XG4gICAgICAgIGNvbXBvbmVudFRvRGVzdHJveS4kX19kZXN0cm95U2hhbGxvdygpO1xuICAgICAgICBlbC5fdyA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKChjb21wb25lbnRUb0Rlc3Ryb3kgPSBjb21wb25lbnRUb0Rlc3Ryb3kuJF9fcm9vdEZvcikpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFRvRGVzdHJveS4kX19yb290Rm9yID0gbnVsbDtcbiAgICAgICAgICAgIGNvbXBvbmVudFRvRGVzdHJveS4kX19kZXN0cm95U2hhbGxvdygpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZGVzdHJveUVsUmVjdXJzaXZlKGVsKSB7XG4gICAgdmFyIGN1ckNoaWxkID0gZWwuZmlyc3RDaGlsZDtcbiAgICB3aGlsZShjdXJDaGlsZCkge1xuICAgICAgICBpZiAoY3VyQ2hpbGQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgZGVzdHJveUNvbXBvbmVudEZvckVsKGN1ckNoaWxkKTtcbiAgICAgICAgICAgIGRlc3Ryb3lFbFJlY3Vyc2l2ZShjdXJDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5leHRDb21wb25lbnRJZCgpIHtcbiAgICAvLyBFYWNoIGNvbXBvbmVudCB3aWxsIGdldCBhbiBJRCB0aGF0IGlzIHVuaXF1ZSBhY3Jvc3MgYWxsIGxvYWRlZFxuICAgIC8vIG1hcmtvIHJ1bnRpbWVzLiBUaGlzIGFsbG93cyBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgbWFya28gdG8gYmVcbiAgICAvLyBsb2FkZWQgaW4gdGhlIHNhbWUgd2luZG93IGFuZCB0aGV5IHNob3VsZCBhbGwgcGxhY2UgbmljZVxuICAgIC8vIHRvZ2V0aGVyXG4gICAgcmV0dXJuICdiJyArICgobWFya29HbG9iYWwudWlkKSsrKTtcbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudEJ5SWQoZG9jLCBpZCkge1xuICAgIHJldHVybiBkb2MuZ2V0RWxlbWVudEJ5SWQoaWQpO1xufVxuXG5mdW5jdGlvbiBhdHRhY2hCdWJibGluZ0V2ZW50KGNvbXBvbmVudERlZiwgaGFuZGxlck1ldGhvZE5hbWUsIGV4dHJhQXJncykge1xuICAgIGlmIChoYW5kbGVyTWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgaWQgPSBjb21wb25lbnREZWYuaWQ7XG5cbiAgICAgICAgcmV0dXJuIGV4dHJhQXJncyA/XG4gICAgICAgICAgICBbaGFuZGxlck1ldGhvZE5hbWUsIGlkLCBleHRyYUFyZ3NdIDpcbiAgICAgICAgICAgIFtoYW5kbGVyTWV0aG9kTmFtZSwgaWRdO1xuICAgIH1cbn1cblxuZXhwb3J0cy4kX19ydW50aW1lSWQgPSBydW50aW1lSWQ7XG5leHBvcnRzLiRfX2NvbXBvbmVudExvb2t1cCA9IGNvbXBvbmVudExvb2t1cDtcbmV4cG9ydHMuJF9fZ2V0Q29tcG9uZW50Rm9yRWwgPSBnZXRDb21wb25lbnRGb3JFbDtcbmV4cG9ydHMuJF9fZW1pdExpZmVjeWNsZUV2ZW50ID0gZW1pdExpZmVjeWNsZUV2ZW50O1xuZXhwb3J0cy4kX19kZXN0cm95Q29tcG9uZW50Rm9yRWwgPSBkZXN0cm95Q29tcG9uZW50Rm9yRWw7XG5leHBvcnRzLiRfX2Rlc3Ryb3lFbFJlY3Vyc2l2ZSA9IGRlc3Ryb3lFbFJlY3Vyc2l2ZTtcbmV4cG9ydHMuJF9fbmV4dENvbXBvbmVudElkID0gbmV4dENvbXBvbmVudElkO1xuZXhwb3J0cy4kX19nZXRFbGVtZW50QnlJZCA9IGdldEVsZW1lbnRCeUlkO1xuZXhwb3J0cy4kX19hdHRhY2hCdWJibGluZ0V2ZW50ID0gYXR0YWNoQnViYmxpbmdFdmVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYXJrby9jb21wb25lbnRzL3V0aWwtYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

eval("module.exports = function extend(target, source) { //A simple function to copy properties from one object to another\n    if (!target) { //Check if a target was provided, otherwise create a new empty object to return\n        target = {};\n    }\n\n    if (source) {\n        for (var propName in source) {\n            if (source.hasOwnProperty(propName)) { //Only look at source properties that are not inherited\n                target[propName] = source[propName]; //Copy the property\n            }\n        }\n    }\n\n    return target;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vcmFwdG9yLXV0aWwvZXh0ZW5kLmpzP2Y3NGQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHsgLy9BIHNpbXBsZSBmdW5jdGlvbiB0byBjb3B5IHByb3BlcnRpZXMgZnJvbSBvbmUgb2JqZWN0IHRvIGFub3RoZXJcbiAgICBpZiAoIXRhcmdldCkgeyAvL0NoZWNrIGlmIGEgdGFyZ2V0IHdhcyBwcm92aWRlZCwgb3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eSBvYmplY3QgdG8gcmV0dXJuXG4gICAgICAgIHRhcmdldCA9IHt9O1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkgeyAvL09ubHkgbG9vayBhdCBzb3VyY2UgcHJvcGVydGllcyB0aGF0IGFyZSBub3QgaW5oZXJpdGVkXG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BOYW1lXSA9IHNvdXJjZVtwcm9wTmFtZV07IC8vQ29weSB0aGUgcHJvcGVydHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yYXB0b3ItdXRpbC9leHRlbmQuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

eval("var copyProps = __webpack_require__(18);\n\nfunction inherit(ctor, superCtor, shouldCopyProps) {\n    var oldProto = ctor.prototype;\n    var newProto = ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n            value: ctor,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (oldProto && shouldCopyProps !== false) {\n        copyProps(oldProto, newProto);\n    }\n    ctor.$super = superCtor;\n    ctor.prototype = newProto;\n    return ctor;\n}\n\n\nmodule.exports = inherit;\ninherit._inherit = inherit;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vcmFwdG9yLXV0aWwvaW5oZXJpdC5qcz82YTgxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjb3B5UHJvcHMgPSByZXF1aXJlKCcuL2NvcHlQcm9wcycpO1xuXG5mdW5jdGlvbiBpbmhlcml0KGN0b3IsIHN1cGVyQ3Rvciwgc2hvdWxkQ29weVByb3BzKSB7XG4gICAgdmFyIG9sZFByb3RvID0gY3Rvci5wcm90b3R5cGU7XG4gICAgdmFyIG5ld1Byb3RvID0gY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChvbGRQcm90byAmJiBzaG91bGRDb3B5UHJvcHMgIT09IGZhbHNlKSB7XG4gICAgICAgIGNvcHlQcm9wcyhvbGRQcm90bywgbmV3UHJvdG8pO1xuICAgIH1cbiAgICBjdG9yLiRzdXBlciA9IHN1cGVyQ3RvcjtcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ld1Byb3RvO1xuICAgIHJldHVybiBjdG9yO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gaW5oZXJpdDtcbmluaGVyaXQuX2luaGVyaXQgPSBpbmhlcml0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JhcHRvci11dGlsL2luaGVyaXQuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

eval("/* jshint newcap:false */\nfunction VNode() {}\n\nVNode.prototype = {\n    $__VNode: function(finalChildCount) {\n        this.$__finalChildCount = finalChildCount;\n        this.$__childCount = 0;\n        this.$__firstChild = null;\n        this.$__lastChild = null;\n        this.$__parentNode = null;\n        this.$__nextSibling = null;\n    },\n\n    get firstChild() {\n        var firstChild = this.$__firstChild;\n\n        if (firstChild && firstChild.$__DocumentFragment) {\n            var nestedFirstChild = firstChild.firstChild;\n            // The first child is a DocumentFragment node.\n            // If the DocumentFragment node has a first child then we will return that.\n            // Otherwise, the DocumentFragment node is not *really* the first child and\n            // we need to skip to its next sibling\n            return nestedFirstChild || firstChild.nextSibling;\n        }\n\n        return firstChild;\n    },\n\n    get nextSibling() {\n        var nextSibling = this.$__nextSibling;\n\n        if (nextSibling) {\n            if (nextSibling.$__DocumentFragment) {\n                var firstChild = nextSibling.firstChild;\n                return firstChild || nextSibling.nextSibling;\n            }\n        } else {\n            var parentNode = this.$__parentNode;\n            if (parentNode && parentNode.$__DocumentFragment) {\n                return parentNode.nextSibling;\n            }\n        }\n\n        return nextSibling;\n    },\n\n    $__appendChild: function(child) {\n        this.$__childCount++;\n\n        if (this.$__isTextArea) {\n            if (child.$__Text) {\n                var childValue = child.nodeValue;\n                this.$__value = (this.$__value || '') + childValue;\n            } else {\n                throw TypeError();\n            }\n        } else {\n            var lastChild = this.$__lastChild;\n\n            child.$__parentNode = this;\n\n            if (lastChild) {\n                lastChild.$__nextSibling = child;\n            } else {\n                this.$__firstChild = child;\n            }\n\n            this.$__lastChild = child;\n        }\n\n        return child;\n    },\n\n    $__finishChild: function finishChild() {\n        if (this.$__childCount == this.$__finalChildCount && this.$__parentNode) {\n            return this.$__parentNode.$__finishChild();\n        } else {\n            return this;\n        }\n    },\n\n    actualize: function(doc) {\n        var actualNode = this.$__actualize(doc);\n\n        var curChild = this.firstChild;\n\n        while(curChild) {\n            actualNode.appendChild(curChild.actualize(doc));\n            curChild = curChild.nextSibling;\n        }\n\n        return actualNode;\n    }\n\n    // ,toJSON: function() {\n    //     var clone = Object.assign({\n    //         nodeType: this.nodeType\n    //     }, this);\n    //\n    //     for (var k in clone) {\n    //         if (k.startsWith('_')) {\n    //             delete clone[k];\n    //         }\n    //     }\n    //     delete clone._nextSibling;\n    //     delete clone._lastChild;\n    //     delete clone.parentNode;\n    //     return clone;\n    // }\n};\n\nmodule.exports = VNode;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vbWFya28vcnVudGltZS92ZG9tL1ZOb2RlLmpzP2ExYzUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoganNoaW50IG5ld2NhcDpmYWxzZSAqL1xuZnVuY3Rpb24gVk5vZGUoKSB7fVxuXG5WTm9kZS5wcm90b3R5cGUgPSB7XG4gICAgJF9fVk5vZGU6IGZ1bmN0aW9uKGZpbmFsQ2hpbGRDb3VudCkge1xuICAgICAgICB0aGlzLiRfX2ZpbmFsQ2hpbGRDb3VudCA9IGZpbmFsQ2hpbGRDb3VudDtcbiAgICAgICAgdGhpcy4kX19jaGlsZENvdW50ID0gMDtcbiAgICAgICAgdGhpcy4kX19maXJzdENoaWxkID0gbnVsbDtcbiAgICAgICAgdGhpcy4kX19sYXN0Q2hpbGQgPSBudWxsO1xuICAgICAgICB0aGlzLiRfX3BhcmVudE5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLiRfX25leHRTaWJsaW5nID0gbnVsbDtcbiAgICB9LFxuXG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7XG4gICAgICAgIHZhciBmaXJzdENoaWxkID0gdGhpcy4kX19maXJzdENoaWxkO1xuXG4gICAgICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQuJF9fRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICAgICAgdmFyIG5lc3RlZEZpcnN0Q2hpbGQgPSBmaXJzdENoaWxkLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAvLyBUaGUgZmlyc3QgY2hpbGQgaXMgYSBEb2N1bWVudEZyYWdtZW50IG5vZGUuXG4gICAgICAgICAgICAvLyBJZiB0aGUgRG9jdW1lbnRGcmFnbWVudCBub2RlIGhhcyBhIGZpcnN0IGNoaWxkIHRoZW4gd2Ugd2lsbCByZXR1cm4gdGhhdC5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIERvY3VtZW50RnJhZ21lbnQgbm9kZSBpcyBub3QgKnJlYWxseSogdGhlIGZpcnN0IGNoaWxkIGFuZFxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBza2lwIHRvIGl0cyBuZXh0IHNpYmxpbmdcbiAgICAgICAgICAgIHJldHVybiBuZXN0ZWRGaXJzdENoaWxkIHx8IGZpcnN0Q2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlyc3RDaGlsZDtcbiAgICB9LFxuXG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSB0aGlzLiRfX25leHRTaWJsaW5nO1xuXG4gICAgICAgIGlmIChuZXh0U2libGluZykge1xuICAgICAgICAgICAgaWYgKG5leHRTaWJsaW5nLiRfX0RvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RDaGlsZCA9IG5leHRTaWJsaW5nLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0Q2hpbGQgfHwgbmV4dFNpYmxpbmcubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHRoaXMuJF9fcGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuJF9fRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5leHRTaWJsaW5nO1xuICAgIH0sXG5cbiAgICAkX19hcHBlbmRDaGlsZDogZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgdGhpcy4kX19jaGlsZENvdW50Kys7XG5cbiAgICAgICAgaWYgKHRoaXMuJF9faXNUZXh0QXJlYSkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLiRfX1RleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRWYWx1ZSA9IGNoaWxkLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLiRfX3ZhbHVlID0gKHRoaXMuJF9fdmFsdWUgfHwgJycpICsgY2hpbGRWYWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGFzdENoaWxkID0gdGhpcy4kX19sYXN0Q2hpbGQ7XG5cbiAgICAgICAgICAgIGNoaWxkLiRfX3BhcmVudE5vZGUgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAobGFzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgbGFzdENoaWxkLiRfX25leHRTaWJsaW5nID0gY2hpbGQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuJF9fZmlyc3RDaGlsZCA9IGNoaWxkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRfX2xhc3RDaGlsZCA9IGNoaWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0sXG5cbiAgICAkX19maW5pc2hDaGlsZDogZnVuY3Rpb24gZmluaXNoQ2hpbGQoKSB7XG4gICAgICAgIGlmICh0aGlzLiRfX2NoaWxkQ291bnQgPT0gdGhpcy4kX19maW5hbENoaWxkQ291bnQgJiYgdGhpcy4kX19wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kX19wYXJlbnROb2RlLiRfX2ZpbmlzaENoaWxkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhY3R1YWxpemU6IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICB2YXIgYWN0dWFsTm9kZSA9IHRoaXMuJF9fYWN0dWFsaXplKGRvYyk7XG5cbiAgICAgICAgdmFyIGN1ckNoaWxkID0gdGhpcy5maXJzdENoaWxkO1xuXG4gICAgICAgIHdoaWxlKGN1ckNoaWxkKSB7XG4gICAgICAgICAgICBhY3R1YWxOb2RlLmFwcGVuZENoaWxkKGN1ckNoaWxkLmFjdHVhbGl6ZShkb2MpKTtcbiAgICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWN0dWFsTm9kZTtcbiAgICB9XG5cbiAgICAvLyAsdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAvLyAgICAgdmFyIGNsb25lID0gT2JqZWN0LmFzc2lnbih7XG4gICAgLy8gICAgICAgICBub2RlVHlwZTogdGhpcy5ub2RlVHlwZVxuICAgIC8vICAgICB9LCB0aGlzKTtcbiAgICAvL1xuICAgIC8vICAgICBmb3IgKHZhciBrIGluIGNsb25lKSB7XG4gICAgLy8gICAgICAgICBpZiAoay5zdGFydHNXaXRoKCdfJykpIHtcbiAgICAvLyAgICAgICAgICAgICBkZWxldGUgY2xvbmVba107XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgZGVsZXRlIGNsb25lLl9uZXh0U2libGluZztcbiAgICAvLyAgICAgZGVsZXRlIGNsb25lLl9sYXN0Q2hpbGQ7XG4gICAgLy8gICAgIGRlbGV0ZSBjbG9uZS5wYXJlbnROb2RlO1xuICAgIC8vICAgICByZXR1cm4gY2xvbmU7XG4gICAgLy8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWTm9kZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYXJrby9ydW50aW1lL3Zkb20vVk5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

eval("/* jshint newcap:false */\nvar slice = Array.prototype.slice;\n\nfunction isFunction(arg) {\n    return typeof arg === 'function';\n}\n\nfunction checkListener(listener) {\n    if (!isFunction(listener)) {\n        throw TypeError('Invalid listener');\n    }\n}\n\nfunction invokeListener(ee, listener, args) {\n    switch (args.length) {\n        // fast cases\n        case 1:\n            listener.call(ee);\n            break;\n        case 2:\n            listener.call(ee, args[1]);\n            break;\n        case 3:\n            listener.call(ee, args[1], args[2]);\n            break;\n            // slower\n        default:\n            listener.apply(ee, slice.call(args, 1));\n    }\n}\n\nfunction addListener(eventEmitter, type, listener, prepend) {\n    checkListener(listener);\n\n    var events = eventEmitter.$e || (eventEmitter.$e = {});\n\n    var listeners = events[type];\n    if (listeners) {\n        if (isFunction(listeners)) {\n            events[type] = prepend ? [listener, listeners] : [listeners, listener];\n        } else {\n            if (prepend) {\n                listeners.unshift(listener);\n            } else {\n                listeners.push(listener);\n            }\n        }\n\n    } else {\n        events[type] = listener;\n    }\n    return eventEmitter;\n}\n\nfunction EventEmitter() {\n    this.$e = this.$e || {};\n}\n\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype = {\n    $e: null,\n\n    emit: function(type) {\n        var args = arguments;\n\n        var events = this.$e;\n        if (!events) {\n            return;\n        }\n\n        var listeners = events && events[type];\n        if (!listeners) {\n            // If there is no 'error' event listener then throw.\n            if (type === 'error') {\n                var error = args[1];\n                if (!(error instanceof Error)) {\n                    var context = error;\n                    error = new Error('Error: ' + context);\n                    error.context = context;\n                }\n\n                throw error; // Unhandled 'error' event\n            }\n\n            return false;\n        }\n\n        if (isFunction(listeners)) {\n            invokeListener(this, listeners, args);\n        } else {\n            listeners = slice.call(listeners);\n\n            for (var i=0, len=listeners.length; i<len; i++) {\n                var listener = listeners[i];\n                invokeListener(this, listener, args);\n            }\n        }\n\n        return true;\n    },\n\n    on: function(type, listener) {\n        return addListener(this, type, listener, false);\n    },\n\n    prependListener: function(type, listener) {\n        return addListener(this, type, listener, true);\n    },\n\n    once: function(type, listener) {\n        checkListener(listener);\n\n        function g() {\n            this.removeListener(type, g);\n\n            if (listener) {\n                listener.apply(this, arguments);\n                listener = null;\n            }\n        }\n\n        this.on(type, g);\n\n        return this;\n    },\n\n    // emits a 'removeListener' event iff the listener was removed\n    removeListener: function(type, listener) {\n        checkListener(listener);\n\n        var events = this.$e;\n        var listeners;\n\n        if (events && (listeners = events[type])) {\n            if (isFunction(listeners)) {\n                if (listeners === listener) {\n                    delete events[type];\n                }\n            } else {\n                for (var i=listeners.length-1; i>=0; i--) {\n                    if (listeners[i] === listener) {\n                        listeners.splice(i, 1);\n                    }\n                }\n            }\n        }\n\n        return this;\n    },\n\n    removeAllListeners: function(type) {\n        var events = this.$e;\n        if (events) {\n            delete events[type];\n        }\n    },\n\n    listenerCount: function(type) {\n        var events = this.$e;\n        var listeners = events && events[type];\n        return listeners ? (isFunction(listeners) ? 1 : listeners.length) : 0;\n    }\n};\n\nmodule.exports = EventEmitter;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZXZlbnRzLWxpZ2h0L3NyYy9pbmRleC5qcz85ZDdlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGpzaGludCBuZXdjYXA6ZmFsc2UgKi9cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIGxpc3RlbmVyJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VMaXN0ZW5lcihlZSwgbGlzdGVuZXIsIGFyZ3MpIHtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgbGlzdGVuZXIuY2FsbChlZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgbGlzdGVuZXIuY2FsbChlZSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgbGlzdGVuZXIuY2FsbChlZSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIHNsb3dlclxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbGlzdGVuZXIuYXBwbHkoZWUsIHNsaWNlLmNhbGwoYXJncywgMSkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZXZlbnRFbWl0dGVyLCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgdmFyIGV2ZW50cyA9IGV2ZW50RW1pdHRlci4kZSB8fCAoZXZlbnRFbWl0dGVyLiRlID0ge30pO1xuXG4gICAgdmFyIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IHByZXBlbmQgPyBbbGlzdGVuZXIsIGxpc3RlbmVyc10gOiBbbGlzdGVuZXJzLCBsaXN0ZW5lcl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50RW1pdHRlcjtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICAgIHRoaXMuJGUgPSB0aGlzLiRlIHx8IHt9O1xufVxuXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlID0ge1xuICAgICRlOiBudWxsLFxuXG4gICAgZW1pdDogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy4kZTtcbiAgICAgICAgaWYgKCFldmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBldmVudHMgJiYgZXZlbnRzW3R5cGVdO1xuICAgICAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBhcmdzWzFdO1xuICAgICAgICAgICAgICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdFcnJvcjogJyArIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgICAgICAgICAgaW52b2tlTGlzdGVuZXIodGhpcywgbGlzdGVuZXJzLCBhcmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RlbmVycyA9IHNsaWNlLmNhbGwobGlzdGVuZXJzKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBsZW49bGlzdGVuZXJzLmxlbmd0aDsgaTxsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgICAgICAgICAgICAgICBpbnZva2VMaXN0ZW5lcih0aGlzLCBsaXN0ZW5lciwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgb246IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH0sXG5cbiAgICBwcmVwZW5kTGlzdGVuZXI6IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIG9uY2U6IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGcoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub24odHlwZSwgZyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG4gICAgcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLiRlO1xuICAgICAgICB2YXIgbGlzdGVuZXJzO1xuXG4gICAgICAgIGlmIChldmVudHMgJiYgKGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXSkpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT1saXN0ZW5lcnMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuJGU7XG4gICAgICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbGlzdGVuZXJDb3VudDogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy4kZTtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IGV2ZW50cyAmJiBldmVudHNbdHlwZV07XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcnMgPyAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpID8gMSA6IGxpc3RlbmVycy5sZW5ndGgpIDogMDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXZlbnRzLWxpZ2h0L3NyYy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

eval("var loadComponent = __webpack_require__(26);\nvar defineComponent = __webpack_require__(11);\n\nvar registered = {};\nvar loaded = {};\nvar componentTypes = {};\n\nfunction register(typeName, def) {\n    // We do this to kick off registering of nested components\n    // but we don't use the return value just yet since there\n    // is a good chance that it resulted in a circular dependency\n    def();\n\n    registered[typeName] = def;\n    delete loaded[typeName];\n    delete componentTypes[typeName];\n    return typeName;\n}\n\nfunction load(typeName) {\n    var target = loaded[typeName];\n    if (!target) {\n        target = registered[typeName];\n\n        if (target) {\n            target = target();\n        } else {\n            target = loadComponent(typeName); // Assume the typeName has been fully resolved already\n        }\n\n        if (!target) {\n            throw Error('Not found: ' + typeName);\n        }\n\n        loaded[typeName] = target;\n    }\n\n    return target;\n}\n\nfunction getComponentClass(typeName) {\n    var ComponentClass = componentTypes[typeName];\n\n    if (ComponentClass) {\n        return ComponentClass;\n    }\n\n    ComponentClass = load(typeName);\n\n    ComponentClass = ComponentClass.Component || ComponentClass;\n\n    if (!ComponentClass.$__isComponent) {\n        ComponentClass = defineComponent(ComponentClass, ComponentClass.renderer);\n    }\n\n    // Make the component \"type\" accessible on each component instance\n    ComponentClass.prototype.$__type = typeName;\n\n    componentTypes[typeName] = ComponentClass;\n\n    return ComponentClass;\n}\n\nfunction createComponent(typeName, id) {\n    var ComponentClass = getComponentClass(typeName);\n    return new ComponentClass(id);\n}\n\nexports.$__register = register;\nexports.$__createComponent = createComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vbWFya28vY29tcG9uZW50cy9yZWdpc3RyeS1icm93c2VyLmpzP2VkOGMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGxvYWRDb21wb25lbnQgPSByZXF1aXJlKCcuL2xvYWRDb21wb25lbnQnKTtcbnZhciBkZWZpbmVDb21wb25lbnQgPSByZXF1aXJlKCcuL2RlZmluZUNvbXBvbmVudCcpO1xuXG52YXIgcmVnaXN0ZXJlZCA9IHt9O1xudmFyIGxvYWRlZCA9IHt9O1xudmFyIGNvbXBvbmVudFR5cGVzID0ge307XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyKHR5cGVOYW1lLCBkZWYpIHtcbiAgICAvLyBXZSBkbyB0aGlzIHRvIGtpY2sgb2ZmIHJlZ2lzdGVyaW5nIG9mIG5lc3RlZCBjb21wb25lbnRzXG4gICAgLy8gYnV0IHdlIGRvbid0IHVzZSB0aGUgcmV0dXJuIHZhbHVlIGp1c3QgeWV0IHNpbmNlIHRoZXJlXG4gICAgLy8gaXMgYSBnb29kIGNoYW5jZSB0aGF0IGl0IHJlc3VsdGVkIGluIGEgY2lyY3VsYXIgZGVwZW5kZW5jeVxuICAgIGRlZigpO1xuXG4gICAgcmVnaXN0ZXJlZFt0eXBlTmFtZV0gPSBkZWY7XG4gICAgZGVsZXRlIGxvYWRlZFt0eXBlTmFtZV07XG4gICAgZGVsZXRlIGNvbXBvbmVudFR5cGVzW3R5cGVOYW1lXTtcbiAgICByZXR1cm4gdHlwZU5hbWU7XG59XG5cbmZ1bmN0aW9uIGxvYWQodHlwZU5hbWUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gbG9hZGVkW3R5cGVOYW1lXTtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICB0YXJnZXQgPSByZWdpc3RlcmVkW3R5cGVOYW1lXTtcblxuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldCA9IGxvYWRDb21wb25lbnQodHlwZU5hbWUpOyAvLyBBc3N1bWUgdGhlIHR5cGVOYW1lIGhhcyBiZWVuIGZ1bGx5IHJlc29sdmVkIGFscmVhZHlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignTm90IGZvdW5kOiAnICsgdHlwZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9hZGVkW3R5cGVOYW1lXSA9IHRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbGFzcyh0eXBlTmFtZSkge1xuICAgIHZhciBDb21wb25lbnRDbGFzcyA9IGNvbXBvbmVudFR5cGVzW3R5cGVOYW1lXTtcblxuICAgIGlmIChDb21wb25lbnRDbGFzcykge1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50Q2xhc3M7XG4gICAgfVxuXG4gICAgQ29tcG9uZW50Q2xhc3MgPSBsb2FkKHR5cGVOYW1lKTtcblxuICAgIENvbXBvbmVudENsYXNzID0gQ29tcG9uZW50Q2xhc3MuQ29tcG9uZW50IHx8IENvbXBvbmVudENsYXNzO1xuXG4gICAgaWYgKCFDb21wb25lbnRDbGFzcy4kX19pc0NvbXBvbmVudCkge1xuICAgICAgICBDb21wb25lbnRDbGFzcyA9IGRlZmluZUNvbXBvbmVudChDb21wb25lbnRDbGFzcywgQ29tcG9uZW50Q2xhc3MucmVuZGVyZXIpO1xuICAgIH1cblxuICAgIC8vIE1ha2UgdGhlIGNvbXBvbmVudCBcInR5cGVcIiBhY2Nlc3NpYmxlIG9uIGVhY2ggY29tcG9uZW50IGluc3RhbmNlXG4gICAgQ29tcG9uZW50Q2xhc3MucHJvdG90eXBlLiRfX3R5cGUgPSB0eXBlTmFtZTtcblxuICAgIGNvbXBvbmVudFR5cGVzW3R5cGVOYW1lXSA9IENvbXBvbmVudENsYXNzO1xuXG4gICAgcmV0dXJuIENvbXBvbmVudENsYXNzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQodHlwZU5hbWUsIGlkKSB7XG4gICAgdmFyIENvbXBvbmVudENsYXNzID0gZ2V0Q29tcG9uZW50Q2xhc3ModHlwZU5hbWUpO1xuICAgIHJldHVybiBuZXcgQ29tcG9uZW50Q2xhc3MoaWQpO1xufVxuXG5leHBvcnRzLiRfX3JlZ2lzdGVyID0gcmVnaXN0ZXI7XG5leHBvcnRzLiRfX2NyZWF0ZUNvbXBvbmVudCA9IGNyZWF0ZUNvbXBvbmVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYXJrby9jb21wb25lbnRzL3JlZ2lzdHJ5LWJyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

eval("var actualCreateOut;\n\nfunction setCreateOut(createOutFunc) {\n    actualCreateOut = createOutFunc;\n}\n\nfunction createOut(globalData) {\n    return actualCreateOut(globalData);\n}\n\ncreateOut.$__setCreateOut = setCreateOut;\n\nmodule.exports = createOut;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vbWFya28vcnVudGltZS9jcmVhdGVPdXQuanM/YzhlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYWN0dWFsQ3JlYXRlT3V0O1xuXG5mdW5jdGlvbiBzZXRDcmVhdGVPdXQoY3JlYXRlT3V0RnVuYykge1xuICAgIGFjdHVhbENyZWF0ZU91dCA9IGNyZWF0ZU91dEZ1bmM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU91dChnbG9iYWxEYXRhKSB7XG4gICAgcmV0dXJuIGFjdHVhbENyZWF0ZU91dChnbG9iYWxEYXRhKTtcbn1cblxuY3JlYXRlT3V0LiRfX3NldENyZWF0ZU91dCA9IHNldENyZWF0ZU91dDtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVPdXQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcmtvL3J1bnRpbWUvY3JlYXRlT3V0LmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

eval("var EventEmitter = __webpack_require__(4);\nmodule.exports = new EventEmitter();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vbWFya28vcnVudGltZS9ldmVudHMuanM/MTQxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzLWxpZ2h0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWFya28vcnVudGltZS9ldmVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(43)\n__webpack_require__(8);\n// Compiled using marko@4.1.2 - DO NOT EDIT\n\"use strict\";\n\nvar marko_template = module.exports = __webpack_require__(40).t(),\n    marko_component = {\n        onCreate: function() {\n          this.state = {\n              count: 0\n            };\n        },\n        increment: function() {\n          this.state.count++;\n        }\n      },\n    marko_components = __webpack_require__(25),\n    marko_registerComponent = marko_components.rc,\n    marko_componentType = marko_registerComponent(\"/template$1.0.0/public/counter.marko\", function() {\n      return module.exports;\n    });\n\nfunction render(input, out, __component, component, state) {\n  var data = input;\n\n  out.e(\"DIV\", {\n      \"class\": \"count\",\n      id: __component.elId(\"_r0\")\n    }, 1, 4)\n    .t(state.count);\n\n  out.e(\"BUTTON\", {\n      \"class\": \"example-button\",\n      id: __component.elId(\"_r1\"),\n      \"data-_onclick\": __component.d(\"increment\")\n    }, 1, 4)\n    .t(\"Click me!\");\n}\n\nmarko_template._ = marko_components.r(render, {\n    type: marko_componentType,\n    roots: [\n      \"_r0\",\n      \"_r1\"\n    ]\n  }, marko_component);\n\nmarko_template.Component = marko_components.c(marko_component, marko_template._);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3B1YmxpYy9jb3VudGVyLm1hcmtvP2NiMzIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXIhLi4vbm9kZV9tb2R1bGVzL21hcmtvLWxvYWRlci9zcmMvY29kZS1sb2FkZXIuanM/e1xcXCJjb2RlXFxcIjpcXFwiLmNvdW50IHtcXFxcbiAgICAgICAgY29sb3I6IzA5YztcXFxcbiAgICAgICAgZm9udC1zaXplOjNlbTtcXFxcbiAgICB9XFxcXG4gICAgLmV4YW1wbGUtYnV0dG9uIHtcXFxcbiAgICAgICAgZm9udC1zaXplOjFlbTtcXFxcbiAgICAgICAgcGFkZGluZzowLjVlbTtcXFxcbiAgICB9XFxcIn0hLi9jb3VudGVyLm1hcmtvXCIpXG5yZXF1aXJlKCcvaG9tZS9hbGV4L1Byb2plY3RzL0dvL3NyYy90ZW1wbGF0ZS9wdWJsaWMvY291bnRlci5tYXJrbycpO1xuLy8gQ29tcGlsZWQgdXNpbmcgbWFya29ANC4xLjIgLSBETyBOT1QgRURJVFxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtYXJrb190ZW1wbGF0ZSA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm1hcmtvL3Zkb21cIikudCgpLFxuICAgIG1hcmtvX2NvbXBvbmVudCA9IHtcbiAgICAgICAgb25DcmVhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICAgIGNvdW50OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBpbmNyZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuc3RhdGUuY291bnQrKztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICBtYXJrb19jb21wb25lbnRzID0gcmVxdWlyZShcIm1hcmtvL2NvbXBvbmVudHNcIiksXG4gICAgbWFya29fcmVnaXN0ZXJDb21wb25lbnQgPSBtYXJrb19jb21wb25lbnRzLnJjLFxuICAgIG1hcmtvX2NvbXBvbmVudFR5cGUgPSBtYXJrb19yZWdpc3RlckNvbXBvbmVudChcIi90ZW1wbGF0ZSQxLjAuMC9wdWJsaWMvY291bnRlci5tYXJrb1wiLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiAgICB9KTtcblxuZnVuY3Rpb24gcmVuZGVyKGlucHV0LCBvdXQsIF9fY29tcG9uZW50LCBjb21wb25lbnQsIHN0YXRlKSB7XG4gIHZhciBkYXRhID0gaW5wdXQ7XG5cbiAgb3V0LmUoXCJESVZcIiwge1xuICAgICAgXCJjbGFzc1wiOiBcImNvdW50XCIsXG4gICAgICBpZDogX19jb21wb25lbnQuZWxJZChcIl9yMFwiKVxuICAgIH0sIDEsIDQpXG4gICAgLnQoc3RhdGUuY291bnQpO1xuXG4gIG91dC5lKFwiQlVUVE9OXCIsIHtcbiAgICAgIFwiY2xhc3NcIjogXCJleGFtcGxlLWJ1dHRvblwiLFxuICAgICAgaWQ6IF9fY29tcG9uZW50LmVsSWQoXCJfcjFcIiksXG4gICAgICBcImRhdGEtX29uY2xpY2tcIjogX19jb21wb25lbnQuZChcImluY3JlbWVudFwiKVxuICAgIH0sIDEsIDQpXG4gICAgLnQoXCJDbGljayBtZSFcIik7XG59XG5cbm1hcmtvX3RlbXBsYXRlLl8gPSBtYXJrb19jb21wb25lbnRzLnIocmVuZGVyLCB7XG4gICAgdHlwZTogbWFya29fY29tcG9uZW50VHlwZSxcbiAgICByb290czogW1xuICAgICAgXCJfcjBcIixcbiAgICAgIFwiX3IxXCJcbiAgICBdXG4gIH0sIG1hcmtvX2NvbXBvbmVudCk7XG5cbm1hcmtvX3RlbXBsYXRlLkNvbXBvbmVudCA9IG1hcmtvX2NvbXBvbmVudHMuYyhtYXJrb19jb21wb25lbnQsIG1hcmtvX3RlbXBsYXRlLl8pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wdWJsaWMvY291bnRlci5tYXJrb1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* jshint newcap:false */\n\nvar domInsert = __webpack_require__(16);\nvar marko = __webpack_require__(31);\nvar componentsUtil = __webpack_require__(0);\nvar componentLookup = componentsUtil.$__componentLookup;\nvar emitLifecycleEvent = componentsUtil.$__emitLifecycleEvent;\nvar destroyComponentForEl = componentsUtil.$__destroyComponentForEl;\nvar destroyElRecursive = componentsUtil.$__destroyElRecursive;\nvar getElementById = componentsUtil.$__getElementById;\nvar EventEmitter = __webpack_require__(4);\nvar RenderResult = __webpack_require__(15);\nvar SubscriptionTracker = __webpack_require__(21);\nvar inherit = __webpack_require__(2);\nvar updateManager = __webpack_require__(28);\nvar morphdom = __webpack_require__(29);\nvar eventDelegation = __webpack_require__(12);\n\nvar slice = Array.prototype.slice;\n\nvar MORPHDOM_SKIP = true;\n\nvar COMPONENT_SUBSCRIBE_TO_OPTIONS;\nvar NON_COMPONENT_SUBSCRIBE_TO_OPTIONS = {\n    addDestroyListener: false\n};\n\nvar emit = EventEmitter.prototype.emit;\n\nfunction removeListener(removeEventListenerHandle) {\n    removeEventListenerHandle();\n}\n\nfunction checkCompatibleComponent(componentsContext, el) {\n    var component = el._w;\n    while(component) {\n        var id = component.id;\n        var newComponentDef = componentsContext.$__componentsById[id];\n        if (newComponentDef && component.$__type == newComponentDef.$__component.$__type) {\n            break;\n        }\n\n        var rootFor = component.$__rootFor;\n        if (rootFor)  {\n            component = rootFor;\n        } else {\n            component.$__destroyShallow();\n            break;\n        }\n    }\n}\n\nfunction handleCustomEventWithMethodListener(component, targetMethodName, args, extraArgs) {\n    // Remove the \"eventType\" argument\n    args.push(component);\n\n    if (extraArgs) {\n        args = extraArgs.concat(args);\n    }\n\n\n    var targetComponent = componentLookup[component.$__scope];\n    var targetMethod = targetComponent[targetMethodName];\n    if (!targetMethod) {\n        throw Error('Method not found: ' + targetMethodName);\n    }\n\n    targetMethod.apply(targetComponent, args);\n}\n\nfunction getElIdHelper(component, componentElId, index) {\n    var id = component.id;\n\n    var elId = componentElId != null ? id + '-' + componentElId : id;\n\n    if (index != null) {\n        elId += '[' + index + ']';\n    }\n\n    return elId;\n}\n\n/**\n * This method is used to process \"update_<stateName>\" handler functions.\n * If all of the modified state properties have a user provided update handler\n * then a rerender will be bypassed and, instead, the DOM will be updated\n * looping over and invoking the custom update handlers.\n * @return {boolean} Returns true if if the DOM was updated. False, otherwise.\n */\nfunction processUpdateHandlers(component, stateChanges, oldState) {\n    var handlerMethod;\n    var handlers;\n\n    for (var propName in stateChanges) {\n        if (stateChanges.hasOwnProperty(propName)) {\n            var handlerMethodName = 'update_' + propName;\n\n            handlerMethod = component[handlerMethodName];\n            if (handlerMethod) {\n                (handlers || (handlers=[])).push([propName, handlerMethod]);\n            } else {\n                // This state change does not have a state handler so return false\n                // to force a rerender\n                return;\n            }\n        }\n    }\n\n    // If we got here then all of the changed state properties have\n    // an update handler or there are no state properties that actually\n    // changed.\n    if (handlers) {\n        // Otherwise, there are handlers for all of the changed properties\n        // so apply the updates using those handlers\n\n        handlers.forEach(function(handler, i) {\n            var propertyName = handler[0];\n            handlerMethod = handler[1];\n\n            var newValue = stateChanges[propertyName];\n            var oldValue = oldState[propertyName];\n            handlerMethod.call(component, newValue, oldValue);\n        });\n\n        emitLifecycleEvent(component, 'update');\n\n        component.$__reset();\n    }\n\n    return true;\n}\n\nfunction checkInputChanged(existingComponent, oldInput, newInput) {\n    if (oldInput != newInput) {\n        if (oldInput == null || newInput == null) {\n            return true;\n        }\n\n        var oldKeys = Object.keys(oldInput);\n        var newKeys = Object.keys(newInput);\n        var len = oldKeys.length;\n        if (len !== newKeys.length) {\n            return true;\n        }\n\n        for (var i=0; i<len; i++) {\n            var key = oldKeys[i];\n            if (oldInput[key] !== newInput[key]) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nfunction onNodeDiscarded(node) {\n    if (node.nodeType == 1) {\n        destroyComponentForEl(node);\n    }\n}\n\nfunction onBeforeNodeDiscarded(node) {\n    return eventDelegation.$__handleNodeDetach(node);\n}\n\nfunction onBeforeElUpdated(fromEl, componentsContext) {\n    var id = fromEl.id;\n\n    if (componentsContext && id) {\n        var preserved = componentsContext.$__preserved[id];\n\n        if (preserved && !preserved.$__bodyOnly) {\n            // Don't morph elements that are associated with components that are being\n            // reused or elements that are being preserved. For components being reused,\n            // the morphing will take place when the reused component updates.\n            return MORPHDOM_SKIP;\n        } else {\n            // We may need to destroy a Component associated with the current element\n            // if a new UI component was rendered to the same element and the types\n            // do not match\n            checkCompatibleComponent(componentsContext, fromEl);\n        }\n    }\n}\n\nfunction onBeforeElChildrenUpdated(el, componentsContext) {\n    var id = el.id;\n    if (componentsContext && id) {\n        var preserved = componentsContext.$__preserved[id];\n        if (preserved && preserved.$__bodyOnly) {\n            // Don't morph the children since they are preserved\n            return MORPHDOM_SKIP;\n        }\n    }\n}\n\nfunction onNodeAdded(node, componentsContext) {\n    eventDelegation.$__handleNodeAttach(node, componentsContext.$__out);\n}\n\nvar componentProto;\n\n/**\n * Base component type.\n *\n * NOTE: Any methods that are prefixed with an underscore should be considered private!\n */\nfunction Component(id, doc) {\n    EventEmitter.call(this);\n    this.id = id;\n    this.el = null;\n    this.$__state = null;\n    this.$__roots = null;\n    this.$__subscriptions = null;\n    this.$__domEventListenerHandles = null;\n    this.$__bubblingDomEvents = null;\n    this.$__customEvents = null;\n    this.$__scope = null;\n    this.$__renderInput = null;\n    this.$__input = undefined;\n\n    this.$__destroyed =\n        this.$__updateQueued =\n        this.$__dirty =\n        this.$__settingInput =\n        false;\n\n    this.$__document = doc;\n}\n\nComponent.prototype = componentProto = {\n    $__isComponent: true,\n\n    subscribeTo: function(target) {\n        if (!target) {\n            throw TypeError();\n        }\n\n        var subscriptions = this.$__subscriptions || (this.$__subscriptions = new SubscriptionTracker());\n\n        var subscribeToOptions = target.$__isComponent ?\n            COMPONENT_SUBSCRIBE_TO_OPTIONS :\n            NON_COMPONENT_SUBSCRIBE_TO_OPTIONS;\n\n        return subscriptions.subscribeTo(target, subscribeToOptions);\n    },\n\n    emit: function(eventType) {\n        var customEvents = this.$__customEvents;\n        var target;\n\n        if (customEvents && (target = customEvents[eventType])) {\n            var targetMethodName = target[0];\n            var extraArgs = target[1];\n            var args = slice.call(arguments, 1);\n\n            handleCustomEventWithMethodListener(this, targetMethodName, args, extraArgs);\n        }\n\n        if (this.listenerCount(eventType)) {\n            return emit.apply(this, arguments);\n        }\n    },\n    getElId: function (componentElId, index) {\n        return getElIdHelper(this, componentElId, index);\n    },\n    getEl: function (componentElId, index) {\n        var doc = this.$__document;\n\n        if (componentElId != null) {\n            return getElementById(doc, getElIdHelper(this, componentElId, index));\n        } else {\n            return this.el || getElementById(doc, getElIdHelper(this));\n        }\n    },\n    getEls: function(id) {\n        var els = [];\n        var i = 0;\n        var el;\n        while((el = this.getEl(id, i))) {\n            els.push(el);\n            i++;\n        }\n        return els;\n    },\n    getComponent: function(id, index) {\n        return componentLookup[getElIdHelper(this, id, index)];\n    },\n    getComponents: function(id) {\n        var components = [];\n        var i = 0;\n        var component;\n        while((component = componentLookup[getElIdHelper(this, id, i)])) {\n            components.push(component);\n            i++;\n        }\n        return components;\n    },\n    destroy: function() {\n        if (this.$__destroyed) {\n            return;\n        }\n\n        var els = this.els;\n\n        this.$__destroyShallow();\n\n        var rootComponents = this.$__rootComponents;\n        if (rootComponents) {\n            rootComponents.forEach(function(rootComponent) {\n                rootComponent.$__destroy();\n            });\n        }\n\n        els.forEach(function(el) {\n            destroyElRecursive(el);\n\n            var parentNode = el.parentNode;\n            if (parentNode) {\n                parentNode.removeChild(el);\n            }\n        });\n    },\n\n    $__destroyShallow: function() {\n        if (this.$__destroyed) {\n            return;\n        }\n\n        emitLifecycleEvent(this, 'destroy');\n        this.$__destroyed = true;\n\n        this.el = null;\n\n        // Unsubscribe from all DOM events\n        this.$__removeDOMEventListeners();\n\n        var subscriptions = this.$__subscriptions;\n        if (subscriptions) {\n            subscriptions.removeAllListeners();\n            this.$__subscriptions = null;\n        }\n\n        delete componentLookup[this.id];\n    },\n\n    isDestroyed: function() {\n        return this.$__destroyed;\n    },\n    get state() {\n        return this.$__state;\n    },\n    set state(newState) {\n        var state = this.$__state;\n        if (!state && !newState) {\n            return;\n        }\n\n        if (!state) {\n                state = this.$__state = new this.$__State(this);\n        }\n\n        state.$__replace(newState || {});\n\n        if (state.$__dirty) {\n            this.$__queueUpdate();\n        }\n\n        if (!newState) {\n            this.$__state = null;\n        }\n    },\n    setState: function(name, value) {\n        var state = this.$__state;\n\n        if (typeof name == 'object') {\n            // Merge in the new state with the old state\n            var newState = name;\n            for (var k in newState) {\n                if (newState.hasOwnProperty(k)) {\n                    state.$__set(k, newState[k], true /* ensure:true */);\n                }\n            }\n        } else {\n            state.$__set(name, value, true /* ensure:true */);\n        }\n    },\n\n    setStateDirty: function(name, value) {\n        var state = this.$__state;\n\n        if (arguments.length == 1) {\n            value = state[name];\n        }\n\n        state.$__set(name, value, true /* ensure:true */, true /* forceDirty:true */);\n    },\n\n    replaceState: function(newState) {\n        this.$__state.$__replace(newState);\n    },\n\n    get input() {\n        return this.$__input;\n    },\n    set input(newInput) {\n        if (this.$__settingInput) {\n            this.$__input = newInput;\n        } else {\n            this.$__setInput(newInput);\n        }\n    },\n\n    $__setInput: function(newInput, onInput, out) {\n        onInput = onInput || this.onInput;\n        var updatedInput;\n\n        var oldInput = this.$__input;\n        this.$__input = undefined;\n\n        if (onInput) {\n            // We need to set a flag to preview `this.input = foo` inside\n            // onInput causing infinite recursion\n            this.$__settingInput = true;\n            updatedInput = onInput.call(this, newInput || {}, out);\n            this.$__settingInput = false;\n        }\n\n        newInput = this.$__renderInput = updatedInput || newInput;\n\n        if ((this.$__dirty = checkInputChanged(this, oldInput, newInput))) {\n            this.$__queueUpdate();\n        }\n\n        if (this.$__input === undefined) {\n            this.$__input = newInput;\n        }\n\n        return newInput;\n    },\n\n    forceUpdate: function() {\n        this.$__dirty = true;\n        this.$__queueUpdate();\n    },\n\n    $__queueUpdate: function() {\n        if (!this.$__updateQueued) {\n            updateManager.$__queueComponentUpdate(this);\n        }\n    },\n\n    update: function() {\n        if (this.$__destroyed || !this.$__isDirty) {\n            return;\n        }\n\n        var input = this.$__input;\n        var state = this.$__state;\n\n        if (!this.$__dirty && state && state.$__dirty) {\n            if (processUpdateHandlers(this, state.$__changes, state.$__old, state)) {\n                state.$__dirty = false;\n            }\n        }\n\n        if (this.$__isDirty) {\n            // The UI component is still dirty after process state handlers\n            // then we should rerender\n\n            if (this.shouldUpdate(input, state) !== false) {\n                this.$__rerender();\n            }\n        }\n\n        this.$__reset();\n    },\n\n\n    get $__isDirty() {\n        return this.$__dirty || (this.$__state && this.$__state.$__dirty);\n    },\n\n    $__reset: function() {\n        this.$__dirty = false;\n        this.$__updateQueued = false;\n        this.$__renderInput = null;\n        var state = this.$__state;\n        if (state) {\n            state.$__reset();\n        }\n    },\n\n    shouldUpdate: function(newState, newProps) {\n        return true;\n    },\n\n    $__emitLifecycleEvent: function(eventType, eventArg1, eventArg2) {\n        emitLifecycleEvent(this, eventType, eventArg1, eventArg2);\n    },\n\n    $__rerender: function(input) {\n        if (input) {\n            this.input = input;\n        }\n\n        var self = this;\n        var renderer = self.$__renderer;\n\n        if (!renderer) {\n            throw TypeError();\n        }\n\n        var globalData = {\n            $w: self\n        };\n\n        var fromEls = self.$__getRootEls({});\n        var doc = self.$__document;\n        input = this.$__renderInput || this.$__input;\n\n        updateManager.$__batchUpdate(function() {\n            var createOut = renderer.createOut || marko.createOut;\n            var out = createOut(globalData);\n            out.$__document = self.$__document;\n            renderer(input, out);\n            var result = new RenderResult(out);\n            var targetNode = out.$__getOutput();\n\n            var componentsContext = out.global.components;\n\n            var fromEl;\n\n            var targetEl = targetNode.firstChild;\n            while(targetEl) {\n                var id = targetEl.id;\n\n                if (id) {\n                    fromEl = fromEls[id];\n                    if (fromEl) {\n                        morphdom(\n                            fromEl,\n                            targetEl,\n                            componentsContext,\n                            onNodeAdded,\n                            onBeforeElUpdated,\n                            onBeforeNodeDiscarded,\n                            onNodeDiscarded,\n                            onBeforeElChildrenUpdated);\n                    }\n                }\n\n                targetEl = targetEl.nextSibling;\n            }\n\n            result.afterInsert(doc);\n\n            out.emit('$__componentsInitialized');\n        });\n\n        this.$__reset();\n    },\n\n    $__getRootEls: function(rootEls) {\n        var i, len;\n\n        var componentEls = this.els;\n\n        for (i=0, len=componentEls.length; i<len; i++) {\n            var componentEl = componentEls[i];\n            rootEls[componentEl.id] = componentEl;\n        }\n\n        var rootComponents = this.$__rootComponents;\n        if (rootComponents) {\n            for (i=0, len=rootComponents.length; i<len; i++) {\n                var rootComponent = rootComponents[i];\n                rootComponent.$__getRootEls(rootEls);\n            }\n        }\n\n        return rootEls;\n    },\n\n    $__removeDOMEventListeners: function() {\n        var eventListenerHandles = this.$__domEventListenerHandles;\n        if (eventListenerHandles) {\n            eventListenerHandles.forEach(removeListener);\n            this.$__domEventListenerHandles = null;\n        }\n    },\n\n    get $__rawState() {\n        var state = this.$__state;\n        return state && state.$__raw;\n    },\n\n    $__setCustomEvents: function(customEvents, scope) {\n        if (customEvents) {\n            var finalCustomEvents = this.$__customEvents = {};\n            this.$__scope = scope;\n\n            customEvents.forEach(function(customEvent) {\n                var eventType = customEvent[0];\n                var targetMethodName = customEvent[1];\n                var extraArgs = customEvent[2];\n\n                finalCustomEvents[eventType] = [targetMethodName, extraArgs];\n            });\n        }\n    }\n};\n\ncomponentProto.elId = componentProto.getElId;\ncomponentProto.$__update = componentProto.update;\ncomponentProto.$__destroy = componentProto.destroy;\n\n// Add all of the following DOM methods to Component.prototype:\n// - appendTo(referenceEl)\n// - replace(referenceEl)\n// - replaceChildrenOf(referenceEl)\n// - insertBefore(referenceEl)\n// - insertAfter(referenceEl)\n// - prependTo(referenceEl)\ndomInsert(\n    componentProto,\n    function getEl(component) {\n        var els = this.els;\n        var elCount = els.length;\n        if (elCount > 1) {\n            var fragment = component.$__document.createDocumentFragment();\n            els.forEach(function(el) {\n                fragment.appendChild(el);\n            });\n            return fragment;\n        } else {\n            return els[0];\n        }\n    },\n    function afterInsert(component) {\n        return component;\n    });\n\ninherit(Component, EventEmitter);\n\nmodule.exports = Component;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vbWFya28vY29tcG9uZW50cy9Db21wb25lbnQuanM/MGQxNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKiBqc2hpbnQgbmV3Y2FwOmZhbHNlICovXG5cbnZhciBkb21JbnNlcnQgPSByZXF1aXJlKCcuLi9ydW50aW1lL2RvbS1pbnNlcnQnKTtcbnZhciBtYXJrbyA9IHJlcXVpcmUoJy4uLycpO1xudmFyIGNvbXBvbmVudHNVdGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgY29tcG9uZW50TG9va3VwID0gY29tcG9uZW50c1V0aWwuJF9fY29tcG9uZW50TG9va3VwO1xudmFyIGVtaXRMaWZlY3ljbGVFdmVudCA9IGNvbXBvbmVudHNVdGlsLiRfX2VtaXRMaWZlY3ljbGVFdmVudDtcbnZhciBkZXN0cm95Q29tcG9uZW50Rm9yRWwgPSBjb21wb25lbnRzVXRpbC4kX19kZXN0cm95Q29tcG9uZW50Rm9yRWw7XG52YXIgZGVzdHJveUVsUmVjdXJzaXZlID0gY29tcG9uZW50c1V0aWwuJF9fZGVzdHJveUVsUmVjdXJzaXZlO1xudmFyIGdldEVsZW1lbnRCeUlkID0gY29tcG9uZW50c1V0aWwuJF9fZ2V0RWxlbWVudEJ5SWQ7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzLWxpZ2h0Jyk7XG52YXIgUmVuZGVyUmVzdWx0ID0gcmVxdWlyZSgnLi4vcnVudGltZS9SZW5kZXJSZXN1bHQnKTtcbnZhciBTdWJzY3JpcHRpb25UcmFja2VyID0gcmVxdWlyZSgnbGlzdGVuZXItdHJhY2tlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdyYXB0b3ItdXRpbC9pbmhlcml0Jyk7XG52YXIgdXBkYXRlTWFuYWdlciA9IHJlcXVpcmUoJy4vdXBkYXRlLW1hbmFnZXInKTtcbnZhciBtb3JwaGRvbSA9IHJlcXVpcmUoJy4uL21vcnBoZG9tJyk7XG52YXIgZXZlbnREZWxlZ2F0aW9uID0gcmVxdWlyZSgnLi9ldmVudC1kZWxlZ2F0aW9uJyk7XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxudmFyIE1PUlBIRE9NX1NLSVAgPSB0cnVlO1xuXG52YXIgQ09NUE9ORU5UX1NVQlNDUklCRV9UT19PUFRJT05TO1xudmFyIE5PTl9DT01QT05FTlRfU1VCU0NSSUJFX1RPX09QVElPTlMgPSB7XG4gICAgYWRkRGVzdHJveUxpc3RlbmVyOiBmYWxzZVxufTtcblxudmFyIGVtaXQgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHJlbW92ZUV2ZW50TGlzdGVuZXJIYW5kbGUpIHtcbiAgICByZW1vdmVFdmVudExpc3RlbmVySGFuZGxlKCk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQ29tcGF0aWJsZUNvbXBvbmVudChjb21wb25lbnRzQ29udGV4dCwgZWwpIHtcbiAgICB2YXIgY29tcG9uZW50ID0gZWwuX3c7XG4gICAgd2hpbGUoY29tcG9uZW50KSB7XG4gICAgICAgIHZhciBpZCA9IGNvbXBvbmVudC5pZDtcbiAgICAgICAgdmFyIG5ld0NvbXBvbmVudERlZiA9IGNvbXBvbmVudHNDb250ZXh0LiRfX2NvbXBvbmVudHNCeUlkW2lkXTtcbiAgICAgICAgaWYgKG5ld0NvbXBvbmVudERlZiAmJiBjb21wb25lbnQuJF9fdHlwZSA9PSBuZXdDb21wb25lbnREZWYuJF9fY29tcG9uZW50LiRfX3R5cGUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvb3RGb3IgPSBjb21wb25lbnQuJF9fcm9vdEZvcjtcbiAgICAgICAgaWYgKHJvb3RGb3IpICB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSByb290Rm9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcG9uZW50LiRfX2Rlc3Ryb3lTaGFsbG93KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlQ3VzdG9tRXZlbnRXaXRoTWV0aG9kTGlzdGVuZXIoY29tcG9uZW50LCB0YXJnZXRNZXRob2ROYW1lLCBhcmdzLCBleHRyYUFyZ3MpIHtcbiAgICAvLyBSZW1vdmUgdGhlIFwiZXZlbnRUeXBlXCIgYXJndW1lbnRcbiAgICBhcmdzLnB1c2goY29tcG9uZW50KTtcblxuICAgIGlmIChleHRyYUFyZ3MpIHtcbiAgICAgICAgYXJncyA9IGV4dHJhQXJncy5jb25jYXQoYXJncyk7XG4gICAgfVxuXG5cbiAgICB2YXIgdGFyZ2V0Q29tcG9uZW50ID0gY29tcG9uZW50TG9va3VwW2NvbXBvbmVudC4kX19zY29wZV07XG4gICAgdmFyIHRhcmdldE1ldGhvZCA9IHRhcmdldENvbXBvbmVudFt0YXJnZXRNZXRob2ROYW1lXTtcbiAgICBpZiAoIXRhcmdldE1ldGhvZCkge1xuICAgICAgICB0aHJvdyBFcnJvcignTWV0aG9kIG5vdCBmb3VuZDogJyArIHRhcmdldE1ldGhvZE5hbWUpO1xuICAgIH1cblxuICAgIHRhcmdldE1ldGhvZC5hcHBseSh0YXJnZXRDb21wb25lbnQsIGFyZ3MpO1xufVxuXG5mdW5jdGlvbiBnZXRFbElkSGVscGVyKGNvbXBvbmVudCwgY29tcG9uZW50RWxJZCwgaW5kZXgpIHtcbiAgICB2YXIgaWQgPSBjb21wb25lbnQuaWQ7XG5cbiAgICB2YXIgZWxJZCA9IGNvbXBvbmVudEVsSWQgIT0gbnVsbCA/IGlkICsgJy0nICsgY29tcG9uZW50RWxJZCA6IGlkO1xuXG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgZWxJZCArPSAnWycgKyBpbmRleCArICddJztcbiAgICB9XG5cbiAgICByZXR1cm4gZWxJZDtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHByb2Nlc3MgXCJ1cGRhdGVfPHN0YXRlTmFtZT5cIiBoYW5kbGVyIGZ1bmN0aW9ucy5cbiAqIElmIGFsbCBvZiB0aGUgbW9kaWZpZWQgc3RhdGUgcHJvcGVydGllcyBoYXZlIGEgdXNlciBwcm92aWRlZCB1cGRhdGUgaGFuZGxlclxuICogdGhlbiBhIHJlcmVuZGVyIHdpbGwgYmUgYnlwYXNzZWQgYW5kLCBpbnN0ZWFkLCB0aGUgRE9NIHdpbGwgYmUgdXBkYXRlZFxuICogbG9vcGluZyBvdmVyIGFuZCBpbnZva2luZyB0aGUgY3VzdG9tIHVwZGF0ZSBoYW5kbGVycy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBpZiB0aGUgRE9NIHdhcyB1cGRhdGVkLiBGYWxzZSwgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBwcm9jZXNzVXBkYXRlSGFuZGxlcnMoY29tcG9uZW50LCBzdGF0ZUNoYW5nZXMsIG9sZFN0YXRlKSB7XG4gICAgdmFyIGhhbmRsZXJNZXRob2Q7XG4gICAgdmFyIGhhbmRsZXJzO1xuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gc3RhdGVDaGFuZ2VzKSB7XG4gICAgICAgIGlmIChzdGF0ZUNoYW5nZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlck1ldGhvZE5hbWUgPSAndXBkYXRlXycgKyBwcm9wTmFtZTtcblxuICAgICAgICAgICAgaGFuZGxlck1ldGhvZCA9IGNvbXBvbmVudFtoYW5kbGVyTWV0aG9kTmFtZV07XG4gICAgICAgICAgICBpZiAoaGFuZGxlck1ldGhvZCkge1xuICAgICAgICAgICAgICAgIChoYW5kbGVycyB8fCAoaGFuZGxlcnM9W10pKS5wdXNoKFtwcm9wTmFtZSwgaGFuZGxlck1ldGhvZF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHN0YXRlIGNoYW5nZSBkb2VzIG5vdCBoYXZlIGEgc3RhdGUgaGFuZGxlciBzbyByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAvLyB0byBmb3JjZSBhIHJlcmVuZGVyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZ290IGhlcmUgdGhlbiBhbGwgb2YgdGhlIGNoYW5nZWQgc3RhdGUgcHJvcGVydGllcyBoYXZlXG4gICAgLy8gYW4gdXBkYXRlIGhhbmRsZXIgb3IgdGhlcmUgYXJlIG5vIHN0YXRlIHByb3BlcnRpZXMgdGhhdCBhY3R1YWxseVxuICAgIC8vIGNoYW5nZWQuXG4gICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhlcmUgYXJlIGhhbmRsZXJzIGZvciBhbGwgb2YgdGhlIGNoYW5nZWQgcHJvcGVydGllc1xuICAgICAgICAvLyBzbyBhcHBseSB0aGUgdXBkYXRlcyB1c2luZyB0aG9zZSBoYW5kbGVyc1xuXG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlciwgaSkge1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IGhhbmRsZXJbMF07XG4gICAgICAgICAgICBoYW5kbGVyTWV0aG9kID0gaGFuZGxlclsxXTtcblxuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gc3RhdGVDaGFuZ2VzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBvbGRTdGF0ZVtwcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgaGFuZGxlck1ldGhvZC5jYWxsKGNvbXBvbmVudCwgbmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZW1pdExpZmVjeWNsZUV2ZW50KGNvbXBvbmVudCwgJ3VwZGF0ZScpO1xuXG4gICAgICAgIGNvbXBvbmVudC4kX19yZXNldCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjaGVja0lucHV0Q2hhbmdlZChleGlzdGluZ0NvbXBvbmVudCwgb2xkSW5wdXQsIG5ld0lucHV0KSB7XG4gICAgaWYgKG9sZElucHV0ICE9IG5ld0lucHV0KSB7XG4gICAgICAgIGlmIChvbGRJbnB1dCA9PSBudWxsIHx8IG5ld0lucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9sZEtleXMgPSBPYmplY3Qua2V5cyhvbGRJbnB1dCk7XG4gICAgICAgIHZhciBuZXdLZXlzID0gT2JqZWN0LmtleXMobmV3SW5wdXQpO1xuICAgICAgICB2YXIgbGVuID0gb2xkS2V5cy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gIT09IG5ld0tleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IG9sZEtleXNbaV07XG4gICAgICAgICAgICBpZiAob2xkSW5wdXRba2V5XSAhPT0gbmV3SW5wdXRba2V5XSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbk5vZGVEaXNjYXJkZWQobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgZGVzdHJveUNvbXBvbmVudEZvckVsKG5vZGUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gb25CZWZvcmVOb2RlRGlzY2FyZGVkKG5vZGUpIHtcbiAgICByZXR1cm4gZXZlbnREZWxlZ2F0aW9uLiRfX2hhbmRsZU5vZGVEZXRhY2gobm9kZSk7XG59XG5cbmZ1bmN0aW9uIG9uQmVmb3JlRWxVcGRhdGVkKGZyb21FbCwgY29tcG9uZW50c0NvbnRleHQpIHtcbiAgICB2YXIgaWQgPSBmcm9tRWwuaWQ7XG5cbiAgICBpZiAoY29tcG9uZW50c0NvbnRleHQgJiYgaWQpIHtcbiAgICAgICAgdmFyIHByZXNlcnZlZCA9IGNvbXBvbmVudHNDb250ZXh0LiRfX3ByZXNlcnZlZFtpZF07XG5cbiAgICAgICAgaWYgKHByZXNlcnZlZCAmJiAhcHJlc2VydmVkLiRfX2JvZHlPbmx5KSB7XG4gICAgICAgICAgICAvLyBEb24ndCBtb3JwaCBlbGVtZW50cyB0aGF0IGFyZSBhc3NvY2lhdGVkIHdpdGggY29tcG9uZW50cyB0aGF0IGFyZSBiZWluZ1xuICAgICAgICAgICAgLy8gcmV1c2VkIG9yIGVsZW1lbnRzIHRoYXQgYXJlIGJlaW5nIHByZXNlcnZlZC4gRm9yIGNvbXBvbmVudHMgYmVpbmcgcmV1c2VkLFxuICAgICAgICAgICAgLy8gdGhlIG1vcnBoaW5nIHdpbGwgdGFrZSBwbGFjZSB3aGVuIHRoZSByZXVzZWQgY29tcG9uZW50IHVwZGF0ZXMuXG4gICAgICAgICAgICByZXR1cm4gTU9SUEhET01fU0tJUDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIG1heSBuZWVkIHRvIGRlc3Ryb3kgYSBDb21wb25lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgICAgICAgIC8vIGlmIGEgbmV3IFVJIGNvbXBvbmVudCB3YXMgcmVuZGVyZWQgdG8gdGhlIHNhbWUgZWxlbWVudCBhbmQgdGhlIHR5cGVzXG4gICAgICAgICAgICAvLyBkbyBub3QgbWF0Y2hcbiAgICAgICAgICAgIGNoZWNrQ29tcGF0aWJsZUNvbXBvbmVudChjb21wb25lbnRzQ29udGV4dCwgZnJvbUVsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gb25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZChlbCwgY29tcG9uZW50c0NvbnRleHQpIHtcbiAgICB2YXIgaWQgPSBlbC5pZDtcbiAgICBpZiAoY29tcG9uZW50c0NvbnRleHQgJiYgaWQpIHtcbiAgICAgICAgdmFyIHByZXNlcnZlZCA9IGNvbXBvbmVudHNDb250ZXh0LiRfX3ByZXNlcnZlZFtpZF07XG4gICAgICAgIGlmIChwcmVzZXJ2ZWQgJiYgcHJlc2VydmVkLiRfX2JvZHlPbmx5KSB7XG4gICAgICAgICAgICAvLyBEb24ndCBtb3JwaCB0aGUgY2hpbGRyZW4gc2luY2UgdGhleSBhcmUgcHJlc2VydmVkXG4gICAgICAgICAgICByZXR1cm4gTU9SUEhET01fU0tJUDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gb25Ob2RlQWRkZWQobm9kZSwgY29tcG9uZW50c0NvbnRleHQpIHtcbiAgICBldmVudERlbGVnYXRpb24uJF9faGFuZGxlTm9kZUF0dGFjaChub2RlLCBjb21wb25lbnRzQ29udGV4dC4kX19vdXQpO1xufVxuXG52YXIgY29tcG9uZW50UHJvdG87XG5cbi8qKlxuICogQmFzZSBjb21wb25lbnQgdHlwZS5cbiAqXG4gKiBOT1RFOiBBbnkgbWV0aG9kcyB0aGF0IGFyZSBwcmVmaXhlZCB3aXRoIGFuIHVuZGVyc2NvcmUgc2hvdWxkIGJlIGNvbnNpZGVyZWQgcHJpdmF0ZSFcbiAqL1xuZnVuY3Rpb24gQ29tcG9uZW50KGlkLCBkb2MpIHtcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5lbCA9IG51bGw7XG4gICAgdGhpcy4kX19zdGF0ZSA9IG51bGw7XG4gICAgdGhpcy4kX19yb290cyA9IG51bGw7XG4gICAgdGhpcy4kX19zdWJzY3JpcHRpb25zID0gbnVsbDtcbiAgICB0aGlzLiRfX2RvbUV2ZW50TGlzdGVuZXJIYW5kbGVzID0gbnVsbDtcbiAgICB0aGlzLiRfX2J1YmJsaW5nRG9tRXZlbnRzID0gbnVsbDtcbiAgICB0aGlzLiRfX2N1c3RvbUV2ZW50cyA9IG51bGw7XG4gICAgdGhpcy4kX19zY29wZSA9IG51bGw7XG4gICAgdGhpcy4kX19yZW5kZXJJbnB1dCA9IG51bGw7XG4gICAgdGhpcy4kX19pbnB1dCA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuJF9fZGVzdHJveWVkID1cbiAgICAgICAgdGhpcy4kX191cGRhdGVRdWV1ZWQgPVxuICAgICAgICB0aGlzLiRfX2RpcnR5ID1cbiAgICAgICAgdGhpcy4kX19zZXR0aW5nSW5wdXQgPVxuICAgICAgICBmYWxzZTtcblxuICAgIHRoaXMuJF9fZG9jdW1lbnQgPSBkb2M7XG59XG5cbkNvbXBvbmVudC5wcm90b3R5cGUgPSBjb21wb25lbnRQcm90byA9IHtcbiAgICAkX19pc0NvbXBvbmVudDogdHJ1ZSxcblxuICAgIHN1YnNjcmliZVRvOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLiRfX3N1YnNjcmlwdGlvbnMgfHwgKHRoaXMuJF9fc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb25UcmFja2VyKCkpO1xuXG4gICAgICAgIHZhciBzdWJzY3JpYmVUb09wdGlvbnMgPSB0YXJnZXQuJF9faXNDb21wb25lbnQgP1xuICAgICAgICAgICAgQ09NUE9ORU5UX1NVQlNDUklCRV9UT19PUFRJT05TIDpcbiAgICAgICAgICAgIE5PTl9DT01QT05FTlRfU1VCU0NSSUJFX1RPX09QVElPTlM7XG5cbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbnMuc3Vic2NyaWJlVG8odGFyZ2V0LCBzdWJzY3JpYmVUb09wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihldmVudFR5cGUpIHtcbiAgICAgICAgdmFyIGN1c3RvbUV2ZW50cyA9IHRoaXMuJF9fY3VzdG9tRXZlbnRzO1xuICAgICAgICB2YXIgdGFyZ2V0O1xuXG4gICAgICAgIGlmIChjdXN0b21FdmVudHMgJiYgKHRhcmdldCA9IGN1c3RvbUV2ZW50c1tldmVudFR5cGVdKSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldE1ldGhvZE5hbWUgPSB0YXJnZXRbMF07XG4gICAgICAgICAgICB2YXIgZXh0cmFBcmdzID0gdGFyZ2V0WzFdO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICAgICAgICAgIGhhbmRsZUN1c3RvbUV2ZW50V2l0aE1ldGhvZExpc3RlbmVyKHRoaXMsIHRhcmdldE1ldGhvZE5hbWUsIGFyZ3MsIGV4dHJhQXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5saXN0ZW5lckNvdW50KGV2ZW50VHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldEVsSWQ6IGZ1bmN0aW9uIChjb21wb25lbnRFbElkLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZ2V0RWxJZEhlbHBlcih0aGlzLCBjb21wb25lbnRFbElkLCBpbmRleCk7XG4gICAgfSxcbiAgICBnZXRFbDogZnVuY3Rpb24gKGNvbXBvbmVudEVsSWQsIGluZGV4KSB7XG4gICAgICAgIHZhciBkb2MgPSB0aGlzLiRfX2RvY3VtZW50O1xuXG4gICAgICAgIGlmIChjb21wb25lbnRFbElkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFbGVtZW50QnlJZChkb2MsIGdldEVsSWRIZWxwZXIodGhpcywgY29tcG9uZW50RWxJZCwgaW5kZXgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsIHx8IGdldEVsZW1lbnRCeUlkKGRvYywgZ2V0RWxJZEhlbHBlcih0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldEVsczogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdmFyIGVscyA9IFtdO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBlbDtcbiAgICAgICAgd2hpbGUoKGVsID0gdGhpcy5nZXRFbChpZCwgaSkpKSB7XG4gICAgICAgICAgICBlbHMucHVzaChlbCk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVscztcbiAgICB9LFxuICAgIGdldENvbXBvbmVudDogZnVuY3Rpb24oaWQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRMb29rdXBbZ2V0RWxJZEhlbHBlcih0aGlzLCBpZCwgaW5kZXgpXTtcbiAgICB9LFxuICAgIGdldENvbXBvbmVudHM6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGNvbXBvbmVudDtcbiAgICAgICAgd2hpbGUoKGNvbXBvbmVudCA9IGNvbXBvbmVudExvb2t1cFtnZXRFbElkSGVscGVyKHRoaXMsIGlkLCBpKV0pKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy4kX19kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbHMgPSB0aGlzLmVscztcblxuICAgICAgICB0aGlzLiRfX2Rlc3Ryb3lTaGFsbG93KCk7XG5cbiAgICAgICAgdmFyIHJvb3RDb21wb25lbnRzID0gdGhpcy4kX19yb290Q29tcG9uZW50cztcbiAgICAgICAgaWYgKHJvb3RDb21wb25lbnRzKSB7XG4gICAgICAgICAgICByb290Q29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHJvb3RDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICByb290Q29tcG9uZW50LiRfX2Rlc3Ryb3koKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxzLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIGRlc3Ryb3lFbFJlY3Vyc2l2ZShlbCk7XG5cbiAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gZWwucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAkX19kZXN0cm95U2hhbGxvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLiRfX2Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZW1pdExpZmVjeWNsZUV2ZW50KHRoaXMsICdkZXN0cm95Jyk7XG4gICAgICAgIHRoaXMuJF9fZGVzdHJveWVkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmVsID0gbnVsbDtcblxuICAgICAgICAvLyBVbnN1YnNjcmliZSBmcm9tIGFsbCBET00gZXZlbnRzXG4gICAgICAgIHRoaXMuJF9fcmVtb3ZlRE9NRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuJF9fc3Vic2NyaXB0aW9ucztcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB0aGlzLiRfX3N1YnNjcmlwdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIGNvbXBvbmVudExvb2t1cFt0aGlzLmlkXTtcbiAgICB9LFxuXG4gICAgaXNEZXN0cm95ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kX19kZXN0cm95ZWQ7XG4gICAgfSxcbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRfX3N0YXRlO1xuICAgIH0sXG4gICAgc2V0IHN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuJF9fc3RhdGU7XG4gICAgICAgIGlmICghc3RhdGUgJiYgIW5ld1N0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSB0aGlzLiRfX3N0YXRlID0gbmV3IHRoaXMuJF9fU3RhdGUodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS4kX19yZXBsYWNlKG5ld1N0YXRlIHx8IHt9KTtcblxuICAgICAgICBpZiAoc3RhdGUuJF9fZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuJF9fcXVldWVVcGRhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbmV3U3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuJF9fc3RhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzZXRTdGF0ZTogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy4kX19zdGF0ZTtcblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIE1lcmdlIGluIHRoZSBuZXcgc3RhdGUgd2l0aCB0aGUgb2xkIHN0YXRlXG4gICAgICAgICAgICB2YXIgbmV3U3RhdGUgPSBuYW1lO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBuZXdTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0ZS5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS4kX19zZXQoaywgbmV3U3RhdGVba10sIHRydWUgLyogZW5zdXJlOnRydWUgKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLiRfX3NldChuYW1lLCB2YWx1ZSwgdHJ1ZSAvKiBlbnN1cmU6dHJ1ZSAqLyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0U3RhdGVEaXJ0eTogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy4kX19zdGF0ZTtcblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHN0YXRlW25hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuJF9fc2V0KG5hbWUsIHZhbHVlLCB0cnVlIC8qIGVuc3VyZTp0cnVlICovLCB0cnVlIC8qIGZvcmNlRGlydHk6dHJ1ZSAqLyk7XG4gICAgfSxcblxuICAgIHJlcGxhY2VTdGF0ZTogZnVuY3Rpb24obmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy4kX19zdGF0ZS4kX19yZXBsYWNlKG5ld1N0YXRlKTtcbiAgICB9LFxuXG4gICAgZ2V0IGlucHV0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kX19pbnB1dDtcbiAgICB9LFxuICAgIHNldCBpbnB1dChuZXdJbnB1dCkge1xuICAgICAgICBpZiAodGhpcy4kX19zZXR0aW5nSW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuJF9faW5wdXQgPSBuZXdJbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJF9fc2V0SW5wdXQobmV3SW5wdXQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICRfX3NldElucHV0OiBmdW5jdGlvbihuZXdJbnB1dCwgb25JbnB1dCwgb3V0KSB7XG4gICAgICAgIG9uSW5wdXQgPSBvbklucHV0IHx8IHRoaXMub25JbnB1dDtcbiAgICAgICAgdmFyIHVwZGF0ZWRJbnB1dDtcblxuICAgICAgICB2YXIgb2xkSW5wdXQgPSB0aGlzLiRfX2lucHV0O1xuICAgICAgICB0aGlzLiRfX2lucHV0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChvbklucHV0KSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHNldCBhIGZsYWcgdG8gcHJldmlldyBgdGhpcy5pbnB1dCA9IGZvb2AgaW5zaWRlXG4gICAgICAgICAgICAvLyBvbklucHV0IGNhdXNpbmcgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICAgICAgICB0aGlzLiRfX3NldHRpbmdJbnB1dCA9IHRydWU7XG4gICAgICAgICAgICB1cGRhdGVkSW5wdXQgPSBvbklucHV0LmNhbGwodGhpcywgbmV3SW5wdXQgfHwge30sIG91dCk7XG4gICAgICAgICAgICB0aGlzLiRfX3NldHRpbmdJbnB1dCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3SW5wdXQgPSB0aGlzLiRfX3JlbmRlcklucHV0ID0gdXBkYXRlZElucHV0IHx8IG5ld0lucHV0O1xuXG4gICAgICAgIGlmICgodGhpcy4kX19kaXJ0eSA9IGNoZWNrSW5wdXRDaGFuZ2VkKHRoaXMsIG9sZElucHV0LCBuZXdJbnB1dCkpKSB7XG4gICAgICAgICAgICB0aGlzLiRfX3F1ZXVlVXBkYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy4kX19pbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLiRfX2lucHV0ID0gbmV3SW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3SW5wdXQ7XG4gICAgfSxcblxuICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy4kX19kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuJF9fcXVldWVVcGRhdGUoKTtcbiAgICB9LFxuXG4gICAgJF9fcXVldWVVcGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuJF9fdXBkYXRlUXVldWVkKSB7XG4gICAgICAgICAgICB1cGRhdGVNYW5hZ2VyLiRfX3F1ZXVlQ29tcG9uZW50VXBkYXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLiRfX2Rlc3Ryb3llZCB8fCAhdGhpcy4kX19pc0RpcnR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLiRfX2lucHV0O1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLiRfX3N0YXRlO1xuXG4gICAgICAgIGlmICghdGhpcy4kX19kaXJ0eSAmJiBzdGF0ZSAmJiBzdGF0ZS4kX19kaXJ0eSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3NVcGRhdGVIYW5kbGVycyh0aGlzLCBzdGF0ZS4kX19jaGFuZ2VzLCBzdGF0ZS4kX19vbGQsIHN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLiRfX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy4kX19pc0RpcnR5KSB7XG4gICAgICAgICAgICAvLyBUaGUgVUkgY29tcG9uZW50IGlzIHN0aWxsIGRpcnR5IGFmdGVyIHByb2Nlc3Mgc3RhdGUgaGFuZGxlcnNcbiAgICAgICAgICAgIC8vIHRoZW4gd2Ugc2hvdWxkIHJlcmVuZGVyXG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFVwZGF0ZShpbnB1dCwgc3RhdGUpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJF9fcmVyZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJF9fcmVzZXQoKTtcbiAgICB9LFxuXG5cbiAgICBnZXQgJF9faXNEaXJ0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJF9fZGlydHkgfHwgKHRoaXMuJF9fc3RhdGUgJiYgdGhpcy4kX19zdGF0ZS4kX19kaXJ0eSk7XG4gICAgfSxcblxuICAgICRfX3Jlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy4kX19kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLiRfX3VwZGF0ZVF1ZXVlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLiRfX3JlbmRlcklucHV0ID0gbnVsbDtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy4kX19zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICBzdGF0ZS4kX19yZXNldCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNob3VsZFVwZGF0ZTogZnVuY3Rpb24obmV3U3RhdGUsIG5ld1Byb3BzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAkX19lbWl0TGlmZWN5Y2xlRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZXZlbnRBcmcxLCBldmVudEFyZzIpIHtcbiAgICAgICAgZW1pdExpZmVjeWNsZUV2ZW50KHRoaXMsIGV2ZW50VHlwZSwgZXZlbnRBcmcxLCBldmVudEFyZzIpO1xuICAgIH0sXG5cbiAgICAkX19yZXJlbmRlcjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHNlbGYuJF9fcmVuZGVyZXI7XG5cbiAgICAgICAgaWYgKCFyZW5kZXJlcikge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2xvYmFsRGF0YSA9IHtcbiAgICAgICAgICAgICR3OiBzZWxmXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGZyb21FbHMgPSBzZWxmLiRfX2dldFJvb3RFbHMoe30pO1xuICAgICAgICB2YXIgZG9jID0gc2VsZi4kX19kb2N1bWVudDtcbiAgICAgICAgaW5wdXQgPSB0aGlzLiRfX3JlbmRlcklucHV0IHx8IHRoaXMuJF9faW5wdXQ7XG5cbiAgICAgICAgdXBkYXRlTWFuYWdlci4kX19iYXRjaFVwZGF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjcmVhdGVPdXQgPSByZW5kZXJlci5jcmVhdGVPdXQgfHwgbWFya28uY3JlYXRlT3V0O1xuICAgICAgICAgICAgdmFyIG91dCA9IGNyZWF0ZU91dChnbG9iYWxEYXRhKTtcbiAgICAgICAgICAgIG91dC4kX19kb2N1bWVudCA9IHNlbGYuJF9fZG9jdW1lbnQ7XG4gICAgICAgICAgICByZW5kZXJlcihpbnB1dCwgb3V0KTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgUmVuZGVyUmVzdWx0KG91dCk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IG91dC4kX19nZXRPdXRwdXQoKTtcblxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudHNDb250ZXh0ID0gb3V0Lmdsb2JhbC5jb21wb25lbnRzO1xuXG4gICAgICAgICAgICB2YXIgZnJvbUVsO1xuXG4gICAgICAgICAgICB2YXIgdGFyZ2V0RWwgPSB0YXJnZXROb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSh0YXJnZXRFbCkge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IHRhcmdldEVsLmlkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21FbCA9IGZyb21FbHNbaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbUVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JwaGRvbShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tRWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50c0NvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Ob2RlQWRkZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25CZWZvcmVFbFVwZGF0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25CZWZvcmVOb2RlRGlzY2FyZGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uTm9kZURpc2NhcmRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRhcmdldEVsID0gdGFyZ2V0RWwubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdC5hZnRlckluc2VydChkb2MpO1xuXG4gICAgICAgICAgICBvdXQuZW1pdCgnJF9fY29tcG9uZW50c0luaXRpYWxpemVkJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuJF9fcmVzZXQoKTtcbiAgICB9LFxuXG4gICAgJF9fZ2V0Um9vdEVsczogZnVuY3Rpb24ocm9vdEVscykge1xuICAgICAgICB2YXIgaSwgbGVuO1xuXG4gICAgICAgIHZhciBjb21wb25lbnRFbHMgPSB0aGlzLmVscztcblxuICAgICAgICBmb3IgKGk9MCwgbGVuPWNvbXBvbmVudEVscy5sZW5ndGg7IGk8bGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRFbCA9IGNvbXBvbmVudEVsc1tpXTtcbiAgICAgICAgICAgIHJvb3RFbHNbY29tcG9uZW50RWwuaWRdID0gY29tcG9uZW50RWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm9vdENvbXBvbmVudHMgPSB0aGlzLiRfX3Jvb3RDb21wb25lbnRzO1xuICAgICAgICBpZiAocm9vdENvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGZvciAoaT0wLCBsZW49cm9vdENvbXBvbmVudHMubGVuZ3RoOyBpPGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3RDb21wb25lbnQgPSByb290Q29tcG9uZW50c1tpXTtcbiAgICAgICAgICAgICAgICByb290Q29tcG9uZW50LiRfX2dldFJvb3RFbHMocm9vdEVscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcm9vdEVscztcbiAgICB9LFxuXG4gICAgJF9fcmVtb3ZlRE9NRXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZXZlbnRMaXN0ZW5lckhhbmRsZXMgPSB0aGlzLiRfX2RvbUV2ZW50TGlzdGVuZXJIYW5kbGVzO1xuICAgICAgICBpZiAoZXZlbnRMaXN0ZW5lckhhbmRsZXMpIHtcbiAgICAgICAgICAgIGV2ZW50TGlzdGVuZXJIYW5kbGVzLmZvckVhY2gocmVtb3ZlTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy4kX19kb21FdmVudExpc3RlbmVySGFuZGxlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0ICRfX3Jhd1N0YXRlKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLiRfX3N0YXRlO1xuICAgICAgICByZXR1cm4gc3RhdGUgJiYgc3RhdGUuJF9fcmF3O1xuICAgIH0sXG5cbiAgICAkX19zZXRDdXN0b21FdmVudHM6IGZ1bmN0aW9uKGN1c3RvbUV2ZW50cywgc2NvcGUpIHtcbiAgICAgICAgaWYgKGN1c3RvbUV2ZW50cykge1xuICAgICAgICAgICAgdmFyIGZpbmFsQ3VzdG9tRXZlbnRzID0gdGhpcy4kX19jdXN0b21FdmVudHMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuJF9fc2NvcGUgPSBzY29wZTtcblxuICAgICAgICAgICAgY3VzdG9tRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oY3VzdG9tRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRUeXBlID0gY3VzdG9tRXZlbnRbMF07XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldE1ldGhvZE5hbWUgPSBjdXN0b21FdmVudFsxXTtcbiAgICAgICAgICAgICAgICB2YXIgZXh0cmFBcmdzID0gY3VzdG9tRXZlbnRbMl07XG5cbiAgICAgICAgICAgICAgICBmaW5hbEN1c3RvbUV2ZW50c1tldmVudFR5cGVdID0gW3RhcmdldE1ldGhvZE5hbWUsIGV4dHJhQXJnc107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmNvbXBvbmVudFByb3RvLmVsSWQgPSBjb21wb25lbnRQcm90by5nZXRFbElkO1xuY29tcG9uZW50UHJvdG8uJF9fdXBkYXRlID0gY29tcG9uZW50UHJvdG8udXBkYXRlO1xuY29tcG9uZW50UHJvdG8uJF9fZGVzdHJveSA9IGNvbXBvbmVudFByb3RvLmRlc3Ryb3k7XG5cbi8vIEFkZCBhbGwgb2YgdGhlIGZvbGxvd2luZyBET00gbWV0aG9kcyB0byBDb21wb25lbnQucHJvdG90eXBlOlxuLy8gLSBhcHBlbmRUbyhyZWZlcmVuY2VFbClcbi8vIC0gcmVwbGFjZShyZWZlcmVuY2VFbClcbi8vIC0gcmVwbGFjZUNoaWxkcmVuT2YocmVmZXJlbmNlRWwpXG4vLyAtIGluc2VydEJlZm9yZShyZWZlcmVuY2VFbClcbi8vIC0gaW5zZXJ0QWZ0ZXIocmVmZXJlbmNlRWwpXG4vLyAtIHByZXBlbmRUbyhyZWZlcmVuY2VFbClcbmRvbUluc2VydChcbiAgICBjb21wb25lbnRQcm90byxcbiAgICBmdW5jdGlvbiBnZXRFbChjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGVscyA9IHRoaXMuZWxzO1xuICAgICAgICB2YXIgZWxDb3VudCA9IGVscy5sZW5ndGg7XG4gICAgICAgIGlmIChlbENvdW50ID4gMSkge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gY29tcG9uZW50LiRfX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIGVscy5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZWxzWzBdO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBmdW5jdGlvbiBhZnRlckluc2VydChjb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICB9KTtcblxuaW5oZXJpdChDb21wb25lbnQsIEV2ZW50RW1pdHRlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcmtvL2NvbXBvbmVudHMvQ29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar nextRepeatedId = __webpack_require__(14);\nvar repeatedRegExp = /\\[\\]$/;\nvar componentUtil = __webpack_require__(0);\nvar nextComponentId = componentUtil.$__nextComponentId;\nvar attachBubblingEvent = componentUtil.$__attachBubblingEvent;\n\nvar extend = __webpack_require__(1);\nvar registry = __webpack_require__(5);\n\n/**\n * A ComponentDef is used to hold the metadata collected at runtime for\n * a single component and this information is used to instantiate the component\n * later (after the rendered HTML has been added to the DOM)\n */\nfunction ComponentDef(component, componentId, out, componentStack, componentStackLen) {\n    this.$__out = out; // The AsyncWriter that this component is associated with\n    this.$__componentStack = componentStack;\n    this.$__componentStackLen = componentStackLen;\n    this.$__component = component;\n    this.id = componentId;\n\n    this.$__roots =  null;            // IDs of root elements if there are multiple root elements\n    this.$__children = null;          // An array of nested ComponentDef instances\n    this.$__domEvents = null;         // An array of DOM events that need to be added (in sets of three)\n    this.$__bubblingDomEvents = null; // Used to keep track of bubbling DOM events for components rendered on the server\n\n    this.$__isExisting = false;\n\n    this.$__nextIdIndex = 0; // The unique integer to use for the next scoped ID\n}\n\nComponentDef.prototype = {\n    $__end: function() {\n        this.$__componentStack.length = this.$__componentStackLen;\n    },\n\n    /**\n     * Register a nested component for this component. We maintain a tree of components\n     * so that we can instantiate nested components before their parents.\n     */\n    $__addChild: function (componentDef) {\n        var children = this.$__children;\n\n        if (children) {\n            children.push(componentDef);\n        } else {\n            this.$__children = [componentDef];\n        }\n    },\n    /**\n     * This helper method generates a unique and fully qualified DOM element ID\n     * that is unique within the scope of the current component. This method prefixes\n     * the the nestedId with the ID of the current component. If nestedId ends\n     * with `[]` then it is treated as a repeated ID and we will generate\n     * an ID with the current index for the current nestedId.\n     * (e.g. \"myParentId-foo[0]\", \"myParentId-foo[1]\", etc.)\n     */\n    elId: function (nestedId) {\n        var id = this.id;\n        if (nestedId == null) {\n            return id;\n        } else {\n            if (typeof nestedId == 'string' && repeatedRegExp.test(nestedId)) {\n                return nextRepeatedId(this.$__out, id, nestedId);\n            } else {\n                return id + '-' + nestedId;\n            }\n        }\n    },\n    /**\n     * Registers a DOM event for a nested HTML element associated with the\n     * component. This is only done for non-bubbling events that require\n     * direct event listeners to be added.\n     * @param  {String} type The DOM event type (\"mouseover\", \"mousemove\", etc.)\n     * @param  {String} targetMethod The name of the method to invoke on the scoped component\n     * @param  {String} elId The DOM element ID of the DOM element that the event listener needs to be added too\n     */\n     e: function(type, targetMethod, elId, extraArgs) {\n        if (targetMethod) {\n            // The event handler method is allowed to be conditional. At render time if the target\n            // method is null then we do not attach any direct event listeners.\n            (this.$__domEvents || (this.$__domEvents = [])).push([\n                type,\n                targetMethod,\n                elId,\n                extraArgs]);\n        }\n    },\n    /**\n     * Returns the next auto generated unique ID for a nested DOM element or nested DOM component\n     */\n    $__nextId: function() {\n        var id = this.id;\n\n        return id ?\n            id + '-c' + (this.$__nextIdIndex++) :\n            nextComponentId(this.$__out);\n    },\n\n    d: function(handlerMethodName, extraArgs) {\n        return attachBubblingEvent(this, handlerMethodName, extraArgs);\n    }\n};\n\nComponentDef.$__deserialize = function(o, types) {\n    var id        = o[0];\n    var typeName  = types[o[1]];\n    var input     = o[2];\n    var extra     = o[3];\n\n    var state = extra.s;\n    var componentProps = extra.w;\n\n    var component = typeName /* legacy */ && registry.$__createComponent(typeName, id);\n\n    if (extra.b) {\n        component.$__bubblingDomEvents = extra.b;\n    }\n\n    // Preview newly created component from being queued for update since we area\n    // just building it from the server info\n    component.$__updateQueued = true;\n\n    if (state) {\n        var undefinedPropNames = extra.u;\n        if (undefinedPropNames) {\n            undefinedPropNames.forEach(function(undefinedPropName) {\n                state[undefinedPropName] = undefined;\n            });\n        }\n        // We go through the setter here so that we convert the state object\n        // to an instance of `State`\n        component.state = state;\n    }\n\n    component.$__input = input;\n\n    if (componentProps) {\n        extend(component, componentProps);\n    }\n\n    var scope = extra.p;\n    var customEvents = extra.e;\n    component.$__setCustomEvents(customEvents, scope);\n\n    return {\n        $__component: component,\n        $__roots: extra.r,\n        $__domEvents: extra.d\n    };\n};\n\nmodule.exports = ComponentDef;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL2NvbXBvbmVudHMvQ29tcG9uZW50RGVmLmpzPzE3NjgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIG5leHRSZXBlYXRlZElkID0gcmVxdWlyZSgnLi9uZXh0UmVwZWF0ZWRJZCcpO1xudmFyIHJlcGVhdGVkUmVnRXhwID0gL1xcW1xcXSQvO1xudmFyIGNvbXBvbmVudFV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBuZXh0Q29tcG9uZW50SWQgPSBjb21wb25lbnRVdGlsLiRfX25leHRDb21wb25lbnRJZDtcbnZhciBhdHRhY2hCdWJibGluZ0V2ZW50ID0gY29tcG9uZW50VXRpbC4kX19hdHRhY2hCdWJibGluZ0V2ZW50O1xuXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgncmFwdG9yLXV0aWwvZXh0ZW5kJyk7XG52YXIgcmVnaXN0cnkgPSByZXF1aXJlKCcuL3JlZ2lzdHJ5Jyk7XG5cbi8qKlxuICogQSBDb21wb25lbnREZWYgaXMgdXNlZCB0byBob2xkIHRoZSBtZXRhZGF0YSBjb2xsZWN0ZWQgYXQgcnVudGltZSBmb3JcbiAqIGEgc2luZ2xlIGNvbXBvbmVudCBhbmQgdGhpcyBpbmZvcm1hdGlvbiBpcyB1c2VkIHRvIGluc3RhbnRpYXRlIHRoZSBjb21wb25lbnRcbiAqIGxhdGVyIChhZnRlciB0aGUgcmVuZGVyZWQgSFRNTCBoYXMgYmVlbiBhZGRlZCB0byB0aGUgRE9NKVxuICovXG5mdW5jdGlvbiBDb21wb25lbnREZWYoY29tcG9uZW50LCBjb21wb25lbnRJZCwgb3V0LCBjb21wb25lbnRTdGFjaywgY29tcG9uZW50U3RhY2tMZW4pIHtcbiAgICB0aGlzLiRfX291dCA9IG91dDsgLy8gVGhlIEFzeW5jV3JpdGVyIHRoYXQgdGhpcyBjb21wb25lbnQgaXMgYXNzb2NpYXRlZCB3aXRoXG4gICAgdGhpcy4kX19jb21wb25lbnRTdGFjayA9IGNvbXBvbmVudFN0YWNrO1xuICAgIHRoaXMuJF9fY29tcG9uZW50U3RhY2tMZW4gPSBjb21wb25lbnRTdGFja0xlbjtcbiAgICB0aGlzLiRfX2NvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICB0aGlzLmlkID0gY29tcG9uZW50SWQ7XG5cbiAgICB0aGlzLiRfX3Jvb3RzID0gIG51bGw7ICAgICAgICAgICAgLy8gSURzIG9mIHJvb3QgZWxlbWVudHMgaWYgdGhlcmUgYXJlIG11bHRpcGxlIHJvb3QgZWxlbWVudHNcbiAgICB0aGlzLiRfX2NoaWxkcmVuID0gbnVsbDsgICAgICAgICAgLy8gQW4gYXJyYXkgb2YgbmVzdGVkIENvbXBvbmVudERlZiBpbnN0YW5jZXNcbiAgICB0aGlzLiRfX2RvbUV2ZW50cyA9IG51bGw7ICAgICAgICAgLy8gQW4gYXJyYXkgb2YgRE9NIGV2ZW50cyB0aGF0IG5lZWQgdG8gYmUgYWRkZWQgKGluIHNldHMgb2YgdGhyZWUpXG4gICAgdGhpcy4kX19idWJibGluZ0RvbUV2ZW50cyA9IG51bGw7IC8vIFVzZWQgdG8ga2VlcCB0cmFjayBvZiBidWJibGluZyBET00gZXZlbnRzIGZvciBjb21wb25lbnRzIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXJcblxuICAgIHRoaXMuJF9faXNFeGlzdGluZyA9IGZhbHNlO1xuXG4gICAgdGhpcy4kX19uZXh0SWRJbmRleCA9IDA7IC8vIFRoZSB1bmlxdWUgaW50ZWdlciB0byB1c2UgZm9yIHRoZSBuZXh0IHNjb3BlZCBJRFxufVxuXG5Db21wb25lbnREZWYucHJvdG90eXBlID0ge1xuICAgICRfX2VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJF9fY29tcG9uZW50U3RhY2subGVuZ3RoID0gdGhpcy4kX19jb21wb25lbnRTdGFja0xlbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBuZXN0ZWQgY29tcG9uZW50IGZvciB0aGlzIGNvbXBvbmVudC4gV2UgbWFpbnRhaW4gYSB0cmVlIG9mIGNvbXBvbmVudHNcbiAgICAgKiBzbyB0aGF0IHdlIGNhbiBpbnN0YW50aWF0ZSBuZXN0ZWQgY29tcG9uZW50cyBiZWZvcmUgdGhlaXIgcGFyZW50cy5cbiAgICAgKi9cbiAgICAkX19hZGRDaGlsZDogZnVuY3Rpb24gKGNvbXBvbmVudERlZikge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRfX2NoaWxkcmVuO1xuXG4gICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjb21wb25lbnREZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kX19jaGlsZHJlbiA9IFtjb21wb25lbnREZWZdO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGlzIGhlbHBlciBtZXRob2QgZ2VuZXJhdGVzIGEgdW5pcXVlIGFuZCBmdWxseSBxdWFsaWZpZWQgRE9NIGVsZW1lbnQgSURcbiAgICAgKiB0aGF0IGlzIHVuaXF1ZSB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBjdXJyZW50IGNvbXBvbmVudC4gVGhpcyBtZXRob2QgcHJlZml4ZXNcbiAgICAgKiB0aGUgdGhlIG5lc3RlZElkIHdpdGggdGhlIElEIG9mIHRoZSBjdXJyZW50IGNvbXBvbmVudC4gSWYgbmVzdGVkSWQgZW5kc1xuICAgICAqIHdpdGggYFtdYCB0aGVuIGl0IGlzIHRyZWF0ZWQgYXMgYSByZXBlYXRlZCBJRCBhbmQgd2Ugd2lsbCBnZW5lcmF0ZVxuICAgICAqIGFuIElEIHdpdGggdGhlIGN1cnJlbnQgaW5kZXggZm9yIHRoZSBjdXJyZW50IG5lc3RlZElkLlxuICAgICAqIChlLmcuIFwibXlQYXJlbnRJZC1mb29bMF1cIiwgXCJteVBhcmVudElkLWZvb1sxXVwiLCBldGMuKVxuICAgICAqL1xuICAgIGVsSWQ6IGZ1bmN0aW9uIChuZXN0ZWRJZCkge1xuICAgICAgICB2YXIgaWQgPSB0aGlzLmlkO1xuICAgICAgICBpZiAobmVzdGVkSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXN0ZWRJZCA9PSAnc3RyaW5nJyAmJiByZXBlYXRlZFJlZ0V4cC50ZXN0KG5lc3RlZElkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0UmVwZWF0ZWRJZCh0aGlzLiRfX291dCwgaWQsIG5lc3RlZElkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkICsgJy0nICsgbmVzdGVkSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIERPTSBldmVudCBmb3IgYSBuZXN0ZWQgSFRNTCBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICAgKiBjb21wb25lbnQuIFRoaXMgaXMgb25seSBkb25lIGZvciBub24tYnViYmxpbmcgZXZlbnRzIHRoYXQgcmVxdWlyZVxuICAgICAqIGRpcmVjdCBldmVudCBsaXN0ZW5lcnMgdG8gYmUgYWRkZWQuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlIFRoZSBET00gZXZlbnQgdHlwZSAoXCJtb3VzZW92ZXJcIiwgXCJtb3VzZW1vdmVcIiwgZXRjLilcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRhcmdldE1ldGhvZCBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGludm9rZSBvbiB0aGUgc2NvcGVkIGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZWxJZCBUaGUgRE9NIGVsZW1lbnQgSUQgb2YgdGhlIERPTSBlbGVtZW50IHRoYXQgdGhlIGV2ZW50IGxpc3RlbmVyIG5lZWRzIHRvIGJlIGFkZGVkIHRvb1xuICAgICAqL1xuICAgICBlOiBmdW5jdGlvbih0eXBlLCB0YXJnZXRNZXRob2QsIGVsSWQsIGV4dHJhQXJncykge1xuICAgICAgICBpZiAodGFyZ2V0TWV0aG9kKSB7XG4gICAgICAgICAgICAvLyBUaGUgZXZlbnQgaGFuZGxlciBtZXRob2QgaXMgYWxsb3dlZCB0byBiZSBjb25kaXRpb25hbC4gQXQgcmVuZGVyIHRpbWUgaWYgdGhlIHRhcmdldFxuICAgICAgICAgICAgLy8gbWV0aG9kIGlzIG51bGwgdGhlbiB3ZSBkbyBub3QgYXR0YWNoIGFueSBkaXJlY3QgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgICAgICAgKHRoaXMuJF9fZG9tRXZlbnRzIHx8ICh0aGlzLiRfX2RvbUV2ZW50cyA9IFtdKSkucHVzaChbXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICB0YXJnZXRNZXRob2QsXG4gICAgICAgICAgICAgICAgZWxJZCxcbiAgICAgICAgICAgICAgICBleHRyYUFyZ3NdKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmV4dCBhdXRvIGdlbmVyYXRlZCB1bmlxdWUgSUQgZm9yIGEgbmVzdGVkIERPTSBlbGVtZW50IG9yIG5lc3RlZCBET00gY29tcG9uZW50XG4gICAgICovXG4gICAgJF9fbmV4dElkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5pZDtcblxuICAgICAgICByZXR1cm4gaWQgP1xuICAgICAgICAgICAgaWQgKyAnLWMnICsgKHRoaXMuJF9fbmV4dElkSW5kZXgrKykgOlxuICAgICAgICAgICAgbmV4dENvbXBvbmVudElkKHRoaXMuJF9fb3V0KTtcbiAgICB9LFxuXG4gICAgZDogZnVuY3Rpb24oaGFuZGxlck1ldGhvZE5hbWUsIGV4dHJhQXJncykge1xuICAgICAgICByZXR1cm4gYXR0YWNoQnViYmxpbmdFdmVudCh0aGlzLCBoYW5kbGVyTWV0aG9kTmFtZSwgZXh0cmFBcmdzKTtcbiAgICB9XG59O1xuXG5Db21wb25lbnREZWYuJF9fZGVzZXJpYWxpemUgPSBmdW5jdGlvbihvLCB0eXBlcykge1xuICAgIHZhciBpZCAgICAgICAgPSBvWzBdO1xuICAgIHZhciB0eXBlTmFtZSAgPSB0eXBlc1tvWzFdXTtcbiAgICB2YXIgaW5wdXQgICAgID0gb1syXTtcbiAgICB2YXIgZXh0cmEgICAgID0gb1szXTtcblxuICAgIHZhciBzdGF0ZSA9IGV4dHJhLnM7XG4gICAgdmFyIGNvbXBvbmVudFByb3BzID0gZXh0cmEudztcblxuICAgIHZhciBjb21wb25lbnQgPSB0eXBlTmFtZSAvKiBsZWdhY3kgKi8gJiYgcmVnaXN0cnkuJF9fY3JlYXRlQ29tcG9uZW50KHR5cGVOYW1lLCBpZCk7XG5cbiAgICBpZiAoZXh0cmEuYikge1xuICAgICAgICBjb21wb25lbnQuJF9fYnViYmxpbmdEb21FdmVudHMgPSBleHRyYS5iO1xuICAgIH1cblxuICAgIC8vIFByZXZpZXcgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQgZnJvbSBiZWluZyBxdWV1ZWQgZm9yIHVwZGF0ZSBzaW5jZSB3ZSBhcmVhXG4gICAgLy8ganVzdCBidWlsZGluZyBpdCBmcm9tIHRoZSBzZXJ2ZXIgaW5mb1xuICAgIGNvbXBvbmVudC4kX191cGRhdGVRdWV1ZWQgPSB0cnVlO1xuXG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIHZhciB1bmRlZmluZWRQcm9wTmFtZXMgPSBleHRyYS51O1xuICAgICAgICBpZiAodW5kZWZpbmVkUHJvcE5hbWVzKSB7XG4gICAgICAgICAgICB1bmRlZmluZWRQcm9wTmFtZXMuZm9yRWFjaChmdW5jdGlvbih1bmRlZmluZWRQcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlW3VuZGVmaW5lZFByb3BOYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGdvIHRocm91Z2ggdGhlIHNldHRlciBoZXJlIHNvIHRoYXQgd2UgY29udmVydCB0aGUgc3RhdGUgb2JqZWN0XG4gICAgICAgIC8vIHRvIGFuIGluc3RhbmNlIG9mIGBTdGF0ZWBcbiAgICAgICAgY29tcG9uZW50LnN0YXRlID0gc3RhdGU7XG4gICAgfVxuXG4gICAgY29tcG9uZW50LiRfX2lucHV0ID0gaW5wdXQ7XG5cbiAgICBpZiAoY29tcG9uZW50UHJvcHMpIHtcbiAgICAgICAgZXh0ZW5kKGNvbXBvbmVudCwgY29tcG9uZW50UHJvcHMpO1xuICAgIH1cblxuICAgIHZhciBzY29wZSA9IGV4dHJhLnA7XG4gICAgdmFyIGN1c3RvbUV2ZW50cyA9IGV4dHJhLmU7XG4gICAgY29tcG9uZW50LiRfX3NldEN1c3RvbUV2ZW50cyhjdXN0b21FdmVudHMsIHNjb3BlKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgICRfX2NvbXBvbmVudDogY29tcG9uZW50LFxuICAgICAgICAkX19yb290czogZXh0cmEucixcbiAgICAgICAgJF9fZG9tRXZlbnRzOiBleHRyYS5kXG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50RGVmO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcmtvL2NvbXBvbmVudHMvQ29tcG9uZW50RGVmLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* jshint newcap:false */\n\nvar BaseState = __webpack_require__(23);\nvar BaseComponent = __webpack_require__(9);\nvar inherit = __webpack_require__(2);\n\nmodule.exports = function defineComponent(def, renderer) {\n    if (def.$__isComponent) {\n        return def;\n    }\n\n    var ComponentClass;\n    var proto;\n\n    var type = typeof def;\n\n    if (type == 'function') {\n        ComponentClass = def;\n        proto = ComponentClass.prototype;\n    } else if (type == 'object') {\n        ComponentClass = function() {};\n        proto = ComponentClass.prototype = def;\n    } else {\n        throw TypeError();\n    }\n\n    // We don't use the constructor provided by the user\n    // since we don't invoke their constructor until\n    // we have had a chance to do our own initialization.\n    // Instead, we store their constructor in the \"initComponent\"\n    // property and that method gets called later inside\n    // init-components-browser.js\n    function Component(id, doc) {\n        BaseComponent.call(this, id, doc);\n    }\n\n    if (!proto.$__isComponent) {\n        // Inherit from Component if they didn't already\n        inherit(ComponentClass, BaseComponent);\n    }\n\n    // The same prototype will be used by our constructor after\n    // we he have set up the prototype chain using the inherit function\n    proto = Component.prototype = ComponentClass.prototype;\n\n    // proto.constructor = def.constructor = Component;\n\n    // Set a flag on the constructor function to make it clear this is\n    // a component so that we can short-circuit this work later\n    Component.$__isComponent = true;\n\n    function State() { BaseState.apply(this, arguments); }\n    inherit(State, BaseState);\n    proto.$__State = State;\n    proto.$__renderer = renderer;\n\n    return Component;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL2NvbXBvbmVudHMvZGVmaW5lQ29tcG9uZW50LmpzPzM5NDkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLyoganNoaW50IG5ld2NhcDpmYWxzZSAqL1xuXG52YXIgQmFzZVN0YXRlID0gcmVxdWlyZSgnLi9TdGF0ZScpO1xudmFyIEJhc2VDb21wb25lbnQgPSByZXF1aXJlKCcuL0NvbXBvbmVudCcpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdyYXB0b3ItdXRpbC9pbmhlcml0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lQ29tcG9uZW50KGRlZiwgcmVuZGVyZXIpIHtcbiAgICBpZiAoZGVmLiRfX2lzQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiBkZWY7XG4gICAgfVxuXG4gICAgdmFyIENvbXBvbmVudENsYXNzO1xuICAgIHZhciBwcm90bztcblxuICAgIHZhciB0eXBlID0gdHlwZW9mIGRlZjtcblxuICAgIGlmICh0eXBlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgQ29tcG9uZW50Q2xhc3MgPSBkZWY7XG4gICAgICAgIHByb3RvID0gQ29tcG9uZW50Q2xhc3MucHJvdG90eXBlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICBDb21wb25lbnRDbGFzcyA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgIHByb3RvID0gQ29tcG9uZW50Q2xhc3MucHJvdG90eXBlID0gZGVmO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgIH1cblxuICAgIC8vIFdlIGRvbid0IHVzZSB0aGUgY29uc3RydWN0b3IgcHJvdmlkZWQgYnkgdGhlIHVzZXJcbiAgICAvLyBzaW5jZSB3ZSBkb24ndCBpbnZva2UgdGhlaXIgY29uc3RydWN0b3IgdW50aWxcbiAgICAvLyB3ZSBoYXZlIGhhZCBhIGNoYW5jZSB0byBkbyBvdXIgb3duIGluaXRpYWxpemF0aW9uLlxuICAgIC8vIEluc3RlYWQsIHdlIHN0b3JlIHRoZWlyIGNvbnN0cnVjdG9yIGluIHRoZSBcImluaXRDb21wb25lbnRcIlxuICAgIC8vIHByb3BlcnR5IGFuZCB0aGF0IG1ldGhvZCBnZXRzIGNhbGxlZCBsYXRlciBpbnNpZGVcbiAgICAvLyBpbml0LWNvbXBvbmVudHMtYnJvd3Nlci5qc1xuICAgIGZ1bmN0aW9uIENvbXBvbmVudChpZCwgZG9jKSB7XG4gICAgICAgIEJhc2VDb21wb25lbnQuY2FsbCh0aGlzLCBpZCwgZG9jKTtcbiAgICB9XG5cbiAgICBpZiAoIXByb3RvLiRfX2lzQ29tcG9uZW50KSB7XG4gICAgICAgIC8vIEluaGVyaXQgZnJvbSBDb21wb25lbnQgaWYgdGhleSBkaWRuJ3QgYWxyZWFkeVxuICAgICAgICBpbmhlcml0KENvbXBvbmVudENsYXNzLCBCYXNlQ29tcG9uZW50KTtcbiAgICB9XG5cbiAgICAvLyBUaGUgc2FtZSBwcm90b3R5cGUgd2lsbCBiZSB1c2VkIGJ5IG91ciBjb25zdHJ1Y3RvciBhZnRlclxuICAgIC8vIHdlIGhlIGhhdmUgc2V0IHVwIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgdGhlIGluaGVyaXQgZnVuY3Rpb25cbiAgICBwcm90byA9IENvbXBvbmVudC5wcm90b3R5cGUgPSBDb21wb25lbnRDbGFzcy5wcm90b3R5cGU7XG5cbiAgICAvLyBwcm90by5jb25zdHJ1Y3RvciA9IGRlZi5jb25zdHJ1Y3RvciA9IENvbXBvbmVudDtcblxuICAgIC8vIFNldCBhIGZsYWcgb24gdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIG1ha2UgaXQgY2xlYXIgdGhpcyBpc1xuICAgIC8vIGEgY29tcG9uZW50IHNvIHRoYXQgd2UgY2FuIHNob3J0LWNpcmN1aXQgdGhpcyB3b3JrIGxhdGVyXG4gICAgQ29tcG9uZW50LiRfX2lzQ29tcG9uZW50ID0gdHJ1ZTtcblxuICAgIGZ1bmN0aW9uIFN0YXRlKCkgeyBCYXNlU3RhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuICAgIGluaGVyaXQoU3RhdGUsIEJhc2VTdGF0ZSk7XG4gICAgcHJvdG8uJF9fU3RhdGUgPSBTdGF0ZTtcbiAgICBwcm90by4kX19yZW5kZXJlciA9IHJlbmRlcmVyO1xuXG4gICAgcmV0dXJuIENvbXBvbmVudDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWFya28vY29tcG9uZW50cy9kZWZpbmVDb21wb25lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

eval("var componentsUtil = __webpack_require__(0);\nvar runtimeId = componentsUtil.$__runtimeId;\nvar componentLookup = componentsUtil.$__componentLookup;\nvar isArray = Array.isArray;\n\n// We make our best effort to allow multiple marko runtimes to be loaded in the\n// same window. Each marko runtime will get its own unique runtime ID.\nvar listenersAttachedKey = '$MED' + runtimeId;\n\nfunction getEventAttribute(el, attrName) {\n    var virtualAttrs = el._vattrs;\n\n    if (virtualAttrs) {\n        return virtualAttrs[attrName];\n    } else {\n        var attrValue = el.getAttribute(attrName);\n        if (attrValue) {\n            // <method_name> <component_id>[ <extra_args_index]\n            var parts = attrValue.split(' ');\n            if (parts.length == 3) {\n                parts[2] = parseInt(parts[2], 10);\n            }\n\n            return parts;\n        }\n    }\n}\n\nfunction delegateEvent(node, target, event) {\n    var targetMethod = target[0];\n    var targetComponentId = target[1];\n    var extraArgs = target[2];\n\n    var targetComponent = componentLookup[targetComponentId];\n\n    if (!targetComponent) {\n        return;\n    }\n\n    var targetFunc = targetComponent[targetMethod];\n    if (!targetFunc) {\n        throw Error('Method not found: ' + targetMethod);\n    }\n\n    if (extraArgs != null) {\n        if (typeof extraArgs === 'number') {\n            extraArgs = targetComponent.$__bubblingDomEvents[extraArgs];\n            if (!isArray(extraArgs)) {\n                extraArgs = [extraArgs];\n            }\n        }\n    }\n\n    // Invoke the component method\n    if (extraArgs) {\n        targetFunc.apply(targetComponent, extraArgs.concat(event, node));\n    } else {\n        targetFunc.call(targetComponent, event, node);\n    }\n}\n\nfunction attachBubbleEventListeners(doc) {\n    var body = doc.body;\n    // Here's where we handle event delegation using our own mechanism\n    // for delegating events. For each event that we have white-listed\n    // as supporting bubble, we will attach a listener to the root\n    // document.body element. When we get notified of a triggered event,\n    // we again walk up the tree starting at the target associated\n    // with the event to find any mappings for event. Each mapping\n    // is from a DOM event type to a method of a component.\n    __webpack_require__(24).forEach(function addBubbleHandler(eventType) {\n        body.addEventListener(eventType, function(event) {\n            var propagationStopped = false;\n\n            // Monkey-patch to fix #97\n            var oldStopPropagation = event.stopPropagation;\n\n            event.stopPropagation = function() {\n                oldStopPropagation.call(event);\n                propagationStopped = true;\n            };\n\n            var curNode = event.target;\n            if (!curNode) {\n                return;\n            }\n\n            // Search up the tree looking DOM events mapped to target\n            // component methods\n            var attrName = 'data-_on' + eventType;\n            var target;\n\n            // Attributes will have the following form:\n            // on<event_type>(\"<target_method>|<component_id>\")\n\n            do {\n                if ((target = getEventAttribute(curNode, attrName))) {\n                    delegateEvent(curNode, target, event);\n\n                    if (propagationStopped) {\n                        break;\n                    }\n                }\n            } while((curNode = curNode.parentNode) && curNode.getAttribute);\n        });\n    });\n}\n\nfunction noop() {}\n\nexports.$__handleNodeAttach = noop;\nexports.$__handleNodeDetach = noop;\nexports.$__delegateEvent = delegateEvent;\nexports.$__getEventAttribute = getEventAttribute;\n\nexports.$__init = function(doc) {\n    if (!doc[listenersAttachedKey]) {\n        doc[listenersAttachedKey] = true;\n        attachBubbleEventListeners(doc);\n    }\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL2NvbXBvbmVudHMvZXZlbnQtZGVsZWdhdGlvbi5qcz9hMGJkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjb21wb25lbnRzVXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIHJ1bnRpbWVJZCA9IGNvbXBvbmVudHNVdGlsLiRfX3J1bnRpbWVJZDtcbnZhciBjb21wb25lbnRMb29rdXAgPSBjb21wb25lbnRzVXRpbC4kX19jb21wb25lbnRMb29rdXA7XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8vIFdlIG1ha2Ugb3VyIGJlc3QgZWZmb3J0IHRvIGFsbG93IG11bHRpcGxlIG1hcmtvIHJ1bnRpbWVzIHRvIGJlIGxvYWRlZCBpbiB0aGVcbi8vIHNhbWUgd2luZG93LiBFYWNoIG1hcmtvIHJ1bnRpbWUgd2lsbCBnZXQgaXRzIG93biB1bmlxdWUgcnVudGltZSBJRC5cbnZhciBsaXN0ZW5lcnNBdHRhY2hlZEtleSA9ICckTUVEJyArIHJ1bnRpbWVJZDtcblxuZnVuY3Rpb24gZ2V0RXZlbnRBdHRyaWJ1dGUoZWwsIGF0dHJOYW1lKSB7XG4gICAgdmFyIHZpcnR1YWxBdHRycyA9IGVsLl92YXR0cnM7XG5cbiAgICBpZiAodmlydHVhbEF0dHJzKSB7XG4gICAgICAgIHJldHVybiB2aXJ0dWFsQXR0cnNbYXR0ck5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhdHRyVmFsdWUgPSBlbC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICBpZiAoYXR0clZhbHVlKSB7XG4gICAgICAgICAgICAvLyA8bWV0aG9kX25hbWU+IDxjb21wb25lbnRfaWQ+WyA8ZXh0cmFfYXJnc19pbmRleF1cbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IGF0dHJWYWx1ZS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICAgICAgcGFydHNbMl0gPSBwYXJzZUludChwYXJ0c1syXSwgMTApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlbGVnYXRlRXZlbnQobm9kZSwgdGFyZ2V0LCBldmVudCkge1xuICAgIHZhciB0YXJnZXRNZXRob2QgPSB0YXJnZXRbMF07XG4gICAgdmFyIHRhcmdldENvbXBvbmVudElkID0gdGFyZ2V0WzFdO1xuICAgIHZhciBleHRyYUFyZ3MgPSB0YXJnZXRbMl07XG5cbiAgICB2YXIgdGFyZ2V0Q29tcG9uZW50ID0gY29tcG9uZW50TG9va3VwW3RhcmdldENvbXBvbmVudElkXTtcblxuICAgIGlmICghdGFyZ2V0Q29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0RnVuYyA9IHRhcmdldENvbXBvbmVudFt0YXJnZXRNZXRob2RdO1xuICAgIGlmICghdGFyZ2V0RnVuYykge1xuICAgICAgICB0aHJvdyBFcnJvcignTWV0aG9kIG5vdCBmb3VuZDogJyArIHRhcmdldE1ldGhvZCk7XG4gICAgfVxuXG4gICAgaWYgKGV4dHJhQXJncyAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXh0cmFBcmdzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZXh0cmFBcmdzID0gdGFyZ2V0Q29tcG9uZW50LiRfX2J1YmJsaW5nRG9tRXZlbnRzW2V4dHJhQXJnc107XG4gICAgICAgICAgICBpZiAoIWlzQXJyYXkoZXh0cmFBcmdzKSkge1xuICAgICAgICAgICAgICAgIGV4dHJhQXJncyA9IFtleHRyYUFyZ3NdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW52b2tlIHRoZSBjb21wb25lbnQgbWV0aG9kXG4gICAgaWYgKGV4dHJhQXJncykge1xuICAgICAgICB0YXJnZXRGdW5jLmFwcGx5KHRhcmdldENvbXBvbmVudCwgZXh0cmFBcmdzLmNvbmNhdChldmVudCwgbm9kZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldEZ1bmMuY2FsbCh0YXJnZXRDb21wb25lbnQsIGV2ZW50LCBub2RlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGF0dGFjaEJ1YmJsZUV2ZW50TGlzdGVuZXJzKGRvYykge1xuICAgIHZhciBib2R5ID0gZG9jLmJvZHk7XG4gICAgLy8gSGVyZSdzIHdoZXJlIHdlIGhhbmRsZSBldmVudCBkZWxlZ2F0aW9uIHVzaW5nIG91ciBvd24gbWVjaGFuaXNtXG4gICAgLy8gZm9yIGRlbGVnYXRpbmcgZXZlbnRzLiBGb3IgZWFjaCBldmVudCB0aGF0IHdlIGhhdmUgd2hpdGUtbGlzdGVkXG4gICAgLy8gYXMgc3VwcG9ydGluZyBidWJibGUsIHdlIHdpbGwgYXR0YWNoIGEgbGlzdGVuZXIgdG8gdGhlIHJvb3RcbiAgICAvLyBkb2N1bWVudC5ib2R5IGVsZW1lbnQuIFdoZW4gd2UgZ2V0IG5vdGlmaWVkIG9mIGEgdHJpZ2dlcmVkIGV2ZW50LFxuICAgIC8vIHdlIGFnYWluIHdhbGsgdXAgdGhlIHRyZWUgc3RhcnRpbmcgYXQgdGhlIHRhcmdldCBhc3NvY2lhdGVkXG4gICAgLy8gd2l0aCB0aGUgZXZlbnQgdG8gZmluZCBhbnkgbWFwcGluZ3MgZm9yIGV2ZW50LiBFYWNoIG1hcHBpbmdcbiAgICAvLyBpcyBmcm9tIGEgRE9NIGV2ZW50IHR5cGUgdG8gYSBtZXRob2Qgb2YgYSBjb21wb25lbnQuXG4gICAgcmVxdWlyZSgnLi9idWJibGUnKS5mb3JFYWNoKGZ1bmN0aW9uIGFkZEJ1YmJsZUhhbmRsZXIoZXZlbnRUeXBlKSB7XG4gICAgICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIE1vbmtleS1wYXRjaCB0byBmaXggIzk3XG4gICAgICAgICAgICB2YXIgb2xkU3RvcFByb3BhZ2F0aW9uID0gZXZlbnQuc3RvcFByb3BhZ2F0aW9uO1xuXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBvbGRTdG9wUHJvcGFnYXRpb24uY2FsbChldmVudCk7XG4gICAgICAgICAgICAgICAgcHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBjdXJOb2RlID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKCFjdXJOb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZWFyY2ggdXAgdGhlIHRyZWUgbG9va2luZyBET00gZXZlbnRzIG1hcHBlZCB0byB0YXJnZXRcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSAnZGF0YS1fb24nICsgZXZlbnRUeXBlO1xuICAgICAgICAgICAgdmFyIHRhcmdldDtcblxuICAgICAgICAgICAgLy8gQXR0cmlidXRlcyB3aWxsIGhhdmUgdGhlIGZvbGxvd2luZyBmb3JtOlxuICAgICAgICAgICAgLy8gb248ZXZlbnRfdHlwZT4oXCI8dGFyZ2V0X21ldGhvZD58PGNvbXBvbmVudF9pZD5cIilcblxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmICgodGFyZ2V0ID0gZ2V0RXZlbnRBdHRyaWJ1dGUoY3VyTm9kZSwgYXR0ck5hbWUpKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZUV2ZW50KGN1ck5vZGUsIHRhcmdldCwgZXZlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wYWdhdGlvblN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSgoY3VyTm9kZSA9IGN1ck5vZGUucGFyZW50Tm9kZSkgJiYgY3VyTm9kZS5nZXRBdHRyaWJ1dGUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmV4cG9ydHMuJF9faGFuZGxlTm9kZUF0dGFjaCA9IG5vb3A7XG5leHBvcnRzLiRfX2hhbmRsZU5vZGVEZXRhY2ggPSBub29wO1xuZXhwb3J0cy4kX19kZWxlZ2F0ZUV2ZW50ID0gZGVsZWdhdGVFdmVudDtcbmV4cG9ydHMuJF9fZ2V0RXZlbnRBdHRyaWJ1dGUgPSBnZXRFdmVudEF0dHJpYnV0ZTtcblxuZXhwb3J0cy4kX19pbml0ID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgaWYgKCFkb2NbbGlzdGVuZXJzQXR0YWNoZWRLZXldKSB7XG4gICAgICAgIGRvY1tsaXN0ZW5lcnNBdHRhY2hlZEtleV0gPSB0cnVlO1xuICAgICAgICBhdHRhY2hCdWJibGVFdmVudExpc3RlbmVycyhkb2MpO1xuICAgIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcmtvL2NvbXBvbmVudHMvZXZlbnQtZGVsZWdhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar warp10Finalize = __webpack_require__(44);\nvar eventDelegation = __webpack_require__(12);\nvar win = window;\nvar defaultDocument = document;\nvar events = __webpack_require__(7);\nvar componentsUtil = __webpack_require__(0);\nvar componentLookup = componentsUtil.$__componentLookup;\nvar getElementById = componentsUtil.$__getElementById;\nvar ComponentDef = __webpack_require__(10);\n// var extend = require('raptor-util/extend');\n// var registry = require('./registry');\n\nfunction invokeComponentEventHandler(component, targetMethodName, args) {\n    var method = component[targetMethodName];\n    if (!method) {\n        throw Error('Method not found: ' + targetMethodName);\n    }\n\n    method.apply(component, args);\n}\n\nfunction addEventListenerHelper(el, eventType, listener) {\n    el.addEventListener(eventType, listener, false);\n    return function remove() {\n        el.removeEventListener(eventType, listener);\n    };\n}\n\nfunction addDOMEventListeners(component, el, eventType, targetMethodName, extraArgs, handles) {\n    var removeListener = addEventListenerHelper(el, eventType, function(event) {\n        var args = [event, el];\n        if (extraArgs) {\n            args = extraArgs.concat(args);\n        }\n\n        invokeComponentEventHandler(component, targetMethodName, args);\n    });\n    handles.push(removeListener);\n}\n\nfunction initComponent(componentDef, doc) {\n    var component = componentDef.$__component;\n\n    if (!component || !component.$__isComponent) {\n        return; // legacy\n    }\n\n    var domEvents = componentDef.$__domEvents;\n\n    component.$__reset();\n    component.$__document = doc;\n\n    var isExisting = componentDef.$__isExisting;\n    var id = component.id;\n\n    var rootIds = componentDef.$__roots;\n\n    if (rootIds) {\n        var rootComponents;\n\n        var els = [];\n\n        rootIds.forEach(function(rootId) {\n            var nestedId = id + '-' + rootId;\n            var rootComponent = componentLookup[nestedId];\n            if (rootComponent) {\n                rootComponent.$__rootFor = component;\n                if (rootComponents) {\n                    rootComponents.push(rootComponent);\n                } else {\n                    rootComponents = component.$__rootComponents = [rootComponent];\n                }\n            } else {\n                var rootEl = getElementById(doc, nestedId);\n                if (rootEl) {\n                    rootEl._w = component;\n                    els.push(rootEl);\n                }\n            }\n        });\n\n        component.el = els[0];\n        component.els = els;\n        componentLookup[id] = component;\n    } else if (!isExisting) {\n        var el = getElementById(doc, id);\n        el._w = component;\n        component.el = el;\n        component.els = [el];\n        componentLookup[id] = component;\n    }\n\n    if (isExisting) {\n        component.$__removeDOMEventListeners();\n    }\n\n    if (domEvents) {\n        var eventListenerHandles = [];\n\n        domEvents.forEach(function(domEventArgs) {\n            // The event mapping is for a direct DOM event (not a custom event and not for bubblign dom events)\n\n            var eventType = domEventArgs[0];\n            var targetMethodName = domEventArgs[1];\n            var eventEl = getElementById(doc, domEventArgs[2]);\n            var extraArgs = domEventArgs[3];\n\n            addDOMEventListeners(component, eventEl, eventType, targetMethodName, extraArgs, eventListenerHandles);\n        });\n\n        if (eventListenerHandles.length) {\n            component.$__domEventListenerHandles = eventListenerHandles;\n        }\n    }\n\n    if (isExisting) {\n        component.$__emitLifecycleEvent('update');\n    } else {\n        events.emit('mountComponent', component);\n        component.$__emitLifecycleEvent('mount');\n    }\n}\n\n/**\n * This method is used to initialized components associated with UI components\n * rendered in the browser. While rendering UI components a \"components context\"\n * is added to the rendering context to keep up with which components are rendered.\n * When ready, the components can then be initialized by walking the component tree\n * in the components context (nested components are initialized before ancestor components).\n * @param  {Array<marko-components/lib/ComponentDef>} componentDefs An array of ComponentDef instances\n */\nfunction initClientRendered(componentDefs, doc) {\n    // Ensure that event handlers to handle delegating events are\n    // always attached before initializing any components\n    eventDelegation.$__init(doc);\n\n    doc = doc || defaultDocument;\n    for (var i=0,len=componentDefs.length; i<len; i++) {\n        var componentDef = componentDefs[i];\n\n        if (componentDef.$__children) {\n            initClientRendered(componentDef.$__children, doc);\n        }\n\n        initComponent(\n            componentDef,\n            doc);\n    }\n}\n\n/**\n * This method initializes all components that were rendered on the server by iterating over all\n * of the component IDs.\n */\nfunction initServerRendered(renderedComponents, doc) {\n    if (!renderedComponents) {\n        renderedComponents = win.$components;\n\n        if (renderedComponents) {\n            if (renderedComponents.forEach) {\n                renderedComponents.forEach(function(renderedComponent) {\n                    initServerRendered(renderedComponent, doc);\n                });\n            }\n        } else {\n            win.$components = {\n                concat: initServerRendered\n            };\n        }\n        return;\n    }\n    // Ensure that event handlers to handle delegating events are\n    // always attached before initializing any components\n    eventDelegation.$__init(doc || defaultDocument);\n\n    renderedComponents = warp10Finalize(renderedComponents);\n\n    var componentDefs = renderedComponents.w;\n    var typesArray = renderedComponents.t;\n\n    componentDefs.forEach(function(componentDef) {\n        componentDef = ComponentDef.$__deserialize(componentDef, typesArray);\n        initComponent(componentDef, doc || defaultDocument);\n    });\n}\n\nexports.$__initClientRendered = initClientRendered;\nexports.$__initServerRendered = initServerRendered;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL2NvbXBvbmVudHMvaW5pdC1jb21wb25lbnRzLWJyb3dzZXIuanM/NTkxYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgd2FycDEwRmluYWxpemUgPSByZXF1aXJlKCd3YXJwMTAvZmluYWxpemUnKTtcbnZhciBldmVudERlbGVnYXRpb24gPSByZXF1aXJlKCcuL2V2ZW50LWRlbGVnYXRpb24nKTtcbnZhciB3aW4gPSB3aW5kb3c7XG52YXIgZGVmYXVsdERvY3VtZW50ID0gZG9jdW1lbnQ7XG52YXIgZXZlbnRzID0gcmVxdWlyZSgnLi4vcnVudGltZS9ldmVudHMnKTtcbnZhciBjb21wb25lbnRzVXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGNvbXBvbmVudExvb2t1cCA9IGNvbXBvbmVudHNVdGlsLiRfX2NvbXBvbmVudExvb2t1cDtcbnZhciBnZXRFbGVtZW50QnlJZCA9IGNvbXBvbmVudHNVdGlsLiRfX2dldEVsZW1lbnRCeUlkO1xudmFyIENvbXBvbmVudERlZiA9IHJlcXVpcmUoJy4vQ29tcG9uZW50RGVmJyk7XG4vLyB2YXIgZXh0ZW5kID0gcmVxdWlyZSgncmFwdG9yLXV0aWwvZXh0ZW5kJyk7XG4vLyB2YXIgcmVnaXN0cnkgPSByZXF1aXJlKCcuL3JlZ2lzdHJ5Jyk7XG5cbmZ1bmN0aW9uIGludm9rZUNvbXBvbmVudEV2ZW50SGFuZGxlcihjb21wb25lbnQsIHRhcmdldE1ldGhvZE5hbWUsIGFyZ3MpIHtcbiAgICB2YXIgbWV0aG9kID0gY29tcG9uZW50W3RhcmdldE1ldGhvZE5hbWVdO1xuICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdNZXRob2Qgbm90IGZvdW5kOiAnICsgdGFyZ2V0TWV0aG9kTmFtZSk7XG4gICAgfVxuXG4gICAgbWV0aG9kLmFwcGx5KGNvbXBvbmVudCwgYXJncyk7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJIZWxwZXIoZWwsIGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGFkZERPTUV2ZW50TGlzdGVuZXJzKGNvbXBvbmVudCwgZWwsIGV2ZW50VHlwZSwgdGFyZ2V0TWV0aG9kTmFtZSwgZXh0cmFBcmdzLCBoYW5kbGVzKSB7XG4gICAgdmFyIHJlbW92ZUxpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lckhlbHBlcihlbCwgZXZlbnRUeXBlLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgYXJncyA9IFtldmVudCwgZWxdO1xuICAgICAgICBpZiAoZXh0cmFBcmdzKSB7XG4gICAgICAgICAgICBhcmdzID0gZXh0cmFBcmdzLmNvbmNhdChhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGludm9rZUNvbXBvbmVudEV2ZW50SGFuZGxlcihjb21wb25lbnQsIHRhcmdldE1ldGhvZE5hbWUsIGFyZ3MpO1xuICAgIH0pO1xuICAgIGhhbmRsZXMucHVzaChyZW1vdmVMaXN0ZW5lcik7XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wb25lbnQoY29tcG9uZW50RGVmLCBkb2MpIHtcbiAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50RGVmLiRfX2NvbXBvbmVudDtcblxuICAgIGlmICghY29tcG9uZW50IHx8ICFjb21wb25lbnQuJF9faXNDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBsZWdhY3lcbiAgICB9XG5cbiAgICB2YXIgZG9tRXZlbnRzID0gY29tcG9uZW50RGVmLiRfX2RvbUV2ZW50cztcblxuICAgIGNvbXBvbmVudC4kX19yZXNldCgpO1xuICAgIGNvbXBvbmVudC4kX19kb2N1bWVudCA9IGRvYztcblxuICAgIHZhciBpc0V4aXN0aW5nID0gY29tcG9uZW50RGVmLiRfX2lzRXhpc3Rpbmc7XG4gICAgdmFyIGlkID0gY29tcG9uZW50LmlkO1xuXG4gICAgdmFyIHJvb3RJZHMgPSBjb21wb25lbnREZWYuJF9fcm9vdHM7XG5cbiAgICBpZiAocm9vdElkcykge1xuICAgICAgICB2YXIgcm9vdENvbXBvbmVudHM7XG5cbiAgICAgICAgdmFyIGVscyA9IFtdO1xuXG4gICAgICAgIHJvb3RJZHMuZm9yRWFjaChmdW5jdGlvbihyb290SWQpIHtcbiAgICAgICAgICAgIHZhciBuZXN0ZWRJZCA9IGlkICsgJy0nICsgcm9vdElkO1xuICAgICAgICAgICAgdmFyIHJvb3RDb21wb25lbnQgPSBjb21wb25lbnRMb29rdXBbbmVzdGVkSWRdO1xuICAgICAgICAgICAgaWYgKHJvb3RDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICByb290Q29tcG9uZW50LiRfX3Jvb3RGb3IgPSBjb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHJvb3RDb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RDb21wb25lbnRzLnB1c2gocm9vdENvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdENvbXBvbmVudHMgPSBjb21wb25lbnQuJF9fcm9vdENvbXBvbmVudHMgPSBbcm9vdENvbXBvbmVudF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdEVsID0gZ2V0RWxlbWVudEJ5SWQoZG9jLCBuZXN0ZWRJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJvb3RFbCkge1xuICAgICAgICAgICAgICAgICAgICByb290RWwuX3cgPSBjb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGVscy5wdXNoKHJvb3RFbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb21wb25lbnQuZWwgPSBlbHNbMF07XG4gICAgICAgIGNvbXBvbmVudC5lbHMgPSBlbHM7XG4gICAgICAgIGNvbXBvbmVudExvb2t1cFtpZF0gPSBjb21wb25lbnQ7XG4gICAgfSBlbHNlIGlmICghaXNFeGlzdGluZykge1xuICAgICAgICB2YXIgZWwgPSBnZXRFbGVtZW50QnlJZChkb2MsIGlkKTtcbiAgICAgICAgZWwuX3cgPSBjb21wb25lbnQ7XG4gICAgICAgIGNvbXBvbmVudC5lbCA9IGVsO1xuICAgICAgICBjb21wb25lbnQuZWxzID0gW2VsXTtcbiAgICAgICAgY29tcG9uZW50TG9va3VwW2lkXSA9IGNvbXBvbmVudDtcbiAgICB9XG5cbiAgICBpZiAoaXNFeGlzdGluZykge1xuICAgICAgICBjb21wb25lbnQuJF9fcmVtb3ZlRE9NRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBpZiAoZG9tRXZlbnRzKSB7XG4gICAgICAgIHZhciBldmVudExpc3RlbmVySGFuZGxlcyA9IFtdO1xuXG4gICAgICAgIGRvbUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGRvbUV2ZW50QXJncykge1xuICAgICAgICAgICAgLy8gVGhlIGV2ZW50IG1hcHBpbmcgaXMgZm9yIGEgZGlyZWN0IERPTSBldmVudCAobm90IGEgY3VzdG9tIGV2ZW50IGFuZCBub3QgZm9yIGJ1YmJsaWduIGRvbSBldmVudHMpXG5cbiAgICAgICAgICAgIHZhciBldmVudFR5cGUgPSBkb21FdmVudEFyZ3NbMF07XG4gICAgICAgICAgICB2YXIgdGFyZ2V0TWV0aG9kTmFtZSA9IGRvbUV2ZW50QXJnc1sxXTtcbiAgICAgICAgICAgIHZhciBldmVudEVsID0gZ2V0RWxlbWVudEJ5SWQoZG9jLCBkb21FdmVudEFyZ3NbMl0pO1xuICAgICAgICAgICAgdmFyIGV4dHJhQXJncyA9IGRvbUV2ZW50QXJnc1szXTtcblxuICAgICAgICAgICAgYWRkRE9NRXZlbnRMaXN0ZW5lcnMoY29tcG9uZW50LCBldmVudEVsLCBldmVudFR5cGUsIHRhcmdldE1ldGhvZE5hbWUsIGV4dHJhQXJncywgZXZlbnRMaXN0ZW5lckhhbmRsZXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZXZlbnRMaXN0ZW5lckhhbmRsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb21wb25lbnQuJF9fZG9tRXZlbnRMaXN0ZW5lckhhbmRsZXMgPSBldmVudExpc3RlbmVySGFuZGxlcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0V4aXN0aW5nKSB7XG4gICAgICAgIGNvbXBvbmVudC4kX19lbWl0TGlmZWN5Y2xlRXZlbnQoJ3VwZGF0ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50cy5lbWl0KCdtb3VudENvbXBvbmVudCcsIGNvbXBvbmVudCk7XG4gICAgICAgIGNvbXBvbmVudC4kX19lbWl0TGlmZWN5Y2xlRXZlbnQoJ21vdW50Jyk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gaW5pdGlhbGl6ZWQgY29tcG9uZW50cyBhc3NvY2lhdGVkIHdpdGggVUkgY29tcG9uZW50c1xuICogcmVuZGVyZWQgaW4gdGhlIGJyb3dzZXIuIFdoaWxlIHJlbmRlcmluZyBVSSBjb21wb25lbnRzIGEgXCJjb21wb25lbnRzIGNvbnRleHRcIlxuICogaXMgYWRkZWQgdG8gdGhlIHJlbmRlcmluZyBjb250ZXh0IHRvIGtlZXAgdXAgd2l0aCB3aGljaCBjb21wb25lbnRzIGFyZSByZW5kZXJlZC5cbiAqIFdoZW4gcmVhZHksIHRoZSBjb21wb25lbnRzIGNhbiB0aGVuIGJlIGluaXRpYWxpemVkIGJ5IHdhbGtpbmcgdGhlIGNvbXBvbmVudCB0cmVlXG4gKiBpbiB0aGUgY29tcG9uZW50cyBjb250ZXh0IChuZXN0ZWQgY29tcG9uZW50cyBhcmUgaW5pdGlhbGl6ZWQgYmVmb3JlIGFuY2VzdG9yIGNvbXBvbmVudHMpLlxuICogQHBhcmFtICB7QXJyYXk8bWFya28tY29tcG9uZW50cy9saWIvQ29tcG9uZW50RGVmPn0gY29tcG9uZW50RGVmcyBBbiBhcnJheSBvZiBDb21wb25lbnREZWYgaW5zdGFuY2VzXG4gKi9cbmZ1bmN0aW9uIGluaXRDbGllbnRSZW5kZXJlZChjb21wb25lbnREZWZzLCBkb2MpIHtcbiAgICAvLyBFbnN1cmUgdGhhdCBldmVudCBoYW5kbGVycyB0byBoYW5kbGUgZGVsZWdhdGluZyBldmVudHMgYXJlXG4gICAgLy8gYWx3YXlzIGF0dGFjaGVkIGJlZm9yZSBpbml0aWFsaXppbmcgYW55IGNvbXBvbmVudHNcbiAgICBldmVudERlbGVnYXRpb24uJF9faW5pdChkb2MpO1xuXG4gICAgZG9jID0gZG9jIHx8IGRlZmF1bHREb2N1bWVudDtcbiAgICBmb3IgKHZhciBpPTAsbGVuPWNvbXBvbmVudERlZnMubGVuZ3RoOyBpPGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjb21wb25lbnREZWYgPSBjb21wb25lbnREZWZzW2ldO1xuXG4gICAgICAgIGlmIChjb21wb25lbnREZWYuJF9fY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGluaXRDbGllbnRSZW5kZXJlZChjb21wb25lbnREZWYuJF9fY2hpbGRyZW4sIGRvYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpbml0Q29tcG9uZW50KFxuICAgICAgICAgICAgY29tcG9uZW50RGVmLFxuICAgICAgICAgICAgZG9jKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaW5pdGlhbGl6ZXMgYWxsIGNvbXBvbmVudHMgdGhhdCB3ZXJlIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXIgYnkgaXRlcmF0aW5nIG92ZXIgYWxsXG4gKiBvZiB0aGUgY29tcG9uZW50IElEcy5cbiAqL1xuZnVuY3Rpb24gaW5pdFNlcnZlclJlbmRlcmVkKHJlbmRlcmVkQ29tcG9uZW50cywgZG9jKSB7XG4gICAgaWYgKCFyZW5kZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgcmVuZGVyZWRDb21wb25lbnRzID0gd2luLiRjb21wb25lbnRzO1xuXG4gICAgICAgIGlmIChyZW5kZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlZENvbXBvbmVudHMuZm9yRWFjaCkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkQ29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHJlbmRlcmVkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRTZXJ2ZXJSZW5kZXJlZChyZW5kZXJlZENvbXBvbmVudCwgZG9jKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbi4kY29tcG9uZW50cyA9IHtcbiAgICAgICAgICAgICAgICBjb25jYXQ6IGluaXRTZXJ2ZXJSZW5kZXJlZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEVuc3VyZSB0aGF0IGV2ZW50IGhhbmRsZXJzIHRvIGhhbmRsZSBkZWxlZ2F0aW5nIGV2ZW50cyBhcmVcbiAgICAvLyBhbHdheXMgYXR0YWNoZWQgYmVmb3JlIGluaXRpYWxpemluZyBhbnkgY29tcG9uZW50c1xuICAgIGV2ZW50RGVsZWdhdGlvbi4kX19pbml0KGRvYyB8fCBkZWZhdWx0RG9jdW1lbnQpO1xuXG4gICAgcmVuZGVyZWRDb21wb25lbnRzID0gd2FycDEwRmluYWxpemUocmVuZGVyZWRDb21wb25lbnRzKTtcblxuICAgIHZhciBjb21wb25lbnREZWZzID0gcmVuZGVyZWRDb21wb25lbnRzLnc7XG4gICAgdmFyIHR5cGVzQXJyYXkgPSByZW5kZXJlZENvbXBvbmVudHMudDtcblxuICAgIGNvbXBvbmVudERlZnMuZm9yRWFjaChmdW5jdGlvbihjb21wb25lbnREZWYpIHtcbiAgICAgICAgY29tcG9uZW50RGVmID0gQ29tcG9uZW50RGVmLiRfX2Rlc2VyaWFsaXplKGNvbXBvbmVudERlZiwgdHlwZXNBcnJheSk7XG4gICAgICAgIGluaXRDb21wb25lbnQoY29tcG9uZW50RGVmLCBkb2MgfHwgZGVmYXVsdERvY3VtZW50KTtcbiAgICB9KTtcbn1cblxuZXhwb3J0cy4kX19pbml0Q2xpZW50UmVuZGVyZWQgPSBpbml0Q2xpZW50UmVuZGVyZWQ7XG5leHBvcnRzLiRfX2luaXRTZXJ2ZXJSZW5kZXJlZCA9IGluaXRTZXJ2ZXJSZW5kZXJlZDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWFya28vY29tcG9uZW50cy9pbml0LWNvbXBvbmVudHMtYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

eval("var REPEATED_ID_KEY = '$rep';\n\nmodule.exports = function nextRepeatedId(out, parentId, id) {\n    var nextIdLookup = out.global[REPEATED_ID_KEY] || (out.global[REPEATED_ID_KEY] = {});\n\n    var indexLookupKey = parentId + '-' + id;\n    var currentIndex = nextIdLookup[indexLookupKey];\n    if (currentIndex == null) {\n        currentIndex = nextIdLookup[indexLookupKey] = 0;\n    } else {\n        currentIndex = ++nextIdLookup[indexLookupKey];\n    }\n\n    return indexLookupKey.slice(0, -2) + '[' + currentIndex + ']';\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL2NvbXBvbmVudHMvbmV4dFJlcGVhdGVkSWQuanM/NjdjOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUkVQRUFURURfSURfS0VZID0gJyRyZXAnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5leHRSZXBlYXRlZElkKG91dCwgcGFyZW50SWQsIGlkKSB7XG4gICAgdmFyIG5leHRJZExvb2t1cCA9IG91dC5nbG9iYWxbUkVQRUFURURfSURfS0VZXSB8fCAob3V0Lmdsb2JhbFtSRVBFQVRFRF9JRF9LRVldID0ge30pO1xuXG4gICAgdmFyIGluZGV4TG9va3VwS2V5ID0gcGFyZW50SWQgKyAnLScgKyBpZDtcbiAgICB2YXIgY3VycmVudEluZGV4ID0gbmV4dElkTG9va3VwW2luZGV4TG9va3VwS2V5XTtcbiAgICBpZiAoY3VycmVudEluZGV4ID09IG51bGwpIHtcbiAgICAgICAgY3VycmVudEluZGV4ID0gbmV4dElkTG9va3VwW2luZGV4TG9va3VwS2V5XSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudEluZGV4ID0gKytuZXh0SWRMb29rdXBbaW5kZXhMb29rdXBLZXldO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleExvb2t1cEtleS5zbGljZSgwLCAtMikgKyAnWycgKyBjdXJyZW50SW5kZXggKyAnXSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcmtvL2NvbXBvbmVudHMvbmV4dFJlcGVhdGVkSWQuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

eval("var domInsert = __webpack_require__(16);\nvar EMPTY_ARRAY = [];\n\n\nfunction getComponentDefs(result) {\n    var componentDefs = result.$__components;\n\n    if (!componentDefs.length) {\n        throw Error('No component');\n    }\n    return componentDefs;\n}\n\nfunction RenderResult(out) {\n   this.out = this.$__out = out;\n   this.$__components = undefined;\n}\n\nmodule.exports = RenderResult;\n\nvar proto = RenderResult.prototype = {\n    getComponent: function() {\n        return this.getComponents()[0];\n    },\n    getComponents: function(selector) {\n        if (!this.$__components) {\n            throw Error('Not added to DOM');\n        }\n\n        var componentDefs = getComponentDefs(this);\n\n        var components = [];\n\n        componentDefs.forEach(function(componentDef) {\n            var component = componentDef.$__component;\n            if (!selector || selector(component)) {\n                components.push(component);\n            }\n        });\n\n        return components;\n    },\n\n    afterInsert: function(doc) {\n        var out = this.$__out;\n        var componentsContext = out.global.components;\n        if (componentsContext) {\n            this.$__components = componentsContext.$__components;\n            componentsContext.$__initComponents(doc);\n        } else {\n            this.$__components = EMPTY_ARRAY;\n        }\n\n        return this;\n    },\n    getNode: function(doc) {\n        return this.$__out.$__getNode(doc);\n    },\n    getOutput: function() {\n        return this.$__out.$__getOutput();\n    },\n    toString: function() {\n        return this.$__out.toString();\n    },\n    document: typeof document != 'undefined' && document\n};\n\n// Add all of the following DOM methods to Component.prototype:\n// - appendTo(referenceEl)\n// - replace(referenceEl)\n// - replaceChildrenOf(referenceEl)\n// - insertBefore(referenceEl)\n// - insertAfter(referenceEl)\n// - prependTo(referenceEl)\ndomInsert(\n    proto,\n    function getEl(renderResult, referenceEl) {\n        return renderResult.getNode(referenceEl.ownerDocument);\n    },\n    function afterInsert(renderResult, referenceEl) {\n        return renderResult.afterInsert(referenceEl.ownerDocument);\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL3J1bnRpbWUvUmVuZGVyUmVzdWx0LmpzP2Q5YjUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGRvbUluc2VydCA9IHJlcXVpcmUoJy4vZG9tLWluc2VydCcpO1xudmFyIEVNUFRZX0FSUkFZID0gW107XG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50RGVmcyhyZXN1bHQpIHtcbiAgICB2YXIgY29tcG9uZW50RGVmcyA9IHJlc3VsdC4kX19jb21wb25lbnRzO1xuXG4gICAgaWYgKCFjb21wb25lbnREZWZzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBFcnJvcignTm8gY29tcG9uZW50Jyk7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnREZWZzO1xufVxuXG5mdW5jdGlvbiBSZW5kZXJSZXN1bHQob3V0KSB7XG4gICB0aGlzLm91dCA9IHRoaXMuJF9fb3V0ID0gb3V0O1xuICAgdGhpcy4kX19jb21wb25lbnRzID0gdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlclJlc3VsdDtcblxudmFyIHByb3RvID0gUmVuZGVyUmVzdWx0LnByb3RvdHlwZSA9IHtcbiAgICBnZXRDb21wb25lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnRzKClbMF07XG4gICAgfSxcbiAgICBnZXRDb21wb25lbnRzOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICBpZiAoIXRoaXMuJF9fY29tcG9uZW50cykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ05vdCBhZGRlZCB0byBET00nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb21wb25lbnREZWZzID0gZ2V0Q29tcG9uZW50RGVmcyh0aGlzKTtcblxuICAgICAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuXG4gICAgICAgIGNvbXBvbmVudERlZnMuZm9yRWFjaChmdW5jdGlvbihjb21wb25lbnREZWYpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnREZWYuJF9fY29tcG9uZW50O1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RvciB8fCBzZWxlY3Rvcihjb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH0sXG5cbiAgICBhZnRlckluc2VydDogZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIHZhciBvdXQgPSB0aGlzLiRfX291dDtcbiAgICAgICAgdmFyIGNvbXBvbmVudHNDb250ZXh0ID0gb3V0Lmdsb2JhbC5jb21wb25lbnRzO1xuICAgICAgICBpZiAoY29tcG9uZW50c0NvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuJF9fY29tcG9uZW50cyA9IGNvbXBvbmVudHNDb250ZXh0LiRfX2NvbXBvbmVudHM7XG4gICAgICAgICAgICBjb21wb25lbnRzQ29udGV4dC4kX19pbml0Q29tcG9uZW50cyhkb2MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kX19jb21wb25lbnRzID0gRU1QVFlfQVJSQVk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGdldE5vZGU6IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICByZXR1cm4gdGhpcy4kX19vdXQuJF9fZ2V0Tm9kZShkb2MpO1xuICAgIH0sXG4gICAgZ2V0T3V0cHV0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJF9fb3V0LiRfX2dldE91dHB1dCgpO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kX19vdXQudG9TdHJpbmcoKTtcbiAgICB9LFxuICAgIGRvY3VtZW50OiB0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnRcbn07XG5cbi8vIEFkZCBhbGwgb2YgdGhlIGZvbGxvd2luZyBET00gbWV0aG9kcyB0byBDb21wb25lbnQucHJvdG90eXBlOlxuLy8gLSBhcHBlbmRUbyhyZWZlcmVuY2VFbClcbi8vIC0gcmVwbGFjZShyZWZlcmVuY2VFbClcbi8vIC0gcmVwbGFjZUNoaWxkcmVuT2YocmVmZXJlbmNlRWwpXG4vLyAtIGluc2VydEJlZm9yZShyZWZlcmVuY2VFbClcbi8vIC0gaW5zZXJ0QWZ0ZXIocmVmZXJlbmNlRWwpXG4vLyAtIHByZXBlbmRUbyhyZWZlcmVuY2VFbClcbmRvbUluc2VydChcbiAgICBwcm90byxcbiAgICBmdW5jdGlvbiBnZXRFbChyZW5kZXJSZXN1bHQsIHJlZmVyZW5jZUVsKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJSZXN1bHQuZ2V0Tm9kZShyZWZlcmVuY2VFbC5vd25lckRvY3VtZW50KTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGFmdGVySW5zZXJ0KHJlbmRlclJlc3VsdCwgcmVmZXJlbmNlRWwpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlclJlc3VsdC5hZnRlckluc2VydChyZWZlcmVuY2VFbC5vd25lckRvY3VtZW50KTtcbiAgICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYXJrby9ydW50aW1lL1JlbmRlclJlc3VsdC5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

eval("var extend = __webpack_require__(1);\nvar componentsUtil = __webpack_require__(0);\nvar destroyComponentForEl = componentsUtil.$__destroyComponentForEl;\nvar destroyElRecursive = componentsUtil.$__destroyElRecursive;\n\nfunction resolveEl(el) {\n    if (typeof el == 'string') {\n        var elId = el;\n        el = document.getElementById(elId);\n        if (!el) {\n            throw Error('Not found: ' + elId);\n        }\n    }\n    return el;\n}\n\nfunction beforeRemove(referenceEl) {\n    destroyElRecursive(referenceEl);\n    destroyComponentForEl(referenceEl);\n}\n\nmodule.exports = function(target, getEl, afterInsert) {\n    extend(target, {\n        appendTo: function(referenceEl) {\n            referenceEl = resolveEl(referenceEl);\n            var el = getEl(this, referenceEl);\n            referenceEl.appendChild(el);\n            return afterInsert(this, referenceEl);\n        },\n        prependTo: function(referenceEl) {\n            referenceEl = resolveEl(referenceEl);\n            var el = getEl(this, referenceEl);\n            referenceEl.insertBefore(el, referenceEl.firstChild || null);\n            return afterInsert(this, referenceEl);\n        },\n        replace: function(referenceEl) {\n            referenceEl = resolveEl(referenceEl);\n            var el = getEl(this, referenceEl);\n            beforeRemove(referenceEl);\n            referenceEl.parentNode.replaceChild(el, referenceEl);\n            return afterInsert(this, referenceEl);\n        },\n        replaceChildrenOf: function(referenceEl) {\n            referenceEl = resolveEl(referenceEl);\n            var el = getEl(this, referenceEl);\n\n            var curChild = referenceEl.firstChild;\n            while(curChild) {\n                var nextSibling = curChild.nextSibling; // Just in case the DOM changes while removing\n                if (curChild.nodeType == 1) {\n                    beforeRemove(curChild);\n                }\n                curChild = nextSibling;\n            }\n\n            referenceEl.innerHTML = '';\n            referenceEl.appendChild(el);\n            return afterInsert(this, referenceEl);\n        },\n        insertBefore: function(referenceEl) {\n            referenceEl = resolveEl(referenceEl);\n            var el = getEl(this, referenceEl);\n            referenceEl.parentNode.insertBefore(el, referenceEl);\n            return afterInsert(this, referenceEl);\n        },\n        insertAfter: function(referenceEl) {\n            referenceEl = resolveEl(referenceEl);\n            var el = getEl(this, referenceEl);\n            el = el;\n            var nextSibling = referenceEl.nextSibling;\n            var parentNode = referenceEl.parentNode;\n            if (nextSibling) {\n                parentNode.insertBefore(el, nextSibling);\n            } else {\n                parentNode.appendChild(el);\n            }\n            return afterInsert(this, referenceEl);\n        }\n    });\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL3J1bnRpbWUvZG9tLWluc2VydC5qcz9jYmNkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBleHRlbmQgPSByZXF1aXJlKCdyYXB0b3ItdXRpbC9leHRlbmQnKTtcbnZhciBjb21wb25lbnRzVXRpbCA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvdXRpbCcpO1xudmFyIGRlc3Ryb3lDb21wb25lbnRGb3JFbCA9IGNvbXBvbmVudHNVdGlsLiRfX2Rlc3Ryb3lDb21wb25lbnRGb3JFbDtcbnZhciBkZXN0cm95RWxSZWN1cnNpdmUgPSBjb21wb25lbnRzVXRpbC4kX19kZXN0cm95RWxSZWN1cnNpdmU7XG5cbmZ1bmN0aW9uIHJlc29sdmVFbChlbCkge1xuICAgIGlmICh0eXBlb2YgZWwgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGVsSWQgPSBlbDtcbiAgICAgICAgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbElkKTtcbiAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ05vdCBmb3VuZDogJyArIGVsSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbDtcbn1cblxuZnVuY3Rpb24gYmVmb3JlUmVtb3ZlKHJlZmVyZW5jZUVsKSB7XG4gICAgZGVzdHJveUVsUmVjdXJzaXZlKHJlZmVyZW5jZUVsKTtcbiAgICBkZXN0cm95Q29tcG9uZW50Rm9yRWwocmVmZXJlbmNlRWwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgZ2V0RWwsIGFmdGVySW5zZXJ0KSB7XG4gICAgZXh0ZW5kKHRhcmdldCwge1xuICAgICAgICBhcHBlbmRUbzogZnVuY3Rpb24ocmVmZXJlbmNlRWwpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZUVsID0gcmVzb2x2ZUVsKHJlZmVyZW5jZUVsKTtcbiAgICAgICAgICAgIHZhciBlbCA9IGdldEVsKHRoaXMsIHJlZmVyZW5jZUVsKTtcbiAgICAgICAgICAgIHJlZmVyZW5jZUVsLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgICAgIHJldHVybiBhZnRlckluc2VydCh0aGlzLCByZWZlcmVuY2VFbCk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZXBlbmRUbzogZnVuY3Rpb24ocmVmZXJlbmNlRWwpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZUVsID0gcmVzb2x2ZUVsKHJlZmVyZW5jZUVsKTtcbiAgICAgICAgICAgIHZhciBlbCA9IGdldEVsKHRoaXMsIHJlZmVyZW5jZUVsKTtcbiAgICAgICAgICAgIHJlZmVyZW5jZUVsLmluc2VydEJlZm9yZShlbCwgcmVmZXJlbmNlRWwuZmlyc3RDaGlsZCB8fCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBhZnRlckluc2VydCh0aGlzLCByZWZlcmVuY2VFbCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlcGxhY2U6IGZ1bmN0aW9uKHJlZmVyZW5jZUVsKSB7XG4gICAgICAgICAgICByZWZlcmVuY2VFbCA9IHJlc29sdmVFbChyZWZlcmVuY2VFbCk7XG4gICAgICAgICAgICB2YXIgZWwgPSBnZXRFbCh0aGlzLCByZWZlcmVuY2VFbCk7XG4gICAgICAgICAgICBiZWZvcmVSZW1vdmUocmVmZXJlbmNlRWwpO1xuICAgICAgICAgICAgcmVmZXJlbmNlRWwucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZWwsIHJlZmVyZW5jZUVsKTtcbiAgICAgICAgICAgIHJldHVybiBhZnRlckluc2VydCh0aGlzLCByZWZlcmVuY2VFbCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlcGxhY2VDaGlsZHJlbk9mOiBmdW5jdGlvbihyZWZlcmVuY2VFbCkge1xuICAgICAgICAgICAgcmVmZXJlbmNlRWwgPSByZXNvbHZlRWwocmVmZXJlbmNlRWwpO1xuICAgICAgICAgICAgdmFyIGVsID0gZ2V0RWwodGhpcywgcmVmZXJlbmNlRWwpO1xuXG4gICAgICAgICAgICB2YXIgY3VyQ2hpbGQgPSByZWZlcmVuY2VFbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgd2hpbGUoY3VyQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBjdXJDaGlsZC5uZXh0U2libGluZzsgLy8gSnVzdCBpbiBjYXNlIHRoZSBET00gY2hhbmdlcyB3aGlsZSByZW1vdmluZ1xuICAgICAgICAgICAgICAgIGlmIChjdXJDaGlsZC5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZVJlbW92ZShjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gbmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlZmVyZW5jZUVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgcmVmZXJlbmNlRWwuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgcmV0dXJuIGFmdGVySW5zZXJ0KHRoaXMsIHJlZmVyZW5jZUVsKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbihyZWZlcmVuY2VFbCkge1xuICAgICAgICAgICAgcmVmZXJlbmNlRWwgPSByZXNvbHZlRWwocmVmZXJlbmNlRWwpO1xuICAgICAgICAgICAgdmFyIGVsID0gZ2V0RWwodGhpcywgcmVmZXJlbmNlRWwpO1xuICAgICAgICAgICAgcmVmZXJlbmNlRWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIHJlZmVyZW5jZUVsKTtcbiAgICAgICAgICAgIHJldHVybiBhZnRlckluc2VydCh0aGlzLCByZWZlcmVuY2VFbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGluc2VydEFmdGVyOiBmdW5jdGlvbihyZWZlcmVuY2VFbCkge1xuICAgICAgICAgICAgcmVmZXJlbmNlRWwgPSByZXNvbHZlRWwocmVmZXJlbmNlRWwpO1xuICAgICAgICAgICAgdmFyIGVsID0gZ2V0RWwodGhpcywgcmVmZXJlbmNlRWwpO1xuICAgICAgICAgICAgZWwgPSBlbDtcbiAgICAgICAgICAgIHZhciBuZXh0U2libGluZyA9IHJlZmVyZW5jZUVsLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSByZWZlcmVuY2VFbC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIG5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWZ0ZXJJbnNlcnQodGhpcywgcmVmZXJlbmNlRWwpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcmtvL3J1bnRpbWUvZG9tLWluc2VydC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

eval("var VNode = __webpack_require__(3);\nvar inherit = __webpack_require__(2);\nvar extend = __webpack_require__(1);\n\nvar NS_XLINK = 'http://www.w3.org/1999/xlink';\nvar ATTR_XLINK_HREF = 'xlink:href';\nvar toString = String;\n\nvar FLAG_IS_SVG = 1;\nvar FLAG_IS_TEXTAREA = 2;\nvar FLAG_SIMPLE_ATTRS = 4;\n\nvar defineProperty = Object.defineProperty;\n\n\nvar ATTR_HREF = 'href';\nvar EMPTY_OBJECT = Object.freeze({});\nvar ATTR_MARKO_CONST = 'data-_mc';\n\nvar specialAttrRegexp = /^data-_/;\n\n\nfunction convertAttrValue(type, value) {\n    if (value === true) {\n        return '';\n    } else if (type == 'object') {\n        return JSON.stringify(value);\n    } else {\n        return toString(value);\n    }\n}\n\nfunction VElementClone(other) {\n    extend(this, other);\n    this.$__parentNode = null;\n    this.$__nextSibling = null;\n}\n\nfunction VElement(tagName, attrs, childCount, flags, constId) {\n    this.$__VNode(childCount);\n\n    if (constId) {\n        if (!attrs) {\n            attrs = {};\n        }\n        attrs[ATTR_MARKO_CONST] = constId;\n    }\n\n    var namespaceURI;\n\n    if ((this.$__flags = flags || 0)) {\n        if (flags & FLAG_IS_SVG) {\n            namespaceURI = 'http://www.w3.org/2000/svg';\n        }\n    }\n\n    this.$__attributes = attrs || EMPTY_OBJECT;\n    this.$__namespaceURI = namespaceURI;\n    this.nodeName = tagName;\n    this.$__value = null;\n    this.$__constId = constId;\n}\n\nVElement.prototype = {\n    $__VElement: true,\n\n    nodeType: 1,\n\n    $__cloneNode: function() {\n        return new VElementClone(this);\n    },\n\n    /**\n     * Shorthand method for creating and appending an HTML element\n     *\n     * @param  {String} tagName    The tag name (e.g. \"div\")\n     * @param  {int|null} attrCount  The number of attributes (or `null` if not known)\n     * @param  {int|null} childCount The number of child nodes (or `null` if not known)\n     */\n    e: function(tagName, attrs, childCount, flags, constId) {\n        var child = this.$__appendChild(new VElement(tagName, attrs, childCount, flags, constId));\n\n        if (childCount === 0) {\n            return this.$__finishChild();\n        } else {\n            return child;\n        }\n    },\n\n\n\n    /**\n     * Shorthand method for creating and appending a static node. The provided node is automatically cloned\n     * using a shallow clone since it will be mutated as a result of setting `nextSibling` and `parentNode`.\n     *\n     * @param  {String} value The value for the new Comment node\n     */\n    n: function(node) {\n        this.$__appendChild(node.$__cloneNode());\n        return this.$__finishChild();\n    },\n\n    $__actualize: function(doc) {\n        var namespaceURI = this.$__namespaceURI;\n        var tagName = this.nodeName;\n\n        var el = namespaceURI ?\n            doc.createElementNS(namespaceURI, tagName) :\n            doc.createElement(tagName);\n\n\n        var attributes = this.$__attributes;\n        for (var attrName in attributes) {\n            var attrValue = attributes[attrName];\n\n            if (attrName[5] == '_' && specialAttrRegexp.test(attrName)) {\n                continue;\n            }\n\n            if (attrValue !== false && attrValue != null) {\n                var type = typeof attrValue;\n\n                if (type != 'string') {\n                    // Special attributes aren't copied to the real DOM. They are only\n                    // kept in the virtual attributes map\n                    attrValue = convertAttrValue(type, attrValue);\n                }\n\n                namespaceURI = null;\n\n                if (attrName == ATTR_XLINK_HREF) {\n                    namespaceURI = NS_XLINK;\n                    attrName = ATTR_HREF;\n                }\n\n                el.setAttributeNS(namespaceURI, attrName, attrValue);\n            }\n        }\n\n        var flags = this.$__flags;\n\n        if (flags & FLAG_IS_TEXTAREA) {\n            el.value = this.$__value;\n        }\n\n        el._vattrs = attributes;\n        el._vflags = flags;\n\n        return el;\n    },\n\n    $__hasAttribute: function(name) {\n        // We don't care about the namespaces since the there\n        // is no chance that attributes with the same name will have\n        // different namespaces\n        var value = this.$__attributes[name];\n        return value != null && value !== false;\n    },\n\n    $__isSameNode: function(otherNode) {\n        if (otherNode.nodeType == 1) {\n            var constId = this.$__constId;\n            if (constId) {\n                var otherVirtualAttrs;\n\n                var otherConstId = otherNode.$__VNode ?\n                    otherNode.$__constId :\n                    (otherVirtualAttrs = otherNode._vattrs) && otherVirtualAttrs[ATTR_MARKO_CONST];\n                return constId === otherConstId;\n            }\n        }\n\n        return false;\n    }\n};\n\ninherit(VElement, VNode);\n\nvar proto = VElementClone.prototype = VElement.prototype;\n\n['checked', 'selected', 'disabled'].forEach(function(name) {\n    defineProperty(proto, name, {\n        get: function () {\n            var value = this.$__attributes[name];\n            return value !== false && value != null;\n        }\n    });\n});\n\ndefineProperty(proto, 'id', {\n    get: function () {\n        return this.$__attributes.id;\n    }\n});\n\ndefineProperty(proto, 'value', {\n    get: function () {\n        var value = this.$__value;\n        if (value == null) {\n            value = this.$__attributes.value;\n        }\n        return value != null ? toString(value) : '';\n    }\n});\n\ndefineProperty(proto, '$__isTextArea', {\n    get: function () {\n        return this.$__flags & FLAG_IS_TEXTAREA;\n    }\n});\n\nVElement.$__removePreservedAttributes = function(attrs) {\n    // By default this static method is a no-op, but if there are any\n    // compiled components that have \"no-update\" attributes then\n    // `preserve-attrs.js` will be imported and this method will be replaced\n    // with a method that actually does something\n    return attrs;\n};\n\nVElement.$__morphAttrs = function(fromEl, toEl) {\n\n    var removePreservedAttributes = VElement.$__removePreservedAttributes;\n\n    var attrs = toEl.$__attributes || toEl._vattrs;\n    var attrName;\n    var i;\n\n    // We use expando properties to associate the previous HTML\n    // attributes provided as part of the VDOM node with the\n    // real VElement DOM node. When diffing attributes,\n    // we only use our internal representation of the attributes.\n    // When diffing for the first time it's possible that the\n    // real VElement node will not have the expando property\n    // so we build the attribute map from the expando property\n\n    var oldAttrs = fromEl._vattrs;\n    if (oldAttrs) {\n        if (oldAttrs == attrs) {\n            // For constant attributes the same object will be provided\n            // every render and we can use that to our advantage to\n            // not waste time diffing a constant, immutable attribute\n            // map.\n            return;\n        } else {\n            oldAttrs = removePreservedAttributes(oldAttrs, true);\n        }\n    } else {\n        // We need to build the attribute map from the real attributes\n        oldAttrs = {};\n\n        var oldAttributesList = fromEl.attributes;\n        for (i = oldAttributesList.length - 1; i >= 0; --i) {\n            var attr = oldAttributesList[i];\n\n            if (attr.specified !== false) {\n                attrName = attr.name;\n                var attrNamespaceURI = attr.namespaceURI;\n                if (attrNamespaceURI === NS_XLINK) {\n                    oldAttrs[ATTR_XLINK_HREF] = attr.value;\n                } else {\n                    oldAttrs[attrName] = attr.value;\n                }\n            }\n        }\n\n        // We don't want preserved attributes to show up in either the old\n        // or new attribute map.\n        removePreservedAttributes(oldAttrs, false);\n    }\n\n    fromEl._vattrs = attrs;\n\n    var attrValue;\n\n    var flags = toEl.$__flags;\n    var oldFlags;\n\n    if (flags & FLAG_SIMPLE_ATTRS && ((oldFlags = fromEl._vflags) & FLAG_SIMPLE_ATTRS)) {\n        if (oldAttrs['class'] != (attrValue = attrs['class'])) {\n            fromEl.className = attrValue;\n        }\n        if (oldAttrs.id != (attrValue = attrs.id)) {\n            fromEl.id = attrValue;\n        }\n        if (oldAttrs.style != (attrValue = attrs.style)) {\n            fromEl.style.cssText = attrValue;\n        }\n        return;\n    }\n\n    // In some cases we only want to set an attribute value for the first\n    // render or we don't want certain attributes to be touched. To support\n    // that use case we delete out all of the preserved attributes\n    // so it's as if they never existed.\n    attrs = removePreservedAttributes(attrs, true);\n\n    var namespaceURI;\n\n    // Loop over all of the attributes in the attribute map and compare\n    // them to the value in the old map. However, if the value is\n    // null/undefined/false then we want to remove the attribute\n    for (attrName in attrs) {\n        attrValue = attrs[attrName];\n        namespaceURI = null;\n\n        if (attrName == ATTR_XLINK_HREF) {\n            namespaceURI = NS_XLINK;\n            attrName = ATTR_HREF;\n        }\n\n        if (attrValue == null || attrValue === false) {\n            fromEl.removeAttributeNS(namespaceURI, attrName);\n        } else if (oldAttrs[attrName] !== attrValue) {\n\n            if (attrName[5] == '_' && specialAttrRegexp.test(attrName)) {\n                // Special attributes aren't copied to the real DOM. They are only\n                // kept in the virtual attributes map\n                continue;\n            }\n\n            var type = typeof attrValue;\n\n            if (type != 'string') {\n                attrValue = convertAttrValue(type, attrValue);\n            }\n\n            fromEl.setAttributeNS(namespaceURI, attrName, attrValue);\n        }\n    }\n\n    // If there are any old attributes that are not in the new set of attributes\n    // then we need to remove those attributes from the target node\n    for (attrName in oldAttrs) {\n        if (!(attrName in attrs)) {\n\n            if (attrName == ATTR_XLINK_HREF) {\n                namespaceURI = ATTR_XLINK_HREF;\n                attrName = ATTR_HREF;\n            }\n\n            fromEl.removeAttributeNS(namespaceURI, attrName);\n        }\n    }\n};\n\nmodule.exports = VElement;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL3J1bnRpbWUvdmRvbS9WRWxlbWVudC5qcz9lMTU4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBWTm9kZSA9IHJlcXVpcmUoJy4vVk5vZGUnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgncmFwdG9yLXV0aWwvaW5oZXJpdCcpO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3JhcHRvci11dGlsL2V4dGVuZCcpO1xuXG52YXIgTlNfWExJTksgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG52YXIgQVRUUl9YTElOS19IUkVGID0gJ3hsaW5rOmhyZWYnO1xudmFyIHRvU3RyaW5nID0gU3RyaW5nO1xuXG52YXIgRkxBR19JU19TVkcgPSAxO1xudmFyIEZMQUdfSVNfVEVYVEFSRUEgPSAyO1xudmFyIEZMQUdfU0lNUExFX0FUVFJTID0gNDtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5cbnZhciBBVFRSX0hSRUYgPSAnaHJlZic7XG52YXIgRU1QVFlfT0JKRUNUID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG52YXIgQVRUUl9NQVJLT19DT05TVCA9ICdkYXRhLV9tYyc7XG5cbnZhciBzcGVjaWFsQXR0clJlZ2V4cCA9IC9eZGF0YS1fLztcblxuXG5mdW5jdGlvbiBjb252ZXJ0QXR0clZhbHVlKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gVkVsZW1lbnRDbG9uZShvdGhlcikge1xuICAgIGV4dGVuZCh0aGlzLCBvdGhlcik7XG4gICAgdGhpcy4kX19wYXJlbnROb2RlID0gbnVsbDtcbiAgICB0aGlzLiRfX25leHRTaWJsaW5nID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gVkVsZW1lbnQodGFnTmFtZSwgYXR0cnMsIGNoaWxkQ291bnQsIGZsYWdzLCBjb25zdElkKSB7XG4gICAgdGhpcy4kX19WTm9kZShjaGlsZENvdW50KTtcblxuICAgIGlmIChjb25zdElkKSB7XG4gICAgICAgIGlmICghYXR0cnMpIHtcbiAgICAgICAgICAgIGF0dHJzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgYXR0cnNbQVRUUl9NQVJLT19DT05TVF0gPSBjb25zdElkO1xuICAgIH1cblxuICAgIHZhciBuYW1lc3BhY2VVUkk7XG5cbiAgICBpZiAoKHRoaXMuJF9fZmxhZ3MgPSBmbGFncyB8fCAwKSkge1xuICAgICAgICBpZiAoZmxhZ3MgJiBGTEFHX0lTX1NWRykge1xuICAgICAgICAgICAgbmFtZXNwYWNlVVJJID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuJF9fYXR0cmlidXRlcyA9IGF0dHJzIHx8IEVNUFRZX09CSkVDVDtcbiAgICB0aGlzLiRfX25hbWVzcGFjZVVSSSA9IG5hbWVzcGFjZVVSSTtcbiAgICB0aGlzLm5vZGVOYW1lID0gdGFnTmFtZTtcbiAgICB0aGlzLiRfX3ZhbHVlID0gbnVsbDtcbiAgICB0aGlzLiRfX2NvbnN0SWQgPSBjb25zdElkO1xufVxuXG5WRWxlbWVudC5wcm90b3R5cGUgPSB7XG4gICAgJF9fVkVsZW1lbnQ6IHRydWUsXG5cbiAgICBub2RlVHlwZTogMSxcblxuICAgICRfX2Nsb25lTm9kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgVkVsZW1lbnRDbG9uZSh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvcnRoYW5kIG1ldGhvZCBmb3IgY3JlYXRpbmcgYW5kIGFwcGVuZGluZyBhbiBIVE1MIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdGFnTmFtZSAgICBUaGUgdGFnIG5hbWUgKGUuZy4gXCJkaXZcIilcbiAgICAgKiBAcGFyYW0gIHtpbnR8bnVsbH0gYXR0ckNvdW50ICBUaGUgbnVtYmVyIG9mIGF0dHJpYnV0ZXMgKG9yIGBudWxsYCBpZiBub3Qga25vd24pXG4gICAgICogQHBhcmFtICB7aW50fG51bGx9IGNoaWxkQ291bnQgVGhlIG51bWJlciBvZiBjaGlsZCBub2RlcyAob3IgYG51bGxgIGlmIG5vdCBrbm93bilcbiAgICAgKi9cbiAgICBlOiBmdW5jdGlvbih0YWdOYW1lLCBhdHRycywgY2hpbGRDb3VudCwgZmxhZ3MsIGNvbnN0SWQpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy4kX19hcHBlbmRDaGlsZChuZXcgVkVsZW1lbnQodGFnTmFtZSwgYXR0cnMsIGNoaWxkQ291bnQsIGZsYWdzLCBjb25zdElkKSk7XG5cbiAgICAgICAgaWYgKGNoaWxkQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRfX2ZpbmlzaENoaWxkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG5cblxuICAgIC8qKlxuICAgICAqIFNob3J0aGFuZCBtZXRob2QgZm9yIGNyZWF0aW5nIGFuZCBhcHBlbmRpbmcgYSBzdGF0aWMgbm9kZS4gVGhlIHByb3ZpZGVkIG5vZGUgaXMgYXV0b21hdGljYWxseSBjbG9uZWRcbiAgICAgKiB1c2luZyBhIHNoYWxsb3cgY2xvbmUgc2luY2UgaXQgd2lsbCBiZSBtdXRhdGVkIGFzIGEgcmVzdWx0IG9mIHNldHRpbmcgYG5leHRTaWJsaW5nYCBhbmQgYHBhcmVudE5vZGVgLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgZm9yIHRoZSBuZXcgQ29tbWVudCBub2RlXG4gICAgICovXG4gICAgbjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB0aGlzLiRfX2FwcGVuZENoaWxkKG5vZGUuJF9fY2xvbmVOb2RlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy4kX19maW5pc2hDaGlsZCgpO1xuICAgIH0sXG5cbiAgICAkX19hY3R1YWxpemU6IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICB2YXIgbmFtZXNwYWNlVVJJID0gdGhpcy4kX19uYW1lc3BhY2VVUkk7XG4gICAgICAgIHZhciB0YWdOYW1lID0gdGhpcy5ub2RlTmFtZTtcblxuICAgICAgICB2YXIgZWwgPSBuYW1lc3BhY2VVUkkgP1xuICAgICAgICAgICAgZG9jLmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHRhZ05hbWUpIDpcbiAgICAgICAgICAgIGRvYy5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuXG5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLiRfX2F0dHJpYnV0ZXM7XG4gICAgICAgIGZvciAodmFyIGF0dHJOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSBhdHRyaWJ1dGVzW2F0dHJOYW1lXTtcblxuICAgICAgICAgICAgaWYgKGF0dHJOYW1lWzVdID09ICdfJyAmJiBzcGVjaWFsQXR0clJlZ2V4cC50ZXN0KGF0dHJOYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXR0clZhbHVlICE9PSBmYWxzZSAmJiBhdHRyVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIGF0dHJWYWx1ZTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlICE9ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgYXR0cmlidXRlcyBhcmVuJ3QgY29waWVkIHRvIHRoZSByZWFsIERPTS4gVGhleSBhcmUgb25seVxuICAgICAgICAgICAgICAgICAgICAvLyBrZXB0IGluIHRoZSB2aXJ0dWFsIGF0dHJpYnV0ZXMgbWFwXG4gICAgICAgICAgICAgICAgICAgIGF0dHJWYWx1ZSA9IGNvbnZlcnRBdHRyVmFsdWUodHlwZSwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VVUkkgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYgKGF0dHJOYW1lID09IEFUVFJfWExJTktfSFJFRikge1xuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VVUkkgPSBOU19YTElOSztcbiAgICAgICAgICAgICAgICAgICAgYXR0ck5hbWUgPSBBVFRSX0hSRUY7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlVVJJLCBhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmbGFncyA9IHRoaXMuJF9fZmxhZ3M7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgRkxBR19JU19URVhUQVJFQSkge1xuICAgICAgICAgICAgZWwudmFsdWUgPSB0aGlzLiRfX3ZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwuX3ZhdHRycyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIGVsLl92ZmxhZ3MgPSBmbGFncztcblxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfSxcblxuICAgICRfX2hhc0F0dHJpYnV0ZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAvLyBXZSBkb24ndCBjYXJlIGFib3V0IHRoZSBuYW1lc3BhY2VzIHNpbmNlIHRoZSB0aGVyZVxuICAgICAgICAvLyBpcyBubyBjaGFuY2UgdGhhdCBhdHRyaWJ1dGVzIHdpdGggdGhlIHNhbWUgbmFtZSB3aWxsIGhhdmVcbiAgICAgICAgLy8gZGlmZmVyZW50IG5hbWVzcGFjZXNcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy4kX19hdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gZmFsc2U7XG4gICAgfSxcblxuICAgICRfX2lzU2FtZU5vZGU6IGZ1bmN0aW9uKG90aGVyTm9kZSkge1xuICAgICAgICBpZiAob3RoZXJOb2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIHZhciBjb25zdElkID0gdGhpcy4kX19jb25zdElkO1xuICAgICAgICAgICAgaWYgKGNvbnN0SWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJWaXJ0dWFsQXR0cnM7XG5cbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJDb25zdElkID0gb3RoZXJOb2RlLiRfX1ZOb2RlID9cbiAgICAgICAgICAgICAgICAgICAgb3RoZXJOb2RlLiRfX2NvbnN0SWQgOlxuICAgICAgICAgICAgICAgICAgICAob3RoZXJWaXJ0dWFsQXR0cnMgPSBvdGhlck5vZGUuX3ZhdHRycykgJiYgb3RoZXJWaXJ0dWFsQXR0cnNbQVRUUl9NQVJLT19DT05TVF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0SWQgPT09IG90aGVyQ29uc3RJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5pbmhlcml0KFZFbGVtZW50LCBWTm9kZSk7XG5cbnZhciBwcm90byA9IFZFbGVtZW50Q2xvbmUucHJvdG90eXBlID0gVkVsZW1lbnQucHJvdG90eXBlO1xuXG5bJ2NoZWNrZWQnLCAnc2VsZWN0ZWQnLCAnZGlzYWJsZWQnXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShwcm90bywgbmFtZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuJF9fYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gZmFsc2UgJiYgdmFsdWUgIT0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5cbmRlZmluZVByb3BlcnR5KHByb3RvLCAnaWQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRfX2F0dHJpYnV0ZXMuaWQ7XG4gICAgfVxufSk7XG5cbmRlZmluZVByb3BlcnR5KHByb3RvLCAndmFsdWUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuJF9fdmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuJF9fYXR0cmlidXRlcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IHRvU3RyaW5nKHZhbHVlKSA6ICcnO1xuICAgIH1cbn0pO1xuXG5kZWZpbmVQcm9wZXJ0eShwcm90bywgJyRfX2lzVGV4dEFyZWEnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRfX2ZsYWdzICYgRkxBR19JU19URVhUQVJFQTtcbiAgICB9XG59KTtcblxuVkVsZW1lbnQuJF9fcmVtb3ZlUHJlc2VydmVkQXR0cmlidXRlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgLy8gQnkgZGVmYXVsdCB0aGlzIHN0YXRpYyBtZXRob2QgaXMgYSBuby1vcCwgYnV0IGlmIHRoZXJlIGFyZSBhbnlcbiAgICAvLyBjb21waWxlZCBjb21wb25lbnRzIHRoYXQgaGF2ZSBcIm5vLXVwZGF0ZVwiIGF0dHJpYnV0ZXMgdGhlblxuICAgIC8vIGBwcmVzZXJ2ZS1hdHRycy5qc2Agd2lsbCBiZSBpbXBvcnRlZCBhbmQgdGhpcyBtZXRob2Qgd2lsbCBiZSByZXBsYWNlZFxuICAgIC8vIHdpdGggYSBtZXRob2QgdGhhdCBhY3R1YWxseSBkb2VzIHNvbWV0aGluZ1xuICAgIHJldHVybiBhdHRycztcbn07XG5cblZFbGVtZW50LiRfX21vcnBoQXR0cnMgPSBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcblxuICAgIHZhciByZW1vdmVQcmVzZXJ2ZWRBdHRyaWJ1dGVzID0gVkVsZW1lbnQuJF9fcmVtb3ZlUHJlc2VydmVkQXR0cmlidXRlcztcblxuICAgIHZhciBhdHRycyA9IHRvRWwuJF9fYXR0cmlidXRlcyB8fCB0b0VsLl92YXR0cnM7XG4gICAgdmFyIGF0dHJOYW1lO1xuICAgIHZhciBpO1xuXG4gICAgLy8gV2UgdXNlIGV4cGFuZG8gcHJvcGVydGllcyB0byBhc3NvY2lhdGUgdGhlIHByZXZpb3VzIEhUTUxcbiAgICAvLyBhdHRyaWJ1dGVzIHByb3ZpZGVkIGFzIHBhcnQgb2YgdGhlIFZET00gbm9kZSB3aXRoIHRoZVxuICAgIC8vIHJlYWwgVkVsZW1lbnQgRE9NIG5vZGUuIFdoZW4gZGlmZmluZyBhdHRyaWJ1dGVzLFxuICAgIC8vIHdlIG9ubHkgdXNlIG91ciBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgYXR0cmlidXRlcy5cbiAgICAvLyBXaGVuIGRpZmZpbmcgZm9yIHRoZSBmaXJzdCB0aW1lIGl0J3MgcG9zc2libGUgdGhhdCB0aGVcbiAgICAvLyByZWFsIFZFbGVtZW50IG5vZGUgd2lsbCBub3QgaGF2ZSB0aGUgZXhwYW5kbyBwcm9wZXJ0eVxuICAgIC8vIHNvIHdlIGJ1aWxkIHRoZSBhdHRyaWJ1dGUgbWFwIGZyb20gdGhlIGV4cGFuZG8gcHJvcGVydHlcblxuICAgIHZhciBvbGRBdHRycyA9IGZyb21FbC5fdmF0dHJzO1xuICAgIGlmIChvbGRBdHRycykge1xuICAgICAgICBpZiAob2xkQXR0cnMgPT0gYXR0cnMpIHtcbiAgICAgICAgICAgIC8vIEZvciBjb25zdGFudCBhdHRyaWJ1dGVzIHRoZSBzYW1lIG9iamVjdCB3aWxsIGJlIHByb3ZpZGVkXG4gICAgICAgICAgICAvLyBldmVyeSByZW5kZXIgYW5kIHdlIGNhbiB1c2UgdGhhdCB0byBvdXIgYWR2YW50YWdlIHRvXG4gICAgICAgICAgICAvLyBub3Qgd2FzdGUgdGltZSBkaWZmaW5nIGEgY29uc3RhbnQsIGltbXV0YWJsZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgIC8vIG1hcC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9sZEF0dHJzID0gcmVtb3ZlUHJlc2VydmVkQXR0cmlidXRlcyhvbGRBdHRycywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGJ1aWxkIHRoZSBhdHRyaWJ1dGUgbWFwIGZyb20gdGhlIHJlYWwgYXR0cmlidXRlc1xuICAgICAgICBvbGRBdHRycyA9IHt9O1xuXG4gICAgICAgIHZhciBvbGRBdHRyaWJ1dGVzTGlzdCA9IGZyb21FbC5hdHRyaWJ1dGVzO1xuICAgICAgICBmb3IgKGkgPSBvbGRBdHRyaWJ1dGVzTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgdmFyIGF0dHIgPSBvbGRBdHRyaWJ1dGVzTGlzdFtpXTtcblxuICAgICAgICAgICAgaWYgKGF0dHIuc3BlY2lmaWVkICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGF0dHJOYW1lID0gYXR0ci5uYW1lO1xuICAgICAgICAgICAgICAgIHZhciBhdHRyTmFtZXNwYWNlVVJJID0gYXR0ci5uYW1lc3BhY2VVUkk7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJOYW1lc3BhY2VVUkkgPT09IE5TX1hMSU5LKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZEF0dHJzW0FUVFJfWExJTktfSFJFRl0gPSBhdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZEF0dHJzW2F0dHJOYW1lXSA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCBwcmVzZXJ2ZWQgYXR0cmlidXRlcyB0byBzaG93IHVwIGluIGVpdGhlciB0aGUgb2xkXG4gICAgICAgIC8vIG9yIG5ldyBhdHRyaWJ1dGUgbWFwLlxuICAgICAgICByZW1vdmVQcmVzZXJ2ZWRBdHRyaWJ1dGVzKG9sZEF0dHJzLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZnJvbUVsLl92YXR0cnMgPSBhdHRycztcblxuICAgIHZhciBhdHRyVmFsdWU7XG5cbiAgICB2YXIgZmxhZ3MgPSB0b0VsLiRfX2ZsYWdzO1xuICAgIHZhciBvbGRGbGFncztcblxuICAgIGlmIChmbGFncyAmIEZMQUdfU0lNUExFX0FUVFJTICYmICgob2xkRmxhZ3MgPSBmcm9tRWwuX3ZmbGFncykgJiBGTEFHX1NJTVBMRV9BVFRSUykpIHtcbiAgICAgICAgaWYgKG9sZEF0dHJzWydjbGFzcyddICE9IChhdHRyVmFsdWUgPSBhdHRyc1snY2xhc3MnXSkpIHtcbiAgICAgICAgICAgIGZyb21FbC5jbGFzc05hbWUgPSBhdHRyVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZEF0dHJzLmlkICE9IChhdHRyVmFsdWUgPSBhdHRycy5pZCkpIHtcbiAgICAgICAgICAgIGZyb21FbC5pZCA9IGF0dHJWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkQXR0cnMuc3R5bGUgIT0gKGF0dHJWYWx1ZSA9IGF0dHJzLnN0eWxlKSkge1xuICAgICAgICAgICAgZnJvbUVsLnN0eWxlLmNzc1RleHQgPSBhdHRyVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEluIHNvbWUgY2FzZXMgd2Ugb25seSB3YW50IHRvIHNldCBhbiBhdHRyaWJ1dGUgdmFsdWUgZm9yIHRoZSBmaXJzdFxuICAgIC8vIHJlbmRlciBvciB3ZSBkb24ndCB3YW50IGNlcnRhaW4gYXR0cmlidXRlcyB0byBiZSB0b3VjaGVkLiBUbyBzdXBwb3J0XG4gICAgLy8gdGhhdCB1c2UgY2FzZSB3ZSBkZWxldGUgb3V0IGFsbCBvZiB0aGUgcHJlc2VydmVkIGF0dHJpYnV0ZXNcbiAgICAvLyBzbyBpdCdzIGFzIGlmIHRoZXkgbmV2ZXIgZXhpc3RlZC5cbiAgICBhdHRycyA9IHJlbW92ZVByZXNlcnZlZEF0dHJpYnV0ZXMoYXR0cnMsIHRydWUpO1xuXG4gICAgdmFyIG5hbWVzcGFjZVVSSTtcblxuICAgIC8vIExvb3Agb3ZlciBhbGwgb2YgdGhlIGF0dHJpYnV0ZXMgaW4gdGhlIGF0dHJpYnV0ZSBtYXAgYW5kIGNvbXBhcmVcbiAgICAvLyB0aGVtIHRvIHRoZSB2YWx1ZSBpbiB0aGUgb2xkIG1hcC4gSG93ZXZlciwgaWYgdGhlIHZhbHVlIGlzXG4gICAgLy8gbnVsbC91bmRlZmluZWQvZmFsc2UgdGhlbiB3ZSB3YW50IHRvIHJlbW92ZSB0aGUgYXR0cmlidXRlXG4gICAgZm9yIChhdHRyTmFtZSBpbiBhdHRycykge1xuICAgICAgICBhdHRyVmFsdWUgPSBhdHRyc1thdHRyTmFtZV07XG4gICAgICAgIG5hbWVzcGFjZVVSSSA9IG51bGw7XG5cbiAgICAgICAgaWYgKGF0dHJOYW1lID09IEFUVFJfWExJTktfSFJFRikge1xuICAgICAgICAgICAgbmFtZXNwYWNlVVJJID0gTlNfWExJTks7XG4gICAgICAgICAgICBhdHRyTmFtZSA9IEFUVFJfSFJFRjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdHRyVmFsdWUgPT0gbnVsbCB8fCBhdHRyVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBmcm9tRWwucmVtb3ZlQXR0cmlidXRlTlMobmFtZXNwYWNlVVJJLCBhdHRyTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAob2xkQXR0cnNbYXR0ck5hbWVdICE9PSBhdHRyVmFsdWUpIHtcblxuICAgICAgICAgICAgaWYgKGF0dHJOYW1lWzVdID09ICdfJyAmJiBzcGVjaWFsQXR0clJlZ2V4cC50ZXN0KGF0dHJOYW1lKSkge1xuICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgYXR0cmlidXRlcyBhcmVuJ3QgY29waWVkIHRvIHRoZSByZWFsIERPTS4gVGhleSBhcmUgb25seVxuICAgICAgICAgICAgICAgIC8vIGtlcHQgaW4gdGhlIHZpcnR1YWwgYXR0cmlidXRlcyBtYXBcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgYXR0clZhbHVlO1xuXG4gICAgICAgICAgICBpZiAodHlwZSAhPSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGF0dHJWYWx1ZSA9IGNvbnZlcnRBdHRyVmFsdWUodHlwZSwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJvbUVsLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZVVSSSwgYXR0ck5hbWUsIGF0dHJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgYW55IG9sZCBhdHRyaWJ1dGVzIHRoYXQgYXJlIG5vdCBpbiB0aGUgbmV3IHNldCBvZiBhdHRyaWJ1dGVzXG4gICAgLy8gdGhlbiB3ZSBuZWVkIHRvIHJlbW92ZSB0aG9zZSBhdHRyaWJ1dGVzIGZyb20gdGhlIHRhcmdldCBub2RlXG4gICAgZm9yIChhdHRyTmFtZSBpbiBvbGRBdHRycykge1xuICAgICAgICBpZiAoIShhdHRyTmFtZSBpbiBhdHRycykpIHtcblxuICAgICAgICAgICAgaWYgKGF0dHJOYW1lID09IEFUVFJfWExJTktfSFJFRikge1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZVVSSSA9IEFUVFJfWExJTktfSFJFRjtcbiAgICAgICAgICAgICAgICBhdHRyTmFtZSA9IEFUVFJfSFJFRjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJvbUVsLnJlbW92ZUF0dHJpYnV0ZU5TKG5hbWVzcGFjZVVSSSwgYXR0ck5hbWUpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWRWxlbWVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYXJrby9ydW50aW1lL3Zkb20vVkVsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 18 */
/***/ (function(module, exports) {

eval("module.exports = function copyProps(from, to) {\n    Object.getOwnPropertyNames(from).forEach(function(name) {\n        var descriptor = Object.getOwnPropertyDescriptor(from, name);\n        Object.defineProperty(to, name, descriptor);\n    });\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3JhcHRvci11dGlsL2NvcHlQcm9wcy5qcz8zMjI1Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29weVByb3BzKGZyb20sIHRvKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZnJvbSkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihmcm9tLCBuYW1lKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBuYW1lLCBkZXNjcmlwdG9yKTtcbiAgICB9KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JhcHRvci11dGlsL2NvcHlQcm9wcy5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(20)(undefined);\n// imports\n\n\n// module\nexports.push([module.i, \".count {\\n        color:#09c;\\n        font-size:3em;\\n    }\\n    .example-button {\\n        font-size:1em;\\n        padding:0.5em;\\n    }\", \"\"]);\n\n// exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wdWJsaWMvY291bnRlci5tYXJrbz83ODZiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5jb3VudCB7XFxuICAgICAgICBjb2xvcjojMDljO1xcbiAgICAgICAgZm9udC1zaXplOjNlbTtcXG4gICAgfVxcbiAgICAuZXhhbXBsZS1idXR0b24ge1xcbiAgICAgICAgZm9udC1zaXplOjFlbTtcXG4gICAgICAgIHBhZGRpbmc6MC41ZW07XFxuICAgIH1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vbWFya28tbG9hZGVyL3NyYy9jb2RlLWxvYWRlci5qcz97XCJjb2RlXCI6XCIuY291bnQgey9uICAgICAgICBjb2xvcjojMDljOy9uICAgICAgICBmb250LXNpemU6M2VtOy9uICAgIH0vbiAgICAuZXhhbXBsZS1idXR0b24gey9uICAgICAgICBmb250LXNpemU6MWVtOy9uICAgICAgICBwYWRkaW5nOjAuNWVtOy9uICAgIH1cIn0hLi9wdWJsaWMvY291bnRlci5tYXJrb1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap) {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n  var base64 = new Buffer(JSON.stringify(sourceMap)).toString('base64');\n  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n  return '/*# ' + data + ' */';\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(48).Buffer))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzP2RhMDQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXApIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIHZhciBiYXNlNjQgPSBuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgdmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuICByZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 21 */
/***/ (function(module, exports) {

eval("var INDEX_EVENT = 0;\nvar INDEX_USER_LISTENER = 1;\nvar INDEX_WRAPPED_LISTENER = 2;\nvar DESTROY = \"destroy\";\n\nfunction isNonEventEmitter(target) {\n  return !target.once;\n}\n\nfunction EventEmitterWrapper(target) {\n    this.$__target = target;\n    this.$__listeners = [];\n    this.$__subscribeTo = null;\n}\n\nEventEmitterWrapper.prototype = {\n    $__remove: function(test, testWrapped) {\n        var target = this.$__target;\n        var listeners = this.$__listeners;\n\n        this.$__listeners = listeners.filter(function(curListener) {\n            var curEvent = curListener[INDEX_EVENT];\n            var curListenerFunc = curListener[INDEX_USER_LISTENER];\n            var curWrappedListenerFunc = curListener[INDEX_WRAPPED_LISTENER];\n\n            if (testWrapped) {\n                // If the user used `once` to attach an event listener then we had to\n                // wrap their listener function with a new function that does some extra\n                // cleanup to avoid a memory leak. If the `testWrapped` flag is set to true\n                // then we are attempting to remove based on a function that we had to\n                // wrap (not the user listener function)\n                if (curWrappedListenerFunc && test(curEvent, curWrappedListenerFunc)) {\n                    target.removeListener(curEvent, curWrappedListenerFunc);\n\n                    return false;\n                }\n            } else if (test(curEvent, curListenerFunc)) {\n                // If the listener function was wrapped due to it being a `once` listener\n                // then we should remove from the target EventEmitter using wrapped\n                // listener function. Otherwise, we remove the listener using the user-provided\n                // listener function.\n                target.removeListener(curEvent, curWrappedListenerFunc || curListenerFunc);\n\n                return false;\n            }\n\n            return true;\n        });\n\n        // Fixes https://github.com/raptorjs/listener-tracker/issues/2\n        // If all of the listeners stored with a wrapped EventEmitter\n        // have been removed then we should unregister the wrapped\n        // EventEmitter in the parent SubscriptionTracker\n        var subscribeTo = this.$__subscribeTo;\n\n        if (!this.$__listeners.length && subscribeTo) {\n            var self = this;\n            var subscribeToList = subscribeTo.$__subscribeToList;\n            subscribeTo.$__subscribeToList = subscribeToList.filter(function(cur) {\n                return cur !== self;\n            });\n        }\n    },\n\n    on: function(event, listener) {\n        this.$__target.on(event, listener);\n        this.$__listeners.push([event, listener]);\n        return this;\n    },\n\n    once: function(event, listener) {\n        var self = this;\n\n        // Handling a `once` event listener is a little tricky since we need to also\n        // do our own cleanup if the `once` event is emitted. Therefore, we need\n        // to wrap the user's listener function with our own listener function.\n        var wrappedListener = function() {\n            self.$__remove(function(event, listenerFunc) {\n                return wrappedListener === listenerFunc;\n            }, true /* We are removing the wrapped listener */);\n\n            listener.apply(this, arguments);\n        };\n\n        this.$__target.once(event, wrappedListener);\n        this.$__listeners.push([event, listener, wrappedListener]);\n        return this;\n    },\n\n    removeListener: function(event, listener) {\n        if (typeof event === 'function') {\n            listener = event;\n            event = null;\n        }\n\n        if (listener && event) {\n            this.$__remove(function(curEvent, curListener) {\n                return event === curEvent && listener === curListener;\n            });\n        } else if (listener) {\n            this.$__remove(function(curEvent, curListener) {\n                return listener === curListener;\n            });\n        } else if (event) {\n            this.removeAllListeners(event);\n        }\n\n        return this;\n    },\n\n    removeAllListeners: function(event) {\n\n        var listeners = this.$__listeners;\n        var target = this.$__target;\n\n        if (event) {\n            this.$__remove(function(curEvent, curListener) {\n                return event === curEvent;\n            });\n        } else {\n            for (var i = listeners.length - 1; i >= 0; i--) {\n                var cur = listeners[i];\n                target.removeListener(cur[INDEX_EVENT], cur[INDEX_USER_LISTENER]);\n            }\n            this.$__listeners.length = 0;\n        }\n\n        return this;\n    }\n};\n\nfunction EventEmitterAdapter(target) {\n    this.$__target = target;\n}\n\nEventEmitterAdapter.prototype = {\n    on: function(event, listener) {\n        this.$__target.addEventListener(event, listener);\n        return this;\n    },\n\n    once: function(event, listener) {\n        var self = this;\n\n        // need to save this so we can remove it below\n        var onceListener = function() {\n          self.$__target.removeEventListener(event, onceListener);\n          listener();\n        };\n        this.$__target.addEventListener(event, onceListener);\n        return this;\n    },\n\n    removeListener: function(event, listener) {\n        this.$__target.removeEventListener(event, listener);\n        return this;\n    }\n};\n\nfunction SubscriptionTracker() {\n    this.$__subscribeToList = [];\n}\n\nSubscriptionTracker.prototype = {\n\n    subscribeTo: function(target, options) {\n        var addDestroyListener = !options || options.addDestroyListener !== false;\n        var wrapper;\n        var nonEE;\n        var subscribeToList = this.$__subscribeToList;\n\n        for (var i=0, len=subscribeToList.length; i<len; i++) {\n            var cur = subscribeToList[i];\n            if (cur.$__target === target) {\n                wrapper = cur;\n                break;\n            }\n        }\n\n        if (!wrapper) {\n            if (isNonEventEmitter(target)) {\n              nonEE = new EventEmitterAdapter(target);\n            }\n\n            wrapper = new EventEmitterWrapper(nonEE || target);\n            if (addDestroyListener && !nonEE) {\n                wrapper.once(DESTROY, function() {\n                    wrapper.removeAllListeners();\n\n                    for (var i = subscribeToList.length - 1; i >= 0; i--) {\n                        if (subscribeToList[i].$__target === target) {\n                            subscribeToList.splice(i, 1);\n                            break;\n                        }\n                    }\n                });\n            }\n\n            // Store a reference to the parent SubscriptionTracker so that we can do cleanup\n            // if the EventEmitterWrapper instance becomes empty (i.e., no active listeners)\n            wrapper.$__subscribeTo = this;\n            subscribeToList.push(wrapper);\n        }\n\n        return wrapper;\n    },\n\n    removeAllListeners: function(target, event) {\n        var subscribeToList = this.$__subscribeToList;\n        var i;\n\n        if (target) {\n            for (i = subscribeToList.length - 1; i >= 0; i--) {\n                var cur = subscribeToList[i];\n                if (cur.$__target === target) {\n                    cur.removeAllListeners(event);\n\n                    if (!cur.$__listeners.length) {\n                        // Do some cleanup if we removed all\n                        // listeners for the target event emitter\n                        subscribeToList.splice(i, 1);\n                    }\n\n                    break;\n                }\n            }\n        } else {\n            for (i = subscribeToList.length - 1; i >= 0; i--) {\n                subscribeToList[i].removeAllListeners();\n            }\n            subscribeToList.length = 0;\n        }\n    }\n};\n\nexports = module.exports = SubscriptionTracker;\n\nexports.wrap = function(targetEventEmitter) {\n    var nonEE;\n    var wrapper;\n\n    if (isNonEventEmitter(targetEventEmitter)) {\n      nonEE = new EventEmitterAdapter(targetEventEmitter);\n    }\n\n    wrapper = new EventEmitterWrapper(nonEE || targetEventEmitter);\n    if (!nonEE) {\n      // we don't set this for non EE types\n      targetEventEmitter.once(DESTROY, function() {\n          wrapper.$__listeners.length = 0;\n      });\n    }\n\n    return wrapper;\n};\n\nexports.createTracker = function() {\n    return new SubscriptionTracker();\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2xpc3RlbmVyLXRyYWNrZXIvbGliL2xpc3RlbmVyLXRyYWNrZXIuanM/MjlmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSU5ERVhfRVZFTlQgPSAwO1xudmFyIElOREVYX1VTRVJfTElTVEVORVIgPSAxO1xudmFyIElOREVYX1dSQVBQRURfTElTVEVORVIgPSAyO1xudmFyIERFU1RST1kgPSBcImRlc3Ryb3lcIjtcblxuZnVuY3Rpb24gaXNOb25FdmVudEVtaXR0ZXIodGFyZ2V0KSB7XG4gIHJldHVybiAhdGFyZ2V0Lm9uY2U7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcldyYXBwZXIodGFyZ2V0KSB7XG4gICAgdGhpcy4kX190YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy4kX19saXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLiRfX3N1YnNjcmliZVRvID0gbnVsbDtcbn1cblxuRXZlbnRFbWl0dGVyV3JhcHBlci5wcm90b3R5cGUgPSB7XG4gICAgJF9fcmVtb3ZlOiBmdW5jdGlvbih0ZXN0LCB0ZXN0V3JhcHBlZCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy4kX190YXJnZXQ7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLiRfX2xpc3RlbmVycztcblxuICAgICAgICB0aGlzLiRfX2xpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24oY3VyTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHZhciBjdXJFdmVudCA9IGN1ckxpc3RlbmVyW0lOREVYX0VWRU5UXTtcbiAgICAgICAgICAgIHZhciBjdXJMaXN0ZW5lckZ1bmMgPSBjdXJMaXN0ZW5lcltJTkRFWF9VU0VSX0xJU1RFTkVSXTtcbiAgICAgICAgICAgIHZhciBjdXJXcmFwcGVkTGlzdGVuZXJGdW5jID0gY3VyTGlzdGVuZXJbSU5ERVhfV1JBUFBFRF9MSVNURU5FUl07XG5cbiAgICAgICAgICAgIGlmICh0ZXN0V3JhcHBlZCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIHVzZWQgYG9uY2VgIHRvIGF0dGFjaCBhbiBldmVudCBsaXN0ZW5lciB0aGVuIHdlIGhhZCB0b1xuICAgICAgICAgICAgICAgIC8vIHdyYXAgdGhlaXIgbGlzdGVuZXIgZnVuY3Rpb24gd2l0aCBhIG5ldyBmdW5jdGlvbiB0aGF0IGRvZXMgc29tZSBleHRyYVxuICAgICAgICAgICAgICAgIC8vIGNsZWFudXAgdG8gYXZvaWQgYSBtZW1vcnkgbGVhay4gSWYgdGhlIGB0ZXN0V3JhcHBlZGAgZmxhZyBpcyBzZXQgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgIC8vIHRoZW4gd2UgYXJlIGF0dGVtcHRpbmcgdG8gcmVtb3ZlIGJhc2VkIG9uIGEgZnVuY3Rpb24gdGhhdCB3ZSBoYWQgdG9cbiAgICAgICAgICAgICAgICAvLyB3cmFwIChub3QgdGhlIHVzZXIgbGlzdGVuZXIgZnVuY3Rpb24pXG4gICAgICAgICAgICAgICAgaWYgKGN1cldyYXBwZWRMaXN0ZW5lckZ1bmMgJiYgdGVzdChjdXJFdmVudCwgY3VyV3JhcHBlZExpc3RlbmVyRnVuYykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUxpc3RlbmVyKGN1ckV2ZW50LCBjdXJXcmFwcGVkTGlzdGVuZXJGdW5jKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0ZXN0KGN1ckV2ZW50LCBjdXJMaXN0ZW5lckZ1bmMpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHdhcyB3cmFwcGVkIGR1ZSB0byBpdCBiZWluZyBhIGBvbmNlYCBsaXN0ZW5lclxuICAgICAgICAgICAgICAgIC8vIHRoZW4gd2Ugc2hvdWxkIHJlbW92ZSBmcm9tIHRoZSB0YXJnZXQgRXZlbnRFbWl0dGVyIHVzaW5nIHdyYXBwZWRcbiAgICAgICAgICAgICAgICAvLyBsaXN0ZW5lciBmdW5jdGlvbi4gT3RoZXJ3aXNlLCB3ZSByZW1vdmUgdGhlIGxpc3RlbmVyIHVzaW5nIHRoZSB1c2VyLXByb3ZpZGVkXG4gICAgICAgICAgICAgICAgLy8gbGlzdGVuZXIgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUxpc3RlbmVyKGN1ckV2ZW50LCBjdXJXcmFwcGVkTGlzdGVuZXJGdW5jIHx8IGN1ckxpc3RlbmVyRnVuYyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vcmFwdG9yanMvbGlzdGVuZXItdHJhY2tlci9pc3N1ZXMvMlxuICAgICAgICAvLyBJZiBhbGwgb2YgdGhlIGxpc3RlbmVycyBzdG9yZWQgd2l0aCBhIHdyYXBwZWQgRXZlbnRFbWl0dGVyXG4gICAgICAgIC8vIGhhdmUgYmVlbiByZW1vdmVkIHRoZW4gd2Ugc2hvdWxkIHVucmVnaXN0ZXIgdGhlIHdyYXBwZWRcbiAgICAgICAgLy8gRXZlbnRFbWl0dGVyIGluIHRoZSBwYXJlbnQgU3Vic2NyaXB0aW9uVHJhY2tlclxuICAgICAgICB2YXIgc3Vic2NyaWJlVG8gPSB0aGlzLiRfX3N1YnNjcmliZVRvO1xuXG4gICAgICAgIGlmICghdGhpcy4kX19saXN0ZW5lcnMubGVuZ3RoICYmIHN1YnNjcmliZVRvKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaWJlVG9MaXN0ID0gc3Vic2NyaWJlVG8uJF9fc3Vic2NyaWJlVG9MaXN0O1xuICAgICAgICAgICAgc3Vic2NyaWJlVG8uJF9fc3Vic2NyaWJlVG9MaXN0ID0gc3Vic2NyaWJlVG9MaXN0LmZpbHRlcihmdW5jdGlvbihjdXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyICE9PSBzZWxmO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb246IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLiRfX3RhcmdldC5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICB0aGlzLiRfX2xpc3RlbmVycy5wdXNoKFtldmVudCwgbGlzdGVuZXJdKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIG9uY2U6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgLy8gSGFuZGxpbmcgYSBgb25jZWAgZXZlbnQgbGlzdGVuZXIgaXMgYSBsaXR0bGUgdHJpY2t5IHNpbmNlIHdlIG5lZWQgdG8gYWxzb1xuICAgICAgICAvLyBkbyBvdXIgb3duIGNsZWFudXAgaWYgdGhlIGBvbmNlYCBldmVudCBpcyBlbWl0dGVkLiBUaGVyZWZvcmUsIHdlIG5lZWRcbiAgICAgICAgLy8gdG8gd3JhcCB0aGUgdXNlcidzIGxpc3RlbmVyIGZ1bmN0aW9uIHdpdGggb3VyIG93biBsaXN0ZW5lciBmdW5jdGlvbi5cbiAgICAgICAgdmFyIHdyYXBwZWRMaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi4kX19yZW1vdmUoZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyRnVuYykge1xuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkTGlzdGVuZXIgPT09IGxpc3RlbmVyRnVuYztcbiAgICAgICAgICAgIH0sIHRydWUgLyogV2UgYXJlIHJlbW92aW5nIHRoZSB3cmFwcGVkIGxpc3RlbmVyICovKTtcblxuICAgICAgICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLiRfX3RhcmdldC5vbmNlKGV2ZW50LCB3cmFwcGVkTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLiRfX2xpc3RlbmVycy5wdXNoKFtldmVudCwgbGlzdGVuZXIsIHdyYXBwZWRMaXN0ZW5lcl0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAodHlwZW9mIGV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBsaXN0ZW5lciA9IGV2ZW50O1xuICAgICAgICAgICAgZXZlbnQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3RlbmVyICYmIGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLiRfX3JlbW92ZShmdW5jdGlvbihjdXJFdmVudCwgY3VyTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQgPT09IGN1ckV2ZW50ICYmIGxpc3RlbmVyID09PSBjdXJMaXN0ZW5lcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLiRfX3JlbW92ZShmdW5jdGlvbihjdXJFdmVudCwgY3VyTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIgPT09IGN1ckxpc3RlbmVyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuJF9fbGlzdGVuZXJzO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy4kX190YXJnZXQ7XG5cbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLiRfX3JlbW92ZShmdW5jdGlvbihjdXJFdmVudCwgY3VyTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQgPT09IGN1ckV2ZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1ciA9IGxpc3RlbmVyc1tpXTtcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlTGlzdGVuZXIoY3VyW0lOREVYX0VWRU5UXSwgY3VyW0lOREVYX1VTRVJfTElTVEVORVJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJF9fbGlzdGVuZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXJBZGFwdGVyKHRhcmdldCkge1xuICAgIHRoaXMuJF9fdGFyZ2V0ID0gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXJBZGFwdGVyLnByb3RvdHlwZSA9IHtcbiAgICBvbjogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuJF9fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIG9uY2U6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgLy8gbmVlZCB0byBzYXZlIHRoaXMgc28gd2UgY2FuIHJlbW92ZSBpdCBiZWxvd1xuICAgICAgICB2YXIgb25jZUxpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi4kX190YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25jZUxpc3RlbmVyKTtcbiAgICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLiRfX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbmNlTGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLiRfX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIFN1YnNjcmlwdGlvblRyYWNrZXIoKSB7XG4gICAgdGhpcy4kX19zdWJzY3JpYmVUb0xpc3QgPSBbXTtcbn1cblxuU3Vic2NyaXB0aW9uVHJhY2tlci5wcm90b3R5cGUgPSB7XG5cbiAgICBzdWJzY3JpYmVUbzogZnVuY3Rpb24odGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBhZGREZXN0cm95TGlzdGVuZXIgPSAhb3B0aW9ucyB8fCBvcHRpb25zLmFkZERlc3Ryb3lMaXN0ZW5lciAhPT0gZmFsc2U7XG4gICAgICAgIHZhciB3cmFwcGVyO1xuICAgICAgICB2YXIgbm9uRUU7XG4gICAgICAgIHZhciBzdWJzY3JpYmVUb0xpc3QgPSB0aGlzLiRfX3N1YnNjcmliZVRvTGlzdDtcblxuICAgICAgICBmb3IgKHZhciBpPTAsIGxlbj1zdWJzY3JpYmVUb0xpc3QubGVuZ3RoOyBpPGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY3VyID0gc3Vic2NyaWJlVG9MaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGN1ci4kX190YXJnZXQgPT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHdyYXBwZXIgPSBjdXI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXdyYXBwZXIpIHtcbiAgICAgICAgICAgIGlmIChpc05vbkV2ZW50RW1pdHRlcih0YXJnZXQpKSB7XG4gICAgICAgICAgICAgIG5vbkVFID0gbmV3IEV2ZW50RW1pdHRlckFkYXB0ZXIodGFyZ2V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd3JhcHBlciA9IG5ldyBFdmVudEVtaXR0ZXJXcmFwcGVyKG5vbkVFIHx8IHRhcmdldCk7XG4gICAgICAgICAgICBpZiAoYWRkRGVzdHJveUxpc3RlbmVyICYmICFub25FRSkge1xuICAgICAgICAgICAgICAgIHdyYXBwZXIub25jZShERVNUUk9ZLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc3Vic2NyaWJlVG9MaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlVG9MaXN0W2ldLiRfX3RhcmdldCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlVG9MaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IFN1YnNjcmlwdGlvblRyYWNrZXIgc28gdGhhdCB3ZSBjYW4gZG8gY2xlYW51cFxuICAgICAgICAgICAgLy8gaWYgdGhlIEV2ZW50RW1pdHRlcldyYXBwZXIgaW5zdGFuY2UgYmVjb21lcyBlbXB0eSAoaS5lLiwgbm8gYWN0aXZlIGxpc3RlbmVycylcbiAgICAgICAgICAgIHdyYXBwZXIuJF9fc3Vic2NyaWJlVG8gPSB0aGlzO1xuICAgICAgICAgICAgc3Vic2NyaWJlVG9MaXN0LnB1c2god3JhcHBlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9LFxuXG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbih0YXJnZXQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBzdWJzY3JpYmVUb0xpc3QgPSB0aGlzLiRfX3N1YnNjcmliZVRvTGlzdDtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgZm9yIChpID0gc3Vic2NyaWJlVG9MaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1ciA9IHN1YnNjcmliZVRvTGlzdFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLiRfX3RhcmdldCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ci5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VyLiRfX2xpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIHNvbWUgY2xlYW51cCBpZiB3ZSByZW1vdmVkIGFsbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGlzdGVuZXJzIGZvciB0aGUgdGFyZ2V0IGV2ZW50IGVtaXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZVRvTGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgPSBzdWJzY3JpYmVUb0xpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVUb0xpc3RbaV0ucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJzY3JpYmVUb0xpc3QubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFN1YnNjcmlwdGlvblRyYWNrZXI7XG5cbmV4cG9ydHMud3JhcCA9IGZ1bmN0aW9uKHRhcmdldEV2ZW50RW1pdHRlcikge1xuICAgIHZhciBub25FRTtcbiAgICB2YXIgd3JhcHBlcjtcblxuICAgIGlmIChpc05vbkV2ZW50RW1pdHRlcih0YXJnZXRFdmVudEVtaXR0ZXIpKSB7XG4gICAgICBub25FRSA9IG5ldyBFdmVudEVtaXR0ZXJBZGFwdGVyKHRhcmdldEV2ZW50RW1pdHRlcik7XG4gICAgfVxuXG4gICAgd3JhcHBlciA9IG5ldyBFdmVudEVtaXR0ZXJXcmFwcGVyKG5vbkVFIHx8IHRhcmdldEV2ZW50RW1pdHRlcik7XG4gICAgaWYgKCFub25FRSkge1xuICAgICAgLy8gd2UgZG9uJ3Qgc2V0IHRoaXMgZm9yIG5vbiBFRSB0eXBlc1xuICAgICAgdGFyZ2V0RXZlbnRFbWl0dGVyLm9uY2UoREVTVFJPWSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgd3JhcHBlci4kX19saXN0ZW5lcnMubGVuZ3RoID0gMDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB3cmFwcGVyO1xufTtcblxuZXhwb3J0cy5jcmVhdGVUcmFja2VyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25UcmFja2VyKCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xpc3RlbmVyLXRyYWNrZXIvbGliL2xpc3RlbmVyLXRyYWNrZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar ComponentDef = __webpack_require__(10);\nvar initComponents = __webpack_require__(13);\nvar EMPTY_OBJECT = {};\n\nfunction ComponentsContext(out, root) {\n    if (!root) {\n        root = new ComponentDef(null, null, out);\n    }\n\n    this.$__out = out;\n    this.$__componentStack = [root];\n    this.$__preserved = EMPTY_OBJECT;\n    this.$__componentsById = {};\n}\n\nComponentsContext.prototype = {\n    get $__components() {\n        return this.$__componentStack[0].$__children;\n    },\n\n    $__beginComponent: function(component) {\n        var self = this;\n        var componentStack = self.$__componentStack;\n        var origLength = componentStack.length;\n        var parent = componentStack[origLength - 1];\n\n        var componentId = component.id;\n\n        if (!componentId) {\n            componentId = component.id = parent.$__nextId();\n        }\n\n        var componentDef = new ComponentDef(component, componentId, this.$__out, componentStack, origLength);\n        this.$__componentsById[componentId] = componentDef;\n        parent.$__addChild(componentDef);\n        componentStack.push(componentDef);\n\n        return componentDef;\n    },\n    $__clearComponents: function () {\n        this.$__componentStack = [new ComponentDef(null /* id */, this.$__out)];\n    },\n    $__initComponents: function (doc) {\n        var componentDefs = this.$__components;\n        if (componentDefs) {\n            initComponents.$__initClientRendered(componentDefs, doc);\n            this.$__clearComponents();\n        }\n    },\n    $__nextComponentId: function() {\n        var componentStack = this.$__componentStack;\n        var parent = componentStack[componentStack.length - 1];\n        return parent.$__nextId();\n    },\n    $__preserveDOMNode: function(elId, bodyOnly) {\n        var preserved = this.$__preserved;\n        if (preserved == EMPTY_OBJECT) {\n            preserved = this.$__preserved = {};\n        }\n        preserved[elId] = { $__bodyOnly: bodyOnly };\n    }\n};\n\nComponentsContext.$__getComponentsContext = function (out) {\n    var global = out.global;\n\n    return out.data.components ||\n        global.components ||\n        (global.components = new ComponentsContext(out));\n};\n\nmodule.exports = ComponentsContext;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL2NvbXBvbmVudHMvQ29tcG9uZW50c0NvbnRleHQuanM/NmIyZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBDb21wb25lbnREZWYgPSByZXF1aXJlKCcuL0NvbXBvbmVudERlZicpO1xudmFyIGluaXRDb21wb25lbnRzID0gcmVxdWlyZSgnLi9pbml0LWNvbXBvbmVudHMnKTtcbnZhciBFTVBUWV9PQkpFQ1QgPSB7fTtcblxuZnVuY3Rpb24gQ29tcG9uZW50c0NvbnRleHQob3V0LCByb290KSB7XG4gICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJvb3QgPSBuZXcgQ29tcG9uZW50RGVmKG51bGwsIG51bGwsIG91dCk7XG4gICAgfVxuXG4gICAgdGhpcy4kX19vdXQgPSBvdXQ7XG4gICAgdGhpcy4kX19jb21wb25lbnRTdGFjayA9IFtyb290XTtcbiAgICB0aGlzLiRfX3ByZXNlcnZlZCA9IEVNUFRZX09CSkVDVDtcbiAgICB0aGlzLiRfX2NvbXBvbmVudHNCeUlkID0ge307XG59XG5cbkNvbXBvbmVudHNDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBnZXQgJF9fY29tcG9uZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJF9fY29tcG9uZW50U3RhY2tbMF0uJF9fY2hpbGRyZW47XG4gICAgfSxcblxuICAgICRfX2JlZ2luQ29tcG9uZW50OiBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29tcG9uZW50U3RhY2sgPSBzZWxmLiRfX2NvbXBvbmVudFN0YWNrO1xuICAgICAgICB2YXIgb3JpZ0xlbmd0aCA9IGNvbXBvbmVudFN0YWNrLmxlbmd0aDtcbiAgICAgICAgdmFyIHBhcmVudCA9IGNvbXBvbmVudFN0YWNrW29yaWdMZW5ndGggLSAxXTtcblxuICAgICAgICB2YXIgY29tcG9uZW50SWQgPSBjb21wb25lbnQuaWQ7XG5cbiAgICAgICAgaWYgKCFjb21wb25lbnRJZCkge1xuICAgICAgICAgICAgY29tcG9uZW50SWQgPSBjb21wb25lbnQuaWQgPSBwYXJlbnQuJF9fbmV4dElkKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29tcG9uZW50RGVmID0gbmV3IENvbXBvbmVudERlZihjb21wb25lbnQsIGNvbXBvbmVudElkLCB0aGlzLiRfX291dCwgY29tcG9uZW50U3RhY2ssIG9yaWdMZW5ndGgpO1xuICAgICAgICB0aGlzLiRfX2NvbXBvbmVudHNCeUlkW2NvbXBvbmVudElkXSA9IGNvbXBvbmVudERlZjtcbiAgICAgICAgcGFyZW50LiRfX2FkZENoaWxkKGNvbXBvbmVudERlZik7XG4gICAgICAgIGNvbXBvbmVudFN0YWNrLnB1c2goY29tcG9uZW50RGVmKTtcblxuICAgICAgICByZXR1cm4gY29tcG9uZW50RGVmO1xuICAgIH0sXG4gICAgJF9fY2xlYXJDb21wb25lbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJF9fY29tcG9uZW50U3RhY2sgPSBbbmV3IENvbXBvbmVudERlZihudWxsIC8qIGlkICovLCB0aGlzLiRfX291dCldO1xuICAgIH0sXG4gICAgJF9faW5pdENvbXBvbmVudHM6IGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudERlZnMgPSB0aGlzLiRfX2NvbXBvbmVudHM7XG4gICAgICAgIGlmIChjb21wb25lbnREZWZzKSB7XG4gICAgICAgICAgICBpbml0Q29tcG9uZW50cy4kX19pbml0Q2xpZW50UmVuZGVyZWQoY29tcG9uZW50RGVmcywgZG9jKTtcbiAgICAgICAgICAgIHRoaXMuJF9fY2xlYXJDb21wb25lbnRzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgICRfX25leHRDb21wb25lbnRJZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb21wb25lbnRTdGFjayA9IHRoaXMuJF9fY29tcG9uZW50U3RhY2s7XG4gICAgICAgIHZhciBwYXJlbnQgPSBjb21wb25lbnRTdGFja1tjb21wb25lbnRTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHBhcmVudC4kX19uZXh0SWQoKTtcbiAgICB9LFxuICAgICRfX3ByZXNlcnZlRE9NTm9kZTogZnVuY3Rpb24oZWxJZCwgYm9keU9ubHkpIHtcbiAgICAgICAgdmFyIHByZXNlcnZlZCA9IHRoaXMuJF9fcHJlc2VydmVkO1xuICAgICAgICBpZiAocHJlc2VydmVkID09IEVNUFRZX09CSkVDVCkge1xuICAgICAgICAgICAgcHJlc2VydmVkID0gdGhpcy4kX19wcmVzZXJ2ZWQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBwcmVzZXJ2ZWRbZWxJZF0gPSB7ICRfX2JvZHlPbmx5OiBib2R5T25seSB9O1xuICAgIH1cbn07XG5cbkNvbXBvbmVudHNDb250ZXh0LiRfX2dldENvbXBvbmVudHNDb250ZXh0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgIHZhciBnbG9iYWwgPSBvdXQuZ2xvYmFsO1xuXG4gICAgcmV0dXJuIG91dC5kYXRhLmNvbXBvbmVudHMgfHxcbiAgICAgICAgZ2xvYmFsLmNvbXBvbmVudHMgfHxcbiAgICAgICAgKGdsb2JhbC5jb21wb25lbnRzID0gbmV3IENvbXBvbmVudHNDb250ZXh0KG91dCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnRzQ29udGV4dDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYXJrby9jb21wb25lbnRzL0NvbXBvbmVudHNDb250ZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

eval("var extend = __webpack_require__(1);\n\nfunction ensure(state, propertyName) {\n    var proto = state.constructor.prototype;\n    if (!(propertyName in proto)) {\n        Object.defineProperty(proto, propertyName, {\n            get: function() {\n                return this.$__raw[propertyName];\n            },\n            set: function(value) {\n                this.$__set(propertyName, value, false /* ensure:false */);\n            }\n        });\n    }\n}\n\nfunction State(component, initialState) {\n    this.$__component = component;\n    this.$__raw = initialState || {};\n\n    this.$__dirty = false;\n    this.$__old = null;\n    this.$__changes = null;\n    this.$__forced = null; // An object that we use to keep tracking of state properties that were forced to be dirty\n\n    if (initialState) {\n        for(var key in initialState) {\n            ensure(this, key);\n        }\n    }\n\n    Object.seal(this);\n}\n\nState.prototype = {\n    $__reset: function() {\n        var self = this;\n\n        self.$__dirty = false;\n        self.$__old = null;\n        self.$__changes = null;\n        self.$__forced = null;\n    },\n\n    $__replace: function(newState) {\n        var state = this;\n        var key;\n\n        var rawState = this.$__raw;\n\n        for (key in rawState) {\n            if (!(key in newState)) {\n                state.$__set(key, undefined, false /* ensure:false */, false /* forceDirty:false */);\n            }\n        }\n\n        for (key in newState) {\n            state.$__set(key, newState[key], true /* ensure:true */, false /* forceDirty:false */);\n        }\n    },\n    $__set: function(name, value, shouldEnsure, forceDirty) {\n        var rawState = this.$__raw;\n\n        if (shouldEnsure) {\n            ensure(this, name);\n        }\n\n        if (forceDirty) {\n            var forcedDirtyState = this.$__forced || (this.$__forced = {});\n            forcedDirtyState[name] = true;\n        } else if (rawState[name] === value) {\n            return;\n        }\n\n        if (!this.$__dirty) {\n            // This is the first time we are modifying the component state\n            // so introduce some properties to do some tracking of\n            // changes to the state\n            this.$__dirty = true; // Mark the component state as dirty (i.e. modified)\n            this.$__old = rawState;\n            this.$__raw = rawState = extend({}, rawState);\n            this.$__changes = {};\n            this.$__component.$__queueUpdate();\n        }\n\n        this.$__changes[name] = value;\n\n        if (value === undefined) {\n            // Don't store state properties with an undefined or null value\n            delete rawState[name];\n        } else {\n            // Otherwise, store the new value in the component state\n            rawState[name] = value;\n        }\n    },\n    toJSON: function() {\n        return this.$__raw;\n    }\n};\n\nmodule.exports = State;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL2NvbXBvbmVudHMvU3RhdGUuanM/MTdhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZXh0ZW5kID0gcmVxdWlyZSgncmFwdG9yLXV0aWwvZXh0ZW5kJyk7XG5cbmZ1bmN0aW9uIGVuc3VyZShzdGF0ZSwgcHJvcGVydHlOYW1lKSB7XG4gICAgdmFyIHByb3RvID0gc3RhdGUuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIGlmICghKHByb3BlcnR5TmFtZSBpbiBwcm90bykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9fcmF3W3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJF9fc2V0KHByb3BlcnR5TmFtZSwgdmFsdWUsIGZhbHNlIC8qIGVuc3VyZTpmYWxzZSAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gU3RhdGUoY29tcG9uZW50LCBpbml0aWFsU3RhdGUpIHtcbiAgICB0aGlzLiRfX2NvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICB0aGlzLiRfX3JhdyA9IGluaXRpYWxTdGF0ZSB8fCB7fTtcblxuICAgIHRoaXMuJF9fZGlydHkgPSBmYWxzZTtcbiAgICB0aGlzLiRfX29sZCA9IG51bGw7XG4gICAgdGhpcy4kX19jaGFuZ2VzID0gbnVsbDtcbiAgICB0aGlzLiRfX2ZvcmNlZCA9IG51bGw7IC8vIEFuIG9iamVjdCB0aGF0IHdlIHVzZSB0byBrZWVwIHRyYWNraW5nIG9mIHN0YXRlIHByb3BlcnRpZXMgdGhhdCB3ZXJlIGZvcmNlZCB0byBiZSBkaXJ0eVxuXG4gICAgaWYgKGluaXRpYWxTdGF0ZSkge1xuICAgICAgICBmb3IodmFyIGtleSBpbiBpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgICAgIGVuc3VyZSh0aGlzLCBrZXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgT2JqZWN0LnNlYWwodGhpcyk7XG59XG5cblN0YXRlLnByb3RvdHlwZSA9IHtcbiAgICAkX19yZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBzZWxmLiRfX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHNlbGYuJF9fb2xkID0gbnVsbDtcbiAgICAgICAgc2VsZi4kX19jaGFuZ2VzID0gbnVsbDtcbiAgICAgICAgc2VsZi4kX19mb3JjZWQgPSBudWxsO1xuICAgIH0sXG5cbiAgICAkX19yZXBsYWNlOiBmdW5jdGlvbihuZXdTdGF0ZSkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzO1xuICAgICAgICB2YXIga2V5O1xuXG4gICAgICAgIHZhciByYXdTdGF0ZSA9IHRoaXMuJF9fcmF3O1xuXG4gICAgICAgIGZvciAoa2V5IGluIHJhd1N0YXRlKSB7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gbmV3U3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuJF9fc2V0KGtleSwgdW5kZWZpbmVkLCBmYWxzZSAvKiBlbnN1cmU6ZmFsc2UgKi8sIGZhbHNlIC8qIGZvcmNlRGlydHk6ZmFsc2UgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrZXkgaW4gbmV3U3RhdGUpIHtcbiAgICAgICAgICAgIHN0YXRlLiRfX3NldChrZXksIG5ld1N0YXRlW2tleV0sIHRydWUgLyogZW5zdXJlOnRydWUgKi8sIGZhbHNlIC8qIGZvcmNlRGlydHk6ZmFsc2UgKi8pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAkX19zZXQ6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBzaG91bGRFbnN1cmUsIGZvcmNlRGlydHkpIHtcbiAgICAgICAgdmFyIHJhd1N0YXRlID0gdGhpcy4kX19yYXc7XG5cbiAgICAgICAgaWYgKHNob3VsZEVuc3VyZSkge1xuICAgICAgICAgICAgZW5zdXJlKHRoaXMsIG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcmNlRGlydHkpIHtcbiAgICAgICAgICAgIHZhciBmb3JjZWREaXJ0eVN0YXRlID0gdGhpcy4kX19mb3JjZWQgfHwgKHRoaXMuJF9fZm9yY2VkID0ge30pO1xuICAgICAgICAgICAgZm9yY2VkRGlydHlTdGF0ZVtuYW1lXSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAocmF3U3RhdGVbbmFtZV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuJF9fZGlydHkpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2UgYXJlIG1vZGlmeWluZyB0aGUgY29tcG9uZW50IHN0YXRlXG4gICAgICAgICAgICAvLyBzbyBpbnRyb2R1Y2Ugc29tZSBwcm9wZXJ0aWVzIHRvIGRvIHNvbWUgdHJhY2tpbmcgb2ZcbiAgICAgICAgICAgIC8vIGNoYW5nZXMgdG8gdGhlIHN0YXRlXG4gICAgICAgICAgICB0aGlzLiRfX2RpcnR5ID0gdHJ1ZTsgLy8gTWFyayB0aGUgY29tcG9uZW50IHN0YXRlIGFzIGRpcnR5IChpLmUuIG1vZGlmaWVkKVxuICAgICAgICAgICAgdGhpcy4kX19vbGQgPSByYXdTdGF0ZTtcbiAgICAgICAgICAgIHRoaXMuJF9fcmF3ID0gcmF3U3RhdGUgPSBleHRlbmQoe30sIHJhd1N0YXRlKTtcbiAgICAgICAgICAgIHRoaXMuJF9fY2hhbmdlcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy4kX19jb21wb25lbnQuJF9fcXVldWVVcGRhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJF9fY2hhbmdlc1tuYW1lXSA9IHZhbHVlO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBzdG9yZSBzdGF0ZSBwcm9wZXJ0aWVzIHdpdGggYW4gdW5kZWZpbmVkIG9yIG51bGwgdmFsdWVcbiAgICAgICAgICAgIGRlbGV0ZSByYXdTdGF0ZVtuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgc3RvcmUgdGhlIG5ldyB2YWx1ZSBpbiB0aGUgY29tcG9uZW50IHN0YXRlXG4gICAgICAgICAgICByYXdTdGF0ZVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kX19yYXc7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWFya28vY29tcG9uZW50cy9TdGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 24 */
/***/ (function(module, exports) {

eval("module.exports = [\n    /* Mouse Events */\n    'click',\n    'dblclick',\n    'mousedown',\n    'mouseup',\n    // 'mouseover',\n    // 'mousemove',\n    // 'mouseout',\n    'dragstart',\n    'drag',\n    // 'dragenter',\n    // 'dragleave',\n    // 'dragover',\n    'drop',\n    'dragend',\n\n    /* Keyboard Events */\n    'keydown',\n    'keypress',\n    'keyup',\n\n    /* Form Events */\n    'select',\n    'change',\n    'submit',\n    'reset',\n    'input',\n\n    'attach', // Pseudo event supported by Marko\n    'detach'  // Pseudo event supported by Marko\n\n    // 'focus', <-- Does not bubble\n    // 'blur', <-- Does not bubble\n    // 'focusin', <-- Not supported in all browsers\n    // 'focusout' <-- Not supported in all browsers\n];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL2NvbXBvbmVudHMvYnViYmxlLmpzPzYwODAiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBbXG4gICAgLyogTW91c2UgRXZlbnRzICovXG4gICAgJ2NsaWNrJyxcbiAgICAnZGJsY2xpY2snLFxuICAgICdtb3VzZWRvd24nLFxuICAgICdtb3VzZXVwJyxcbiAgICAvLyAnbW91c2VvdmVyJyxcbiAgICAvLyAnbW91c2Vtb3ZlJyxcbiAgICAvLyAnbW91c2VvdXQnLFxuICAgICdkcmFnc3RhcnQnLFxuICAgICdkcmFnJyxcbiAgICAvLyAnZHJhZ2VudGVyJyxcbiAgICAvLyAnZHJhZ2xlYXZlJyxcbiAgICAvLyAnZHJhZ292ZXInLFxuICAgICdkcm9wJyxcbiAgICAnZHJhZ2VuZCcsXG5cbiAgICAvKiBLZXlib2FyZCBFdmVudHMgKi9cbiAgICAna2V5ZG93bicsXG4gICAgJ2tleXByZXNzJyxcbiAgICAna2V5dXAnLFxuXG4gICAgLyogRm9ybSBFdmVudHMgKi9cbiAgICAnc2VsZWN0JyxcbiAgICAnY2hhbmdlJyxcbiAgICAnc3VibWl0JyxcbiAgICAncmVzZXQnLFxuICAgICdpbnB1dCcsXG5cbiAgICAnYXR0YWNoJywgLy8gUHNldWRvIGV2ZW50IHN1cHBvcnRlZCBieSBNYXJrb1xuICAgICdkZXRhY2gnICAvLyBQc2V1ZG8gZXZlbnQgc3VwcG9ydGVkIGJ5IE1hcmtvXG5cbiAgICAvLyAnZm9jdXMnLCA8LS0gRG9lcyBub3QgYnViYmxlXG4gICAgLy8gJ2JsdXInLCA8LS0gRG9lcyBub3QgYnViYmxlXG4gICAgLy8gJ2ZvY3VzaW4nLCA8LS0gTm90IHN1cHBvcnRlZCBpbiBhbGwgYnJvd3NlcnNcbiAgICAvLyAnZm9jdXNvdXQnIDwtLSBOb3Qgc3VwcG9ydGVkIGluIGFsbCBicm93c2Vyc1xuXTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWFya28vY29tcG9uZW50cy9idWJibGUuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

eval("var events = __webpack_require__(7);\nvar Component = __webpack_require__(9);\nvar componentsUtil = __webpack_require__(0);\n\nfunction onInitComponent(listener) {\n    events.on('initComponent', listener);\n}\n\nexports.onInitComponent = onInitComponent;\nexports.Component = Component;\nexports.getComponentForEl = componentsUtil.$__getComponentForEl;\nexports.init = __webpack_require__(13).$__initServerRendered;\n\nexports.c = __webpack_require__(11); // Referenced by compiled templates\nexports.r = __webpack_require__(27); // Referenced by compiled templates\nexports.rc = __webpack_require__(5).$__register;  // Referenced by compiled templates\n\nwindow.$__MARKO_COMPONENTS = exports; // Helpful when debugging... WARNING: DO NOT USE IN REAL CODE!//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL2NvbXBvbmVudHMvaW5kZXgtYnJvd3Nlci5qcz81NzYyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBldmVudHMgPSByZXF1aXJlKCcuLi9ydW50aW1lL2V2ZW50cycpO1xudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4vQ29tcG9uZW50Jyk7XG52YXIgY29tcG9uZW50c1V0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZnVuY3Rpb24gb25Jbml0Q29tcG9uZW50KGxpc3RlbmVyKSB7XG4gICAgZXZlbnRzLm9uKCdpbml0Q29tcG9uZW50JywgbGlzdGVuZXIpO1xufVxuXG5leHBvcnRzLm9uSW5pdENvbXBvbmVudCA9IG9uSW5pdENvbXBvbmVudDtcbmV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuZXhwb3J0cy5nZXRDb21wb25lbnRGb3JFbCA9IGNvbXBvbmVudHNVdGlsLiRfX2dldENvbXBvbmVudEZvckVsO1xuZXhwb3J0cy5pbml0ID0gcmVxdWlyZSgnLi9pbml0LWNvbXBvbmVudHMnKS4kX19pbml0U2VydmVyUmVuZGVyZWQ7XG5cbmV4cG9ydHMuYyA9IHJlcXVpcmUoJy4vZGVmaW5lQ29tcG9uZW50Jyk7IC8vIFJlZmVyZW5jZWQgYnkgY29tcGlsZWQgdGVtcGxhdGVzXG5leHBvcnRzLnIgPSByZXF1aXJlKCcuL3JlbmRlcmVyJyk7IC8vIFJlZmVyZW5jZWQgYnkgY29tcGlsZWQgdGVtcGxhdGVzXG5leHBvcnRzLnJjID0gcmVxdWlyZSgnLi9yZWdpc3RyeScpLiRfX3JlZ2lzdGVyOyAgLy8gUmVmZXJlbmNlZCBieSBjb21waWxlZCB0ZW1wbGF0ZXNcblxud2luZG93LiRfX01BUktPX0NPTVBPTkVOVFMgPSBleHBvcnRzOyAvLyBIZWxwZnVsIHdoZW4gZGVidWdnaW5nLi4uIFdBUk5JTkc6IERPIE5PVCBVU0UgSU4gUkVBTCBDT0RFIVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYXJrby9jb21wb25lbnRzL2luZGV4LWJyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function load(typeName) {\n    throw new Error('Not found: ' + typeName);\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL2NvbXBvbmVudHMvbG9hZENvbXBvbmVudC5qcz84ZTEzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbG9hZCh0eXBlTmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGZvdW5kOiAnICsgdHlwZU5hbWUpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWFya28vY29tcG9uZW50cy9sb2FkQ29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

eval("var componentsUtil = __webpack_require__(0);\nvar componentLookup = componentsUtil.$__componentLookup;\nvar emitLifecycleEvent = componentsUtil.$__emitLifecycleEvent;\nvar nextRepeatedId = __webpack_require__(14);\nvar repeatedRegExp = /\\[\\]$/;\nvar ComponentsContext = __webpack_require__(22);\nvar registry = __webpack_require__(5);\nvar copyProps = __webpack_require__(18);\n\nvar COMPONENT_BEGIN_ASYNC_ADDED_KEY = '$wa';\n\nfunction resolveComponentKey(out, key, scope) {\n    if (key[0] == '#') {\n        return key.substring(1);\n    } else {\n        var resolvedId;\n\n        if (repeatedRegExp.test(key)) {\n            resolvedId = nextRepeatedId(out, scope, key);\n        } else {\n            resolvedId = scope + '-' + key;\n        }\n\n        return resolvedId;\n    }\n}\n\nfunction preserveComponentEls(existingComponent, out, componentsContext) {\n    var rootEls = existingComponent.$__getRootEls({});\n\n    for (var elId in rootEls) {\n        var el = rootEls[elId];\n\n        // We put a placeholder element in the output stream to ensure that the existing\n        // DOM node is matched up correctly when using morphdom.\n        out.element(el.tagName, { id: elId });\n\n        componentsContext.$__preserveDOMNode(elId); // Mark the element as being preserved (for morphdom)\n    }\n\n    existingComponent.$__reset(); // The component is no longer dirty so reset internal flags\n    return true;\n}\n\nfunction handleBeginAsync(event) {\n    var parentOut = event.parentOut;\n    var asyncOut = event.out;\n    var componentsContext = asyncOut.global.components;\n    var componentStack;\n\n    if (componentsContext && (componentStack = componentsContext.$__componentStack)) {\n        // All of the components in this async block should be\n        // initialized after the components in the parent. Therefore,\n        // we will create a new ComponentsContext for the nested\n        // async block and will create a new component stack where the current\n        // component in the parent block is the only component in the nested\n        // stack (to begin with). This will result in top-level components\n        // of the async block being added as children of the component in the\n        // parent block.\n        var nestedComponentsContext = new ComponentsContext(asyncOut, componentStack[componentStack.length-1]);\n        asyncOut.data.components = nestedComponentsContext;\n    }\n    asyncOut.$c = parentOut.$c;\n}\n\nfunction createRendererFunc(templateRenderFunc, componentProps, renderingLogic) {\n    renderingLogic = renderingLogic || {};\n    var onInput = renderingLogic.onInput;\n    var typeName = componentProps.type;\n    var roots = componentProps.roots;\n    var assignedId = componentProps.id;\n    var split = componentProps.split;\n\n    return function renderer(input, out) {\n        var outGlobal = out.global;\n\n        if (!out.isSync()) {\n            if (!outGlobal[COMPONENT_BEGIN_ASYNC_ADDED_KEY]) {\n                outGlobal[COMPONENT_BEGIN_ASYNC_ADDED_KEY] = true;\n                out.on('beginAsync', handleBeginAsync);\n            }\n        }\n\n        var component = outGlobal.$w;\n        var isRerender = component !== undefined;\n        var id = assignedId;\n        var isExisting;\n        var customEvents;\n        var scope;\n\n        if (component) {\n            id = component.id;\n            isExisting = true;\n            outGlobal.$w = null;\n        } else {\n            var componentArgs = out.$c;\n\n            if (componentArgs) {\n                out.$c = null;\n\n                scope = componentArgs[0];\n\n                if (scope) {\n                    scope = scope.id;\n                }\n\n                var key = componentArgs[1];\n                if (key != null) {\n                    key = key.toString();\n                }\n                id = id || resolveComponentKey(out, key, scope);\n                customEvents = componentArgs[2];\n            }\n        }\n\n        var componentsContext = ComponentsContext.$__getComponentsContext(out);\n        id = id || componentsContext.$__nextComponentId();\n\n        if (registry.$__isServer) {\n            component = registry.$__createComponent(\n                renderingLogic,\n                id,\n                input,\n                out,\n                typeName,\n                customEvents,\n                scope);\n            input = component.$__updatedInput;\n            component.$__updatedInput = undefined; // We don't want $__updatedInput to be serialized to the browser\n        } else {\n            if (!component) {\n                if (isRerender) {\n                    // Look in in the DOM to see if a component with the same ID and type already exists.\n                    component = componentLookup[id];\n                    if (component && component.$__type !== typeName) {\n                        component = undefined;\n                    }\n                }\n\n                if (component) {\n                    isExisting = true;\n                } else {\n                    isExisting = false;\n                    // We need to create a new instance of the component\n                    component = registry.$__createComponent(typeName, id);\n\n                    if (split) {\n                        split = false;\n\n                        var renderingLogicProps = typeof renderingLogic == 'function' ?\n                            renderingLogic.prototype :\n                            renderingLogic;\n\n                        copyProps(renderingLogicProps, component.constructor.prototype);\n                    }\n                }\n\n                // Set this flag to prevent the component from being queued for update\n                // based on the new input. The component is about to be rerendered\n                // so we don't want to queue it up as a result of calling `setInput()`\n                component.$__updateQueued = true;\n\n                component.$__setCustomEvents(customEvents, scope);\n\n                if (!isExisting) {\n                    emitLifecycleEvent(component, 'create', input, out);\n                }\n\n                input = component.$__setInput(input, onInput, out);\n\n                if (isExisting) {\n                    if (!component.$__isDirty || !component.shouldUpdate(input, component.$__state)) {\n                        preserveComponentEls(component, out, componentsContext);\n                        return;\n                    }\n                }\n            }\n\n            emitLifecycleEvent(component, 'render', out);\n        }\n\n        var componentDef = componentsContext.$__beginComponent(component);\n        componentDef.$__roots = roots;\n        componentDef.$__isExisting = isExisting;\n\n        // Render the template associated with the component using the final template\n        // data that we constructed\n        templateRenderFunc(input, out, componentDef, component, component.$__rawState);\n\n        componentDef.$__end();\n    };\n}\n\nmodule.exports = createRendererFunc;\n\n// exports used by the legacy renderer\ncreateRendererFunc.$__resolveComponentKey = resolveComponentKey;\ncreateRendererFunc.$__preserveComponentEls = preserveComponentEls;\ncreateRendererFunc.$__handleBeginAsync = handleBeginAsync;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL2NvbXBvbmVudHMvcmVuZGVyZXIuanM/MTM3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29tcG9uZW50c1V0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBjb21wb25lbnRMb29rdXAgPSBjb21wb25lbnRzVXRpbC4kX19jb21wb25lbnRMb29rdXA7XG52YXIgZW1pdExpZmVjeWNsZUV2ZW50ID0gY29tcG9uZW50c1V0aWwuJF9fZW1pdExpZmVjeWNsZUV2ZW50O1xudmFyIG5leHRSZXBlYXRlZElkID0gcmVxdWlyZSgnLi9uZXh0UmVwZWF0ZWRJZCcpO1xudmFyIHJlcGVhdGVkUmVnRXhwID0gL1xcW1xcXSQvO1xudmFyIENvbXBvbmVudHNDb250ZXh0ID0gcmVxdWlyZSgnLi9Db21wb25lbnRzQ29udGV4dCcpO1xudmFyIHJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9yZWdpc3RyeScpO1xudmFyIGNvcHlQcm9wcyA9IHJlcXVpcmUoJ3JhcHRvci11dGlsL2NvcHlQcm9wcycpO1xuXG52YXIgQ09NUE9ORU5UX0JFR0lOX0FTWU5DX0FEREVEX0tFWSA9ICckd2EnO1xuXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50S2V5KG91dCwga2V5LCBzY29wZSkge1xuICAgIGlmIChrZXlbMF0gPT0gJyMnKSB7XG4gICAgICAgIHJldHVybiBrZXkuc3Vic3RyaW5nKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXNvbHZlZElkO1xuXG4gICAgICAgIGlmIChyZXBlYXRlZFJlZ0V4cC50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgIHJlc29sdmVkSWQgPSBuZXh0UmVwZWF0ZWRJZChvdXQsIHNjb3BlLCBrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZWRJZCA9IHNjb3BlICsgJy0nICsga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkSWQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwcmVzZXJ2ZUNvbXBvbmVudEVscyhleGlzdGluZ0NvbXBvbmVudCwgb3V0LCBjb21wb25lbnRzQ29udGV4dCkge1xuICAgIHZhciByb290RWxzID0gZXhpc3RpbmdDb21wb25lbnQuJF9fZ2V0Um9vdEVscyh7fSk7XG5cbiAgICBmb3IgKHZhciBlbElkIGluIHJvb3RFbHMpIHtcbiAgICAgICAgdmFyIGVsID0gcm9vdEVsc1tlbElkXTtcblxuICAgICAgICAvLyBXZSBwdXQgYSBwbGFjZWhvbGRlciBlbGVtZW50IGluIHRoZSBvdXRwdXQgc3RyZWFtIHRvIGVuc3VyZSB0aGF0IHRoZSBleGlzdGluZ1xuICAgICAgICAvLyBET00gbm9kZSBpcyBtYXRjaGVkIHVwIGNvcnJlY3RseSB3aGVuIHVzaW5nIG1vcnBoZG9tLlxuICAgICAgICBvdXQuZWxlbWVudChlbC50YWdOYW1lLCB7IGlkOiBlbElkIH0pO1xuXG4gICAgICAgIGNvbXBvbmVudHNDb250ZXh0LiRfX3ByZXNlcnZlRE9NTm9kZShlbElkKTsgLy8gTWFyayB0aGUgZWxlbWVudCBhcyBiZWluZyBwcmVzZXJ2ZWQgKGZvciBtb3JwaGRvbSlcbiAgICB9XG5cbiAgICBleGlzdGluZ0NvbXBvbmVudC4kX19yZXNldCgpOyAvLyBUaGUgY29tcG9uZW50IGlzIG5vIGxvbmdlciBkaXJ0eSBzbyByZXNldCBpbnRlcm5hbCBmbGFnc1xuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVCZWdpbkFzeW5jKGV2ZW50KSB7XG4gICAgdmFyIHBhcmVudE91dCA9IGV2ZW50LnBhcmVudE91dDtcbiAgICB2YXIgYXN5bmNPdXQgPSBldmVudC5vdXQ7XG4gICAgdmFyIGNvbXBvbmVudHNDb250ZXh0ID0gYXN5bmNPdXQuZ2xvYmFsLmNvbXBvbmVudHM7XG4gICAgdmFyIGNvbXBvbmVudFN0YWNrO1xuXG4gICAgaWYgKGNvbXBvbmVudHNDb250ZXh0ICYmIChjb21wb25lbnRTdGFjayA9IGNvbXBvbmVudHNDb250ZXh0LiRfX2NvbXBvbmVudFN0YWNrKSkge1xuICAgICAgICAvLyBBbGwgb2YgdGhlIGNvbXBvbmVudHMgaW4gdGhpcyBhc3luYyBibG9jayBzaG91bGQgYmVcbiAgICAgICAgLy8gaW5pdGlhbGl6ZWQgYWZ0ZXIgdGhlIGNvbXBvbmVudHMgaW4gdGhlIHBhcmVudC4gVGhlcmVmb3JlLFxuICAgICAgICAvLyB3ZSB3aWxsIGNyZWF0ZSBhIG5ldyBDb21wb25lbnRzQ29udGV4dCBmb3IgdGhlIG5lc3RlZFxuICAgICAgICAvLyBhc3luYyBibG9jayBhbmQgd2lsbCBjcmVhdGUgYSBuZXcgY29tcG9uZW50IHN0YWNrIHdoZXJlIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIGNvbXBvbmVudCBpbiB0aGUgcGFyZW50IGJsb2NrIGlzIHRoZSBvbmx5IGNvbXBvbmVudCBpbiB0aGUgbmVzdGVkXG4gICAgICAgIC8vIHN0YWNrICh0byBiZWdpbiB3aXRoKS4gVGhpcyB3aWxsIHJlc3VsdCBpbiB0b3AtbGV2ZWwgY29tcG9uZW50c1xuICAgICAgICAvLyBvZiB0aGUgYXN5bmMgYmxvY2sgYmVpbmcgYWRkZWQgYXMgY2hpbGRyZW4gb2YgdGhlIGNvbXBvbmVudCBpbiB0aGVcbiAgICAgICAgLy8gcGFyZW50IGJsb2NrLlxuICAgICAgICB2YXIgbmVzdGVkQ29tcG9uZW50c0NvbnRleHQgPSBuZXcgQ29tcG9uZW50c0NvbnRleHQoYXN5bmNPdXQsIGNvbXBvbmVudFN0YWNrW2NvbXBvbmVudFN0YWNrLmxlbmd0aC0xXSk7XG4gICAgICAgIGFzeW5jT3V0LmRhdGEuY29tcG9uZW50cyA9IG5lc3RlZENvbXBvbmVudHNDb250ZXh0O1xuICAgIH1cbiAgICBhc3luY091dC4kYyA9IHBhcmVudE91dC4kYztcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVuZGVyZXJGdW5jKHRlbXBsYXRlUmVuZGVyRnVuYywgY29tcG9uZW50UHJvcHMsIHJlbmRlcmluZ0xvZ2ljKSB7XG4gICAgcmVuZGVyaW5nTG9naWMgPSByZW5kZXJpbmdMb2dpYyB8fCB7fTtcbiAgICB2YXIgb25JbnB1dCA9IHJlbmRlcmluZ0xvZ2ljLm9uSW5wdXQ7XG4gICAgdmFyIHR5cGVOYW1lID0gY29tcG9uZW50UHJvcHMudHlwZTtcbiAgICB2YXIgcm9vdHMgPSBjb21wb25lbnRQcm9wcy5yb290cztcbiAgICB2YXIgYXNzaWduZWRJZCA9IGNvbXBvbmVudFByb3BzLmlkO1xuICAgIHZhciBzcGxpdCA9IGNvbXBvbmVudFByb3BzLnNwbGl0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlbmRlcmVyKGlucHV0LCBvdXQpIHtcbiAgICAgICAgdmFyIG91dEdsb2JhbCA9IG91dC5nbG9iYWw7XG5cbiAgICAgICAgaWYgKCFvdXQuaXNTeW5jKCkpIHtcbiAgICAgICAgICAgIGlmICghb3V0R2xvYmFsW0NPTVBPTkVOVF9CRUdJTl9BU1lOQ19BRERFRF9LRVldKSB7XG4gICAgICAgICAgICAgICAgb3V0R2xvYmFsW0NPTVBPTkVOVF9CRUdJTl9BU1lOQ19BRERFRF9LRVldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBvdXQub24oJ2JlZ2luQXN5bmMnLCBoYW5kbGVCZWdpbkFzeW5jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb21wb25lbnQgPSBvdXRHbG9iYWwuJHc7XG4gICAgICAgIHZhciBpc1JlcmVuZGVyID0gY29tcG9uZW50ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBpZCA9IGFzc2lnbmVkSWQ7XG4gICAgICAgIHZhciBpc0V4aXN0aW5nO1xuICAgICAgICB2YXIgY3VzdG9tRXZlbnRzO1xuICAgICAgICB2YXIgc2NvcGU7XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgaWQgPSBjb21wb25lbnQuaWQ7XG4gICAgICAgICAgICBpc0V4aXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIG91dEdsb2JhbC4kdyA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50QXJncyA9IG91dC4kYztcblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudEFyZ3MpIHtcbiAgICAgICAgICAgICAgICBvdXQuJGMgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgc2NvcGUgPSBjb21wb25lbnRBcmdzWzBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlID0gc2NvcGUuaWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGNvbXBvbmVudEFyZ3NbMV07XG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZCA9IGlkIHx8IHJlc29sdmVDb21wb25lbnRLZXkob3V0LCBrZXksIHNjb3BlKTtcbiAgICAgICAgICAgICAgICBjdXN0b21FdmVudHMgPSBjb21wb25lbnRBcmdzWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbXBvbmVudHNDb250ZXh0ID0gQ29tcG9uZW50c0NvbnRleHQuJF9fZ2V0Q29tcG9uZW50c0NvbnRleHQob3V0KTtcbiAgICAgICAgaWQgPSBpZCB8fCBjb21wb25lbnRzQ29udGV4dC4kX19uZXh0Q29tcG9uZW50SWQoKTtcblxuICAgICAgICBpZiAocmVnaXN0cnkuJF9faXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IHJlZ2lzdHJ5LiRfX2NyZWF0ZUNvbXBvbmVudChcbiAgICAgICAgICAgICAgICByZW5kZXJpbmdMb2dpYyxcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBvdXQsXG4gICAgICAgICAgICAgICAgdHlwZU5hbWUsXG4gICAgICAgICAgICAgICAgY3VzdG9tRXZlbnRzLFxuICAgICAgICAgICAgICAgIHNjb3BlKTtcbiAgICAgICAgICAgIGlucHV0ID0gY29tcG9uZW50LiRfX3VwZGF0ZWRJbnB1dDtcbiAgICAgICAgICAgIGNvbXBvbmVudC4kX191cGRhdGVkSW5wdXQgPSB1bmRlZmluZWQ7IC8vIFdlIGRvbid0IHdhbnQgJF9fdXBkYXRlZElucHV0IHRvIGJlIHNlcmlhbGl6ZWQgdG8gdGhlIGJyb3dzZXJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVyZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9vayBpbiBpbiB0aGUgRE9NIHRvIHNlZSBpZiBhIGNvbXBvbmVudCB3aXRoIHRoZSBzYW1lIElEIGFuZCB0eXBlIGFscmVhZHkgZXhpc3RzLlxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnRMb29rdXBbaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC4kX190eXBlICE9PSB0eXBlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpc0V4aXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpc0V4aXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ID0gcmVnaXN0cnkuJF9fY3JlYXRlQ29tcG9uZW50KHR5cGVOYW1lLCBpZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwbGl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpdCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVuZGVyaW5nTG9naWNQcm9wcyA9IHR5cGVvZiByZW5kZXJpbmdMb2dpYyA9PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJpbmdMb2dpYy5wcm90b3R5cGUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmluZ0xvZ2ljO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5UHJvcHMocmVuZGVyaW5nTG9naWNQcm9wcywgY29tcG9uZW50LmNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhpcyBmbGFnIHRvIHByZXZlbnQgdGhlIGNvbXBvbmVudCBmcm9tIGJlaW5nIHF1ZXVlZCBmb3IgdXBkYXRlXG4gICAgICAgICAgICAgICAgLy8gYmFzZWQgb24gdGhlIG5ldyBpbnB1dC4gVGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byBiZSByZXJlbmRlcmVkXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3Qgd2FudCB0byBxdWV1ZSBpdCB1cCBhcyBhIHJlc3VsdCBvZiBjYWxsaW5nIGBzZXRJbnB1dCgpYFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC4kX191cGRhdGVRdWV1ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LiRfX3NldEN1c3RvbUV2ZW50cyhjdXN0b21FdmVudHMsIHNjb3BlKTtcblxuICAgICAgICAgICAgICAgIGlmICghaXNFeGlzdGluZykge1xuICAgICAgICAgICAgICAgICAgICBlbWl0TGlmZWN5Y2xlRXZlbnQoY29tcG9uZW50LCAnY3JlYXRlJywgaW5wdXQsIG91dCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW5wdXQgPSBjb21wb25lbnQuJF9fc2V0SW5wdXQoaW5wdXQsIG9uSW5wdXQsIG91dCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNFeGlzdGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudC4kX19pc0RpcnR5IHx8ICFjb21wb25lbnQuc2hvdWxkVXBkYXRlKGlucHV0LCBjb21wb25lbnQuJF9fc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVzZXJ2ZUNvbXBvbmVudEVscyhjb21wb25lbnQsIG91dCwgY29tcG9uZW50c0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbWl0TGlmZWN5Y2xlRXZlbnQoY29tcG9uZW50LCAncmVuZGVyJywgb3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb21wb25lbnREZWYgPSBjb21wb25lbnRzQ29udGV4dC4kX19iZWdpbkNvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgICBjb21wb25lbnREZWYuJF9fcm9vdHMgPSByb290cztcbiAgICAgICAgY29tcG9uZW50RGVmLiRfX2lzRXhpc3RpbmcgPSBpc0V4aXN0aW5nO1xuXG4gICAgICAgIC8vIFJlbmRlciB0aGUgdGVtcGxhdGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb21wb25lbnQgdXNpbmcgdGhlIGZpbmFsIHRlbXBsYXRlXG4gICAgICAgIC8vIGRhdGEgdGhhdCB3ZSBjb25zdHJ1Y3RlZFxuICAgICAgICB0ZW1wbGF0ZVJlbmRlckZ1bmMoaW5wdXQsIG91dCwgY29tcG9uZW50RGVmLCBjb21wb25lbnQsIGNvbXBvbmVudC4kX19yYXdTdGF0ZSk7XG5cbiAgICAgICAgY29tcG9uZW50RGVmLiRfX2VuZCgpO1xuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmVuZGVyZXJGdW5jO1xuXG4vLyBleHBvcnRzIHVzZWQgYnkgdGhlIGxlZ2FjeSByZW5kZXJlclxuY3JlYXRlUmVuZGVyZXJGdW5jLiRfX3Jlc29sdmVDb21wb25lbnRLZXkgPSByZXNvbHZlQ29tcG9uZW50S2V5O1xuY3JlYXRlUmVuZGVyZXJGdW5jLiRfX3ByZXNlcnZlQ29tcG9uZW50RWxzID0gcHJlc2VydmVDb21wb25lbnRFbHM7XG5jcmVhdGVSZW5kZXJlckZ1bmMuJF9faGFuZGxlQmVnaW5Bc3luYyA9IGhhbmRsZUJlZ2luQXN5bmM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWFya28vY29tcG9uZW50cy9yZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar updatesScheduled = false;\nvar batchStack = []; // A stack of batched updates\nvar unbatchedQueue = []; // Used for scheduled batched updates\n\nvar win = window;\nvar setImmediate = win.setImmediate;\n\nif (!setImmediate) {\n    if (win.postMessage) {\n        var queue = [];\n        var messageName = 'si';\n        win.addEventListener('message', function (event) {\n            var source = event.source;\n            if (source == win || !source && event.data === messageName) {\n                event.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        setImmediate = function(fn) {\n            queue.push(fn);\n            win.postMessage(messageName, '*');\n        };\n    } else {\n        setImmediate = setTimeout;\n    }\n}\n\n/**\n * This function is called when we schedule the update of \"unbatched\"\n * updates to components.\n */\nfunction updateUnbatchedComponents() {\n    if (unbatchedQueue.length) {\n        try {\n            updateComponents(unbatchedQueue);\n        } finally {\n            // Reset the flag now that this scheduled batch update\n            // is complete so that we can later schedule another\n            // batched update if needed\n            updatesScheduled = false;\n        }\n    }\n}\n\nfunction scheduleUpdates() {\n    if (updatesScheduled) {\n        // We have already scheduled a batched update for the\n        // process.nextTick so nothing to do\n        return;\n    }\n\n    updatesScheduled = true;\n\n    setImmediate(updateUnbatchedComponents);\n}\n\nfunction updateComponents(queue) {\n    // Loop over the components in the queue and update them.\n    // NOTE: It is okay if the queue grows during the iteration\n    //       since we will still get to them at the end\n    for (var i=0; i<queue.length; i++) {\n        var component = queue[i];\n        component.$__update(); // Do the actual component update\n    }\n\n    // Clear out the queue by setting the length to zero\n    queue.length = 0;\n}\n\nfunction batchUpdate(func) {\n    // If the batched update stack is empty then this\n    // is the outer batched update. After the outer\n    // batched update completes we invoke the \"afterUpdate\"\n    // event listeners.\n    var batch = {\n        $__queue: null\n    };\n\n    batchStack.push(batch);\n\n    try {\n        func();\n    } finally {\n        try {\n            // Update all of the components that where queued up\n            // in this batch (if any)\n            if (batch.$__queue) {\n                updateComponents(batch.$__queue);\n            }\n        } finally {\n            // Now that we have completed the update of all the components\n            // in this batch we need to remove it off the top of the stack\n            batchStack.length--;\n        }\n    }\n}\n\nfunction queueComponentUpdate(component) {\n    var batchStackLen = batchStack.length;\n\n    if (batchStackLen) {\n        // When a batch update is started we push a new batch on to a stack.\n        // If the stack has a non-zero length then we know that a batch has\n        // been started so we can just queue the component on the top batch. When\n        // the batch is ended this component will be updated.\n        var batch = batchStack[batchStackLen-1];\n\n        // We default the batch queue to null to avoid creating an Array instance\n        // unnecessarily. If it is null then we create a new Array, otherwise\n        // we push it onto the existing Array queue\n        if (batch.$__queue) {\n            batch.$__queue.push(component);\n        } else {\n            batch.$__queue = [component];\n        }\n    } else {\n        // We are not within a batched update. We need to schedule a batch update\n        // for the process.nextTick (if that hasn't been done already) and we will\n        // add the component to the unbatched queued\n        scheduleUpdates();\n        unbatchedQueue.push(component);\n    }\n}\n\nexports.$__queueComponentUpdate = queueComponentUpdate;\nexports.$__batchUpdate = batchUpdate;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL2NvbXBvbmVudHMvdXBkYXRlLW1hbmFnZXIuanM/YzliYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1cGRhdGVzU2NoZWR1bGVkID0gZmFsc2U7XG52YXIgYmF0Y2hTdGFjayA9IFtdOyAvLyBBIHN0YWNrIG9mIGJhdGNoZWQgdXBkYXRlc1xudmFyIHVuYmF0Y2hlZFF1ZXVlID0gW107IC8vIFVzZWQgZm9yIHNjaGVkdWxlZCBiYXRjaGVkIHVwZGF0ZXNcblxudmFyIHdpbiA9IHdpbmRvdztcbnZhciBzZXRJbW1lZGlhdGUgPSB3aW4uc2V0SW1tZWRpYXRlO1xuXG5pZiAoIXNldEltbWVkaWF0ZSkge1xuICAgIGlmICh3aW4ucG9zdE1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHZhciBtZXNzYWdlTmFtZSA9ICdzaSc7XG4gICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXZlbnQuc291cmNlO1xuICAgICAgICAgICAgaWYgKHNvdXJjZSA9PSB3aW4gfHwgIXNvdXJjZSAmJiBldmVudC5kYXRhID09PSBtZXNzYWdlTmFtZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbihmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW4ucG9zdE1lc3NhZ2UobWVzc2FnZU5hbWUsICcqJyk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlID0gc2V0VGltZW91dDtcbiAgICB9XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiB3ZSBzY2hlZHVsZSB0aGUgdXBkYXRlIG9mIFwidW5iYXRjaGVkXCJcbiAqIHVwZGF0ZXMgdG8gY29tcG9uZW50cy5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlVW5iYXRjaGVkQ29tcG9uZW50cygpIHtcbiAgICBpZiAodW5iYXRjaGVkUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1cGRhdGVDb21wb25lbnRzKHVuYmF0Y2hlZFF1ZXVlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBmbGFnIG5vdyB0aGF0IHRoaXMgc2NoZWR1bGVkIGJhdGNoIHVwZGF0ZVxuICAgICAgICAgICAgLy8gaXMgY29tcGxldGUgc28gdGhhdCB3ZSBjYW4gbGF0ZXIgc2NoZWR1bGUgYW5vdGhlclxuICAgICAgICAgICAgLy8gYmF0Y2hlZCB1cGRhdGUgaWYgbmVlZGVkXG4gICAgICAgICAgICB1cGRhdGVzU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlVXBkYXRlcygpIHtcbiAgICBpZiAodXBkYXRlc1NjaGVkdWxlZCkge1xuICAgICAgICAvLyBXZSBoYXZlIGFscmVhZHkgc2NoZWR1bGVkIGEgYmF0Y2hlZCB1cGRhdGUgZm9yIHRoZVxuICAgICAgICAvLyBwcm9jZXNzLm5leHRUaWNrIHNvIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHVwZGF0ZXNTY2hlZHVsZWQgPSB0cnVlO1xuXG4gICAgc2V0SW1tZWRpYXRlKHVwZGF0ZVVuYmF0Y2hlZENvbXBvbmVudHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRzKHF1ZXVlKSB7XG4gICAgLy8gTG9vcCBvdmVyIHRoZSBjb21wb25lbnRzIGluIHRoZSBxdWV1ZSBhbmQgdXBkYXRlIHRoZW0uXG4gICAgLy8gTk9URTogSXQgaXMgb2theSBpZiB0aGUgcXVldWUgZ3Jvd3MgZHVyaW5nIHRoZSBpdGVyYXRpb25cbiAgICAvLyAgICAgICBzaW5jZSB3ZSB3aWxsIHN0aWxsIGdldCB0byB0aGVtIGF0IHRoZSBlbmRcbiAgICBmb3IgKHZhciBpPTA7IGk8cXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHF1ZXVlW2ldO1xuICAgICAgICBjb21wb25lbnQuJF9fdXBkYXRlKCk7IC8vIERvIHRoZSBhY3R1YWwgY29tcG9uZW50IHVwZGF0ZVxuICAgIH1cblxuICAgIC8vIENsZWFyIG91dCB0aGUgcXVldWUgYnkgc2V0dGluZyB0aGUgbGVuZ3RoIHRvIHplcm9cbiAgICBxdWV1ZS5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBiYXRjaFVwZGF0ZShmdW5jKSB7XG4gICAgLy8gSWYgdGhlIGJhdGNoZWQgdXBkYXRlIHN0YWNrIGlzIGVtcHR5IHRoZW4gdGhpc1xuICAgIC8vIGlzIHRoZSBvdXRlciBiYXRjaGVkIHVwZGF0ZS4gQWZ0ZXIgdGhlIG91dGVyXG4gICAgLy8gYmF0Y2hlZCB1cGRhdGUgY29tcGxldGVzIHdlIGludm9rZSB0aGUgXCJhZnRlclVwZGF0ZVwiXG4gICAgLy8gZXZlbnQgbGlzdGVuZXJzLlxuICAgIHZhciBiYXRjaCA9IHtcbiAgICAgICAgJF9fcXVldWU6IG51bGxcbiAgICB9O1xuXG4gICAgYmF0Y2hTdGFjay5wdXNoKGJhdGNoKTtcblxuICAgIHRyeSB7XG4gICAgICAgIGZ1bmMoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGFsbCBvZiB0aGUgY29tcG9uZW50cyB0aGF0IHdoZXJlIHF1ZXVlZCB1cFxuICAgICAgICAgICAgLy8gaW4gdGhpcyBiYXRjaCAoaWYgYW55KVxuICAgICAgICAgICAgaWYgKGJhdGNoLiRfX3F1ZXVlKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50cyhiYXRjaC4kX19xdWV1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAvLyBOb3cgdGhhdCB3ZSBoYXZlIGNvbXBsZXRlZCB0aGUgdXBkYXRlIG9mIGFsbCB0aGUgY29tcG9uZW50c1xuICAgICAgICAgICAgLy8gaW4gdGhpcyBiYXRjaCB3ZSBuZWVkIHRvIHJlbW92ZSBpdCBvZmYgdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICAgICAgICAgIGJhdGNoU3RhY2subGVuZ3RoLS07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHF1ZXVlQ29tcG9uZW50VXBkYXRlKGNvbXBvbmVudCkge1xuICAgIHZhciBiYXRjaFN0YWNrTGVuID0gYmF0Y2hTdGFjay5sZW5ndGg7XG5cbiAgICBpZiAoYmF0Y2hTdGFja0xlbikge1xuICAgICAgICAvLyBXaGVuIGEgYmF0Y2ggdXBkYXRlIGlzIHN0YXJ0ZWQgd2UgcHVzaCBhIG5ldyBiYXRjaCBvbiB0byBhIHN0YWNrLlxuICAgICAgICAvLyBJZiB0aGUgc3RhY2sgaGFzIGEgbm9uLXplcm8gbGVuZ3RoIHRoZW4gd2Uga25vdyB0aGF0IGEgYmF0Y2ggaGFzXG4gICAgICAgIC8vIGJlZW4gc3RhcnRlZCBzbyB3ZSBjYW4ganVzdCBxdWV1ZSB0aGUgY29tcG9uZW50IG9uIHRoZSB0b3AgYmF0Y2guIFdoZW5cbiAgICAgICAgLy8gdGhlIGJhdGNoIGlzIGVuZGVkIHRoaXMgY29tcG9uZW50IHdpbGwgYmUgdXBkYXRlZC5cbiAgICAgICAgdmFyIGJhdGNoID0gYmF0Y2hTdGFja1tiYXRjaFN0YWNrTGVuLTFdO1xuXG4gICAgICAgIC8vIFdlIGRlZmF1bHQgdGhlIGJhdGNoIHF1ZXVlIHRvIG51bGwgdG8gYXZvaWQgY3JlYXRpbmcgYW4gQXJyYXkgaW5zdGFuY2VcbiAgICAgICAgLy8gdW5uZWNlc3NhcmlseS4gSWYgaXQgaXMgbnVsbCB0aGVuIHdlIGNyZWF0ZSBhIG5ldyBBcnJheSwgb3RoZXJ3aXNlXG4gICAgICAgIC8vIHdlIHB1c2ggaXQgb250byB0aGUgZXhpc3RpbmcgQXJyYXkgcXVldWVcbiAgICAgICAgaWYgKGJhdGNoLiRfX3F1ZXVlKSB7XG4gICAgICAgICAgICBiYXRjaC4kX19xdWV1ZS5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXRjaC4kX19xdWV1ZSA9IFtjb21wb25lbnRdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UgYXJlIG5vdCB3aXRoaW4gYSBiYXRjaGVkIHVwZGF0ZS4gV2UgbmVlZCB0byBzY2hlZHVsZSBhIGJhdGNoIHVwZGF0ZVxuICAgICAgICAvLyBmb3IgdGhlIHByb2Nlc3MubmV4dFRpY2sgKGlmIHRoYXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5KSBhbmQgd2Ugd2lsbFxuICAgICAgICAvLyBhZGQgdGhlIGNvbXBvbmVudCB0byB0aGUgdW5iYXRjaGVkIHF1ZXVlZFxuICAgICAgICBzY2hlZHVsZVVwZGF0ZXMoKTtcbiAgICAgICAgdW5iYXRjaGVkUXVldWUucHVzaChjb21wb25lbnQpO1xuICAgIH1cbn1cblxuZXhwb3J0cy4kX19xdWV1ZUNvbXBvbmVudFVwZGF0ZSA9IHF1ZXVlQ29tcG9uZW50VXBkYXRlO1xuZXhwb3J0cy4kX19iYXRjaFVwZGF0ZSA9IGJhdGNoVXBkYXRlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYXJrby9jb21wb25lbnRzL3VwZGF0ZS1tYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar defaultDoc = typeof document == 'undefined' ? undefined : document;\nvar specialElHandlers = __webpack_require__(30);\n\nvar morphAttrs = __webpack_require__(17).$__morphAttrs;\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nfunction compareNodeNames(fromEl, toEl) {\n    return fromEl.nodeName == toEl.nodeName;\n}\n\nfunction replaceChild(child, newChild) {\n    if (child.parentNode) {\n        child.parentNode.replaceChild(newChild, child);\n    }\n    return newChild;\n}\n\nfunction morphdom(\n        fromNode,\n        toNode,\n        context,\n        onNodeAdded,\n        onBeforeElUpdated,\n        onBeforeNodeDiscarded,\n        onNodeDiscarded,\n        onBeforeElChildrenUpdated\n    ) {\n\n    var doc = fromNode.ownerDocument || defaultDoc;\n\n    // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n    var fromNodesLookup = {};\n    var keyedRemovalList;\n\n    function addKeyedRemoval(key) {\n        if (keyedRemovalList) {\n            keyedRemovalList.push(key);\n        } else {\n            keyedRemovalList = [key];\n        }\n    }\n\n    function walkDiscardedChildNodes(node, skipKeyedNodes) {\n        if (node.nodeType == ELEMENT_NODE) {\n            var curChild = node.firstChild;\n            while (curChild) {\n                var key;\n\n                if (skipKeyedNodes && (key = curChild.id)) {\n                    // If we are skipping keyed nodes then we add the key\n                    // to a list so that it can be handled at the very end.\n                    addKeyedRemoval(key);\n                } else {\n                    // Only report the node as discarded if it is not keyed. We do this because\n                    // at the end we loop through all keyed elements that were unmatched\n                    // and then discard them in one final pass.\n                    onNodeDiscarded(curChild);\n                    if (curChild.firstChild) {\n                        walkDiscardedChildNodes(curChild, skipKeyedNodes);\n                    }\n                }\n\n                curChild = curChild.nextSibling;\n            }\n        }\n    }\n\n    /**\n     * Removes a DOM node out of the original DOM\n     *\n     * @param  {Node} node The node to remove\n     * @param  {Node} parentNode The nodes parent\n     * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n     * @return {undefined}\n     */\n    function removeNode(node, parentNode, skipKeyedNodes) {\n        if (onBeforeNodeDiscarded(node) == false) {\n            return;\n        }\n\n        if (parentNode) {\n            parentNode.removeChild(node);\n        }\n\n        onNodeDiscarded(node);\n        walkDiscardedChildNodes(node, skipKeyedNodes);\n    }\n\n    // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n    // function indexTree(root) {\n    //     var treeWalker = document.createTreeWalker(\n    //         root,\n    //         NodeFilter.SHOW_ELEMENT);\n    //\n    //     var el;\n    //     while((el = treeWalker.nextNode())) {\n    //         var key = getNodeKey(el);\n    //         if (key) {\n    //             fromNodesLookup[key] = el;\n    //         }\n    //     }\n    // }\n\n    // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n    //\n    // function indexTree(node) {\n    //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n    //     var el;\n    //     while((el = nodeIterator.nextNode())) {\n    //         var key = getNodeKey(el);\n    //         if (key) {\n    //             fromNodesLookup[key] = el;\n    //         }\n    //     }\n    // }\n\n    function indexTree(node) {\n        if (node.nodeType == ELEMENT_NODE) {\n            var curChild = node.firstChild;\n            while (curChild) {\n                var key = curChild.id;\n                if (key) {\n                    fromNodesLookup[key] = curChild;\n                }\n\n                // Walk recursively\n                indexTree(curChild);\n\n                curChild = curChild.nextSibling;\n            }\n        }\n    }\n\n    indexTree(fromNode);\n\n    function addVirtualNode(vEl, parentEl) {\n        var realEl = vEl.$__actualize(doc);\n\n        if (parentEl) {\n            parentEl.appendChild(realEl);\n        }\n\n        onNodeAdded(realEl, context);\n\n        var vCurChild = vEl.firstChild;\n        while (vCurChild) {\n            var realCurChild = null;\n\n            var key = vCurChild.id;\n            if (key) {\n                var unmatchedFromEl = fromNodesLookup[key];\n                if (unmatchedFromEl && compareNodeNames(vCurChild, unmatchedFromEl)) {\n                    morphEl(unmatchedFromEl, vCurChild, false);\n                    realEl.appendChild(realCurChild = unmatchedFromEl);\n                }\n            }\n\n            if (!realCurChild) {\n                addVirtualNode(vCurChild, realEl);\n            }\n\n            vCurChild = vCurChild.nextSibling;\n        }\n\n        return realEl;\n    }\n\n    function morphEl(fromEl, toEl, childrenOnly) {\n\n        if (!childrenOnly) {\n            var toElKey = toEl.id;\n\n\n            if (toElKey) {\n                // If an element with an ID is being morphed then it is will be in the final\n                // DOM so clear it out of the saved elements collection\n                delete fromNodesLookup[toElKey];\n            }\n\n            if (toNode.$__isSameNode(fromNode)) {\n                return;\n            }\n\n            if (onBeforeElUpdated(fromEl, context)) {\n                return;\n            }\n\n            morphAttrs(fromEl, toEl);\n        }\n\n\n        if (onBeforeElChildrenUpdated(fromEl, context)) {\n            return;\n        }\n\n        if (fromEl.nodeName != 'TEXTAREA') {\n            var curToNodeChild = toEl.firstChild;\n            var curFromNodeChild = fromEl.firstChild;\n            var curToNodeKey;\n            var curFromNodeKey;\n\n            var fromNextSibling;\n            var toNextSibling;\n            var matchingFromEl;\n\n            outer: while (curToNodeChild) {\n                toNextSibling = curToNodeChild.nextSibling;\n                curToNodeKey = curToNodeChild.id;\n\n                while (curFromNodeChild) {\n                    fromNextSibling = curFromNodeChild.nextSibling;\n\n                    if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n                        curToNodeChild = toNextSibling;\n                        curFromNodeChild = fromNextSibling;\n                        continue outer;\n                    }\n\n                    curFromNodeKey = curFromNodeChild.id;\n\n                    var curFromNodeType = curFromNodeChild.nodeType;\n\n                    var isCompatible = undefined;\n\n                    if (curFromNodeType == curToNodeChild.nodeType) {\n                        if (curFromNodeType == ELEMENT_NODE) {\n                            // Both nodes being compared are Element nodes\n\n                            if (curToNodeKey) {\n                                // The target node has a key so we want to match it up with the correct element\n                                // in the original DOM tree\n                                if (curToNodeKey != curFromNodeKey) {\n                                    // The current element in the original DOM tree does not have a matching key so\n                                    // let's check our lookup to see if there is a matching element in the original\n                                    // DOM tree\n                                    if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                                        if (curFromNodeChild.nextSibling == matchingFromEl) {\n                                            // Special case for single element removals. To avoid removing the original\n                                            // DOM node out of the tree (since that can break CSS transitions, etc.),\n                                            // we will instead discard the current node and wait until the next\n                                            // iteration to properly match up the keyed target element with its matching\n                                            // element in the original tree\n                                            isCompatible = false;\n                                        } else {\n                                            // We found a matching keyed element somewhere in the original DOM tree.\n                                            // Let's moving the original DOM node into the current position and morph\n                                            // it.\n\n                                            // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                                            // the `removeNode()` function for the node that is being discarded so that\n                                            // all lifecycle hooks are correctly invoked\n                                            fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                                            fromNextSibling = curFromNodeChild.nextSibling;\n\n                                            if (curFromNodeKey) {\n                                                // Since the node is keyed it might be matched up later so we defer\n                                                // the actual removal to later\n                                                addKeyedRemoval(curFromNodeKey);\n                                            } else {\n                                                // NOTE: we skip nested keyed nodes from being removed since there is\n                                                //       still a chance they will be matched up later\n                                                removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                                            }\n\n                                            curFromNodeChild = matchingFromEl;\n                                        }\n                                    } else {\n                                        // The nodes are not compatible since the \"to\" node has a key and there\n                                        // is no matching keyed node in the source tree\n                                        isCompatible = false;\n                                    }\n                                }\n                            } else if (curFromNodeKey) {\n                                // The original has a key\n                                isCompatible = false;\n                            }\n\n                            isCompatible = isCompatible != false && compareNodeNames(curFromNodeChild, curToNodeChild);\n                            if (isCompatible) {\n                                // We found compatible DOM elements so transform\n                                // the current \"from\" node to match the current\n                                // target DOM node.\n                                morphEl(curFromNodeChild, curToNodeChild, false);\n                            }\n\n                        } else if (curFromNodeType == TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n                            // Both nodes being compared are Text or Comment nodes\n                            isCompatible = true;\n                            // Simply update nodeValue on the original node to\n                            // change the text value\n                            curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                        }\n                    }\n\n                    if (isCompatible) {\n                        // Advance both the \"to\" child and the \"from\" child since we found a match\n                        curToNodeChild = toNextSibling;\n                        curFromNodeChild = fromNextSibling;\n                        continue outer;\n                    }\n\n                    // No compatible match so remove the old node from the DOM and continue trying to find a\n                    // match in the original DOM. However, we only do this if the from node is not keyed\n                    // since it is possible that a keyed node might match up with a node somewhere else in the\n                    // target tree and we don't want to discard it just yet since it still might find a\n                    // home in the final DOM tree. After everything is done we will remove any keyed nodes\n                    // that didn't find a home\n                    if (curFromNodeKey) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                    } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                    }\n\n                    curFromNodeChild = fromNextSibling;\n                }\n\n                // If we got this far then we did not find a candidate match for\n                // our \"to node\" and we exhausted all of the children \"from\"\n                // nodes. Therefore, we will just append the current \"to\" node\n                // to the end\n                if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n                    fromEl.appendChild(matchingFromEl);\n                    morphEl(matchingFromEl, curToNodeChild, false);\n                } else {\n                    addVirtualNode(curToNodeChild, fromEl);\n                }\n\n                curToNodeChild = toNextSibling;\n                curFromNodeChild = fromNextSibling;\n            }\n\n            // We have processed all of the \"to nodes\". If curFromNodeChild is\n            // non-null then we still have some from nodes left over that need\n            // to be removed\n            while (curFromNodeChild) {\n                fromNextSibling = curFromNodeChild.nextSibling;\n                if ((curFromNodeKey = curFromNodeChild.id)) {\n                    // Since the node is keyed it might be matched up later so we defer\n                    // the actual removal to later\n                    addKeyedRemoval(curFromNodeKey);\n                } else {\n                    // NOTE: we skip nested keyed nodes from being removed since there is\n                    //       still a chance they will be matched up later\n                    removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                }\n                curFromNodeChild = fromNextSibling;\n            }\n        }\n\n        var specialElHandler = specialElHandlers[fromEl.nodeName];\n        if (specialElHandler) {\n            specialElHandler(fromEl, toEl);\n        }\n    } // END: morphEl(...)\n\n    var morphedNode = fromNode;\n    var fromNodeType = morphedNode.nodeType;\n    var toNodeType = toNode.nodeType;\n    var morphChildrenOnly = false;\n\n    // Handle the case where we are given two DOM nodes that are not\n    // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n    if (fromNodeType == ELEMENT_NODE) {\n        if (toNodeType == ELEMENT_NODE) {\n            if (!compareNodeNames(fromNode, toNode)) {\n                morphedNode = toNode.$__actualize(doc);\n                replaceChild(fromNode, morphedNode);\n                morphChildrenOnly = true;\n                onNodeDiscarded(fromNode);\n                walkDiscardedChildNodes(fromNode, true);\n            }\n        } else {\n            // Going from an element node to a text or comment node\n            onNodeDiscarded(fromNode);\n            walkDiscardedChildNodes(fromNode, false);\n            morphedNode = toNode.$__actualize(doc);\n            return replaceChild(fromNode, morphedNode);\n        }\n    } else if (fromNodeType == TEXT_NODE || fromNodeType == COMMENT_NODE) { // Text or comment node\n        if (toNodeType == fromNodeType) {\n            morphedNode.nodeValue = toNode.nodeValue;\n            return morphedNode;\n        } else {\n            // Text node to something else\n            onNodeDiscarded(fromNode);\n            return replaceChild(fromNode, addVirtualNode(toNode));\n        }\n    }\n\n    morphEl(morphedNode, toNode, morphChildrenOnly);\n\n    // We now need to loop over any keyed nodes that might need to be\n    // removed. We only do the removal if we know that the keyed node\n    // never found a match. When a keyed node is matched up we remove\n    // it out of fromNodesLookup and we use fromNodesLookup to determine\n    // if a keyed node has been matched up or not\n    if (keyedRemovalList) {\n        keyedRemovalList.forEach(function(key) {\n            var elToRemove = fromNodesLookup[key];\n            if (elToRemove) {\n                removeNode(elToRemove, elToRemove.parentNode, false);\n            }\n        });\n    }\n\n    return morphedNode;\n}\n\nmodule.exports = morphdom;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL21vcnBoZG9tL2luZGV4LmpzPzM2MGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIGRlZmF1bHREb2MgPSB0eXBlb2YgZG9jdW1lbnQgPT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBkb2N1bWVudDtcbnZhciBzcGVjaWFsRWxIYW5kbGVycyA9IHJlcXVpcmUoJy4vc3BlY2lhbEVsSGFuZGxlcnMnKTtcblxudmFyIG1vcnBoQXR0cnMgPSByZXF1aXJlKCcuLi9ydW50aW1lL3Zkb20vVkVsZW1lbnQnKS4kX19tb3JwaEF0dHJzO1xuXG52YXIgRUxFTUVOVF9OT0RFID0gMTtcbnZhciBURVhUX05PREUgPSAzO1xudmFyIENPTU1FTlRfTk9ERSA9IDg7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHR3byBub2RlJ3MgbmFtZXMgYXJlIHRoZSBzYW1lLlxuICpcbiAqIE5PVEU6IFdlIGRvbid0IGJvdGhlciBjaGVja2luZyBgbmFtZXNwYWNlVVJJYCBiZWNhdXNlIHlvdSB3aWxsIG5ldmVyIGZpbmQgdHdvIEhUTUwgZWxlbWVudHMgd2l0aCB0aGUgc2FtZVxuICogICAgICAgbm9kZU5hbWUgYW5kIGRpZmZlcmVudCBuYW1lc3BhY2UgVVJJcy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYiBUaGUgdGFyZ2V0IGVsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTmFtZXMoZnJvbUVsLCB0b0VsKSB7XG4gICAgcmV0dXJuIGZyb21FbC5ub2RlTmFtZSA9PSB0b0VsLm5vZGVOYW1lO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlQ2hpbGQoY2hpbGQsIG5ld0NoaWxkKSB7XG4gICAgaWYgKGNoaWxkLnBhcmVudE5vZGUpIHtcbiAgICAgICAgY2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Q2hpbGQsIGNoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0NoaWxkO1xufVxuXG5mdW5jdGlvbiBtb3JwaGRvbShcbiAgICAgICAgZnJvbU5vZGUsXG4gICAgICAgIHRvTm9kZSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgb25Ob2RlQWRkZWQsXG4gICAgICAgIG9uQmVmb3JlRWxVcGRhdGVkLFxuICAgICAgICBvbkJlZm9yZU5vZGVEaXNjYXJkZWQsXG4gICAgICAgIG9uTm9kZURpc2NhcmRlZCxcbiAgICAgICAgb25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZFxuICAgICkge1xuXG4gICAgdmFyIGRvYyA9IGZyb21Ob2RlLm93bmVyRG9jdW1lbnQgfHwgZGVmYXVsdERvYztcblxuICAgIC8vIFRoaXMgb2JqZWN0IGlzIHVzZWQgYXMgYSBsb29rdXAgdG8gcXVpY2tseSBmaW5kIGFsbCBrZXllZCBlbGVtZW50cyBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWUuXG4gICAgdmFyIGZyb21Ob2Rlc0xvb2t1cCA9IHt9O1xuICAgIHZhciBrZXllZFJlbW92YWxMaXN0O1xuXG4gICAgZnVuY3Rpb24gYWRkS2V5ZWRSZW1vdmFsKGtleSkge1xuICAgICAgICBpZiAoa2V5ZWRSZW1vdmFsTGlzdCkge1xuICAgICAgICAgICAga2V5ZWRSZW1vdmFsTGlzdC5wdXNoKGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXllZFJlbW92YWxMaXN0ID0gW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3YWxrRGlzY2FyZGVkQ2hpbGROb2Rlcyhub2RlLCBza2lwS2V5ZWROb2Rlcykge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHZhciBjdXJDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2tpcEtleWVkTm9kZXMgJiYgKGtleSA9IGN1ckNoaWxkLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgc2tpcHBpbmcga2V5ZWQgbm9kZXMgdGhlbiB3ZSBhZGQgdGhlIGtleVxuICAgICAgICAgICAgICAgICAgICAvLyB0byBhIGxpc3Qgc28gdGhhdCBpdCBjYW4gYmUgaGFuZGxlZCBhdCB0aGUgdmVyeSBlbmQuXG4gICAgICAgICAgICAgICAgICAgIGFkZEtleWVkUmVtb3ZhbChrZXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVwb3J0IHRoZSBub2RlIGFzIGRpc2NhcmRlZCBpZiBpdCBpcyBub3Qga2V5ZWQuIFdlIGRvIHRoaXMgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBhdCB0aGUgZW5kIHdlIGxvb3AgdGhyb3VnaCBhbGwga2V5ZWQgZWxlbWVudHMgdGhhdCB3ZXJlIHVubWF0Y2hlZFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhlbiBkaXNjYXJkIHRoZW0gaW4gb25lIGZpbmFsIHBhc3MuXG4gICAgICAgICAgICAgICAgICAgIG9uTm9kZURpc2NhcmRlZChjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJDaGlsZC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxrRGlzY2FyZGVkQ2hpbGROb2RlcyhjdXJDaGlsZCwgc2tpcEtleWVkTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBET00gbm9kZSBvdXQgb2YgdGhlIG9yaWdpbmFsIERPTVxuICAgICAqXG4gICAgICogQHBhcmFtICB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmVcbiAgICAgKiBAcGFyYW0gIHtOb2RlfSBwYXJlbnROb2RlIFRoZSBub2RlcyBwYXJlbnRcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBza2lwS2V5ZWROb2RlcyBJZiB0cnVlIHRoZW4gZWxlbWVudHMgd2l0aCBrZXlzIHdpbGwgYmUgc2tpcHBlZCBhbmQgbm90IGRpc2NhcmRlZC5cbiAgICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlLCBwYXJlbnROb2RlLCBza2lwS2V5ZWROb2Rlcykge1xuICAgICAgICBpZiAob25CZWZvcmVOb2RlRGlzY2FyZGVkKG5vZGUpID09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9uTm9kZURpc2NhcmRlZChub2RlKTtcbiAgICAgICAgd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMobm9kZSwgc2tpcEtleWVkTm9kZXMpO1xuICAgIH1cblxuICAgIC8vIC8vIFRyZWVXYWxrZXIgaW1wbGVtZW50YXRpb24gaXMgbm8gZmFzdGVyLCBidXQga2VlcGluZyB0aGlzIGFyb3VuZCBpbiBjYXNlIHRoaXMgY2hhbmdlcyBpbiB0aGUgZnV0dXJlXG4gICAgLy8gZnVuY3Rpb24gaW5kZXhUcmVlKHJvb3QpIHtcbiAgICAvLyAgICAgdmFyIHRyZWVXYWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKFxuICAgIC8vICAgICAgICAgcm9vdCxcbiAgICAvLyAgICAgICAgIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UKTtcbiAgICAvL1xuICAgIC8vICAgICB2YXIgZWw7XG4gICAgLy8gICAgIHdoaWxlKChlbCA9IHRyZWVXYWxrZXIubmV4dE5vZGUoKSkpIHtcbiAgICAvLyAgICAgICAgIHZhciBrZXkgPSBnZXROb2RlS2V5KGVsKTtcbiAgICAvLyAgICAgICAgIGlmIChrZXkpIHtcbiAgICAvLyAgICAgICAgICAgICBmcm9tTm9kZXNMb29rdXBba2V5XSA9IGVsO1xuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICB9XG4gICAgLy8gfVxuXG4gICAgLy8gLy8gTm9kZUl0ZXJhdG9yIGltcGxlbWVudGF0aW9uIGlzIG5vIGZhc3RlciwgYnV0IGtlZXBpbmcgdGhpcyBhcm91bmQgaW4gY2FzZSB0aGlzIGNoYW5nZXMgaW4gdGhlIGZ1dHVyZVxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gaW5kZXhUcmVlKG5vZGUpIHtcbiAgICAvLyAgICAgdmFyIG5vZGVJdGVyYXRvciA9IGRvY3VtZW50LmNyZWF0ZU5vZGVJdGVyYXRvcihub2RlLCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCk7XG4gICAgLy8gICAgIHZhciBlbDtcbiAgICAvLyAgICAgd2hpbGUoKGVsID0gbm9kZUl0ZXJhdG9yLm5leHROb2RlKCkpKSB7XG4gICAgLy8gICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShlbCk7XG4gICAgLy8gICAgICAgICBpZiAoa2V5KSB7XG4gICAgLy8gICAgICAgICAgICAgZnJvbU5vZGVzTG9va3VwW2tleV0gPSBlbDtcbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgfVxuICAgIC8vIH1cblxuICAgIGZ1bmN0aW9uIGluZGV4VHJlZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgdmFyIGN1ckNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGN1ckNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGN1ckNoaWxkLmlkO1xuICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbU5vZGVzTG9va3VwW2tleV0gPSBjdXJDaGlsZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXYWxrIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICAgICAgaW5kZXhUcmVlKGN1ckNoaWxkKTtcblxuICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbmRleFRyZWUoZnJvbU5vZGUpO1xuXG4gICAgZnVuY3Rpb24gYWRkVmlydHVhbE5vZGUodkVsLCBwYXJlbnRFbCkge1xuICAgICAgICB2YXIgcmVhbEVsID0gdkVsLiRfX2FjdHVhbGl6ZShkb2MpO1xuXG4gICAgICAgIGlmIChwYXJlbnRFbCkge1xuICAgICAgICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQocmVhbEVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9uTm9kZUFkZGVkKHJlYWxFbCwgY29udGV4dCk7XG5cbiAgICAgICAgdmFyIHZDdXJDaGlsZCA9IHZFbC5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAodkN1ckNoaWxkKSB7XG4gICAgICAgICAgICB2YXIgcmVhbEN1ckNoaWxkID0gbnVsbDtcblxuICAgICAgICAgICAgdmFyIGtleSA9IHZDdXJDaGlsZC5pZDtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdW5tYXRjaGVkRnJvbUVsID0gZnJvbU5vZGVzTG9va3VwW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHVubWF0Y2hlZEZyb21FbCAmJiBjb21wYXJlTm9kZU5hbWVzKHZDdXJDaGlsZCwgdW5tYXRjaGVkRnJvbUVsKSkge1xuICAgICAgICAgICAgICAgICAgICBtb3JwaEVsKHVubWF0Y2hlZEZyb21FbCwgdkN1ckNoaWxkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlYWxFbC5hcHBlbmRDaGlsZChyZWFsQ3VyQ2hpbGQgPSB1bm1hdGNoZWRGcm9tRWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFyZWFsQ3VyQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICBhZGRWaXJ0dWFsTm9kZSh2Q3VyQ2hpbGQsIHJlYWxFbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZDdXJDaGlsZCA9IHZDdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWFsRWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9ycGhFbChmcm9tRWwsIHRvRWwsIGNoaWxkcmVuT25seSkge1xuXG4gICAgICAgIGlmICghY2hpbGRyZW5Pbmx5KSB7XG4gICAgICAgICAgICB2YXIgdG9FbEtleSA9IHRvRWwuaWQ7XG5cblxuICAgICAgICAgICAgaWYgKHRvRWxLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhbiBlbGVtZW50IHdpdGggYW4gSUQgaXMgYmVpbmcgbW9ycGhlZCB0aGVuIGl0IGlzIHdpbGwgYmUgaW4gdGhlIGZpbmFsXG4gICAgICAgICAgICAgICAgLy8gRE9NIHNvIGNsZWFyIGl0IG91dCBvZiB0aGUgc2F2ZWQgZWxlbWVudHMgY29sbGVjdGlvblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBmcm9tTm9kZXNMb29rdXBbdG9FbEtleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0b05vZGUuJF9faXNTYW1lTm9kZShmcm9tTm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvbkJlZm9yZUVsVXBkYXRlZChmcm9tRWwsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtb3JwaEF0dHJzKGZyb21FbCwgdG9FbCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmIChvbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkKGZyb21FbCwgY29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcm9tRWwubm9kZU5hbWUgIT0gJ1RFWFRBUkVBJykge1xuICAgICAgICAgICAgdmFyIGN1clRvTm9kZUNoaWxkID0gdG9FbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgdmFyIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHZhciBjdXJUb05vZGVLZXk7XG4gICAgICAgICAgICB2YXIgY3VyRnJvbU5vZGVLZXk7XG5cbiAgICAgICAgICAgIHZhciBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB2YXIgdG9OZXh0U2libGluZztcbiAgICAgICAgICAgIHZhciBtYXRjaGluZ0Zyb21FbDtcblxuICAgICAgICAgICAgb3V0ZXI6IHdoaWxlIChjdXJUb05vZGVDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRvTmV4dFNpYmxpbmcgPSBjdXJUb05vZGVDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBjdXJUb05vZGVLZXkgPSBjdXJUb05vZGVDaGlsZC5pZDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJGcm9tTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUNoaWxkLmlzU2FtZU5vZGUgJiYgY3VyVG9Ob2RlQ2hpbGQuaXNTYW1lTm9kZShjdXJGcm9tTm9kZUNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVLZXkgPSBjdXJGcm9tTm9kZUNoaWxkLmlkO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJGcm9tTm9kZVR5cGUgPSBjdXJGcm9tTm9kZUNoaWxkLm5vZGVUeXBlO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0NvbXBhdGlibGUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlVHlwZSA9PSBjdXJUb05vZGVDaGlsZC5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlVHlwZSA9PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCb3RoIG5vZGVzIGJlaW5nIGNvbXBhcmVkIGFyZSBFbGVtZW50IG5vZGVzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0YXJnZXQgbm9kZSBoYXMgYSBrZXkgc28gd2Ugd2FudCB0byBtYXRjaCBpdCB1cCB3aXRoIHRoZSBjb3JyZWN0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVLZXkgIT0gY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlIGRvZXMgbm90IGhhdmUgYSBtYXRjaGluZyBrZXkgc29cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCdzIGNoZWNrIG91ciBsb29rdXAgdG8gc2VlIGlmIHRoZXJlIGlzIGEgbWF0Y2hpbmcgZWxlbWVudCBpbiB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERPTSB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG1hdGNoaW5nRnJvbUVsID0gZnJvbU5vZGVzTG9va3VwW2N1clRvTm9kZUtleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmcgPT0gbWF0Y2hpbmdGcm9tRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBzaW5nbGUgZWxlbWVudCByZW1vdmFscy4gVG8gYXZvaWQgcmVtb3ZpbmcgdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERPTSBub2RlIG91dCBvZiB0aGUgdHJlZSAoc2luY2UgdGhhdCBjYW4gYnJlYWsgQ1NTIHRyYW5zaXRpb25zLCBldGMuKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugd2lsbCBpbnN0ZWFkIGRpc2NhcmQgdGhlIGN1cnJlbnQgbm9kZSBhbmQgd2FpdCB1bnRpbCB0aGUgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRpb24gdG8gcHJvcGVybHkgbWF0Y2ggdXAgdGhlIGtleWVkIHRhcmdldCBlbGVtZW50IHdpdGggaXRzIG1hdGNoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgYSBtYXRjaGluZyBrZXllZCBlbGVtZW50IHNvbWV3aGVyZSBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExldCdzIG1vdmluZyB0aGUgb3JpZ2luYWwgRE9NIG5vZGUgaW50byB0aGUgY3VycmVudCBwb3NpdGlvbiBhbmQgbW9ycGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogV2UgdXNlIGluc2VydEJlZm9yZSBpbnN0ZWFkIG9mIHJlcGxhY2VDaGlsZCBiZWNhdXNlIHdlIHdhbnQgdG8gZ28gdGhyb3VnaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYHJlbW92ZU5vZGUoKWAgZnVuY3Rpb24gZm9yIHRoZSBub2RlIHRoYXQgaXMgYmVpbmcgZGlzY2FyZGVkIHNvIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIGxpZmVjeWNsZSBob29rcyBhcmUgY29ycmVjdGx5IGludm9rZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbUVsLmluc2VydEJlZm9yZShtYXRjaGluZ0Zyb21FbCwgY3VyRnJvbU5vZGVDaGlsZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbU5leHRTaWJsaW5nID0gY3VyRnJvbU5vZGVDaGlsZC5uZXh0U2libGluZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBub2RlIGlzIGtleWVkIGl0IG1pZ2h0IGJlIG1hdGNoZWQgdXAgbGF0ZXIgc28gd2UgZGVmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhY3R1YWwgcmVtb3ZhbCB0byBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdlIHNraXAgbmVzdGVkIGtleWVkIG5vZGVzIGZyb20gYmVpbmcgcmVtb3ZlZCBzaW5jZSB0aGVyZSBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgc3RpbGwgYSBjaGFuY2UgdGhleSB3aWxsIGJlIG1hdGNoZWQgdXAgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCwgZnJvbUVsLCB0cnVlIC8qIHNraXAga2V5ZWQgbm9kZXMgKi8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IG1hdGNoaW5nRnJvbUVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5vZGVzIGFyZSBub3QgY29tcGF0aWJsZSBzaW5jZSB0aGUgXCJ0b1wiIG5vZGUgaGFzIGEga2V5IGFuZCB0aGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIG5vIG1hdGNoaW5nIGtleWVkIG5vZGUgaW4gdGhlIHNvdXJjZSB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvcmlnaW5hbCBoYXMgYSBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gaXNDb21wYXRpYmxlICE9IGZhbHNlICYmIGNvbXBhcmVOb2RlTmFtZXMoY3VyRnJvbU5vZGVDaGlsZCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgY29tcGF0aWJsZSBET00gZWxlbWVudHMgc28gdHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IFwiZnJvbVwiIG5vZGUgdG8gbWF0Y2ggdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFyZ2V0IERPTSBub2RlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3JwaEVsKGN1ckZyb21Ob2RlQ2hpbGQsIGN1clRvTm9kZUNoaWxkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1ckZyb21Ob2RlVHlwZSA9PSBURVhUX05PREUgfHwgY3VyRnJvbU5vZGVUeXBlID09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJvdGggbm9kZXMgYmVpbmcgY29tcGFyZWQgYXJlIFRleHQgb3IgQ29tbWVudCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2ltcGx5IHVwZGF0ZSBub2RlVmFsdWUgb24gdGhlIG9yaWdpbmFsIG5vZGUgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2UgdGhlIHRleHQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkLm5vZGVWYWx1ZSA9IGN1clRvTm9kZUNoaWxkLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgYm90aCB0aGUgXCJ0b1wiIGNoaWxkIGFuZCB0aGUgXCJmcm9tXCIgY2hpbGQgc2luY2Ugd2UgZm91bmQgYSBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gY29tcGF0aWJsZSBtYXRjaCBzbyByZW1vdmUgdGhlIG9sZCBub2RlIGZyb20gdGhlIERPTSBhbmQgY29udGludWUgdHJ5aW5nIHRvIGZpbmQgYVxuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaCBpbiB0aGUgb3JpZ2luYWwgRE9NLiBIb3dldmVyLCB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIGZyb20gbm9kZSBpcyBub3Qga2V5ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgaXQgaXMgcG9zc2libGUgdGhhdCBhIGtleWVkIG5vZGUgbWlnaHQgbWF0Y2ggdXAgd2l0aCBhIG5vZGUgc29tZXdoZXJlIGVsc2UgaW4gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRhcmdldCB0cmVlIGFuZCB3ZSBkb24ndCB3YW50IHRvIGRpc2NhcmQgaXQganVzdCB5ZXQgc2luY2UgaXQgc3RpbGwgbWlnaHQgZmluZCBhXG4gICAgICAgICAgICAgICAgICAgIC8vIGhvbWUgaW4gdGhlIGZpbmFsIERPTSB0cmVlLiBBZnRlciBldmVyeXRoaW5nIGlzIGRvbmUgd2Ugd2lsbCByZW1vdmUgYW55IGtleWVkIG5vZGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgZGlkbid0IGZpbmQgYSBob21lXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIG5vZGUgaXMga2V5ZWQgaXQgbWlnaHQgYmUgbWF0Y2hlZCB1cCBsYXRlciBzbyB3ZSBkZWZlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogd2Ugc2tpcCBuZXN0ZWQga2V5ZWQgbm9kZXMgZnJvbSBiZWluZyByZW1vdmVkIHNpbmNlIHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBzdGlsbCBhIGNoYW5jZSB0aGV5IHdpbGwgYmUgbWF0Y2hlZCB1cCBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUgLyogc2tpcCBrZXllZCBub2RlcyAqLyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGdvdCB0aGlzIGZhciB0aGVuIHdlIGRpZCBub3QgZmluZCBhIGNhbmRpZGF0ZSBtYXRjaCBmb3JcbiAgICAgICAgICAgICAgICAvLyBvdXIgXCJ0byBub2RlXCIgYW5kIHdlIGV4aGF1c3RlZCBhbGwgb2YgdGhlIGNoaWxkcmVuIFwiZnJvbVwiXG4gICAgICAgICAgICAgICAgLy8gbm9kZXMuIFRoZXJlZm9yZSwgd2Ugd2lsbCBqdXN0IGFwcGVuZCB0aGUgY3VycmVudCBcInRvXCIgbm9kZVxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBlbmRcbiAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5ICYmIChtYXRjaGluZ0Zyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtjdXJUb05vZGVLZXldKSAmJiBjb21wYXJlTm9kZU5hbWVzKG1hdGNoaW5nRnJvbUVsLCBjdXJUb05vZGVDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbUVsLmFwcGVuZENoaWxkKG1hdGNoaW5nRnJvbUVsKTtcbiAgICAgICAgICAgICAgICAgICAgbW9ycGhFbChtYXRjaGluZ0Zyb21FbCwgY3VyVG9Ob2RlQ2hpbGQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGRWaXJ0dWFsTm9kZShjdXJUb05vZGVDaGlsZCwgZnJvbUVsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IHRvTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2UgaGF2ZSBwcm9jZXNzZWQgYWxsIG9mIHRoZSBcInRvIG5vZGVzXCIuIElmIGN1ckZyb21Ob2RlQ2hpbGQgaXNcbiAgICAgICAgICAgIC8vIG5vbi1udWxsIHRoZW4gd2Ugc3RpbGwgaGF2ZSBzb21lIGZyb20gbm9kZXMgbGVmdCBvdmVyIHRoYXQgbmVlZFxuICAgICAgICAgICAgLy8gdG8gYmUgcmVtb3ZlZFxuICAgICAgICAgICAgd2hpbGUgKGN1ckZyb21Ob2RlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICBmcm9tTmV4dFNpYmxpbmcgPSBjdXJGcm9tTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGlmICgoY3VyRnJvbU5vZGVLZXkgPSBjdXJGcm9tTm9kZUNoaWxkLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGUgbm9kZSBpcyBrZXllZCBpdCBtaWdodCBiZSBtYXRjaGVkIHVwIGxhdGVyIHNvIHdlIGRlZmVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhY3R1YWwgcmVtb3ZhbCB0byBsYXRlclxuICAgICAgICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdlIHNraXAgbmVzdGVkIGtleWVkIG5vZGVzIGZyb20gYmVpbmcgcmVtb3ZlZCBzaW5jZSB0aGVyZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBzdGlsbCBhIGNoYW5jZSB0aGV5IHdpbGwgYmUgbWF0Y2hlZCB1cCBsYXRlclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQsIGZyb21FbCwgdHJ1ZSAvKiBza2lwIGtleWVkIG5vZGVzICovKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzcGVjaWFsRWxIYW5kbGVyID0gc3BlY2lhbEVsSGFuZGxlcnNbZnJvbUVsLm5vZGVOYW1lXTtcbiAgICAgICAgaWYgKHNwZWNpYWxFbEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHNwZWNpYWxFbEhhbmRsZXIoZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgfVxuICAgIH0gLy8gRU5EOiBtb3JwaEVsKC4uLilcblxuICAgIHZhciBtb3JwaGVkTm9kZSA9IGZyb21Ob2RlO1xuICAgIHZhciBmcm9tTm9kZVR5cGUgPSBtb3JwaGVkTm9kZS5ub2RlVHlwZTtcbiAgICB2YXIgdG9Ob2RlVHlwZSA9IHRvTm9kZS5ub2RlVHlwZTtcbiAgICB2YXIgbW9ycGhDaGlsZHJlbk9ubHkgPSBmYWxzZTtcblxuICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBhcmUgZ2l2ZW4gdHdvIERPTSBub2RlcyB0aGF0IGFyZSBub3RcbiAgICAvLyBjb21wYXRpYmxlIChlLmcuIDxkaXY+IC0tPiA8c3Bhbj4gb3IgPGRpdj4gLS0+IFRFWFQpXG4gICAgaWYgKGZyb21Ob2RlVHlwZSA9PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgaWYgKHRvTm9kZVR5cGUgPT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICBpZiAoIWNvbXBhcmVOb2RlTmFtZXMoZnJvbU5vZGUsIHRvTm9kZSkpIHtcbiAgICAgICAgICAgICAgICBtb3JwaGVkTm9kZSA9IHRvTm9kZS4kX19hY3R1YWxpemUoZG9jKTtcbiAgICAgICAgICAgICAgICByZXBsYWNlQ2hpbGQoZnJvbU5vZGUsIG1vcnBoZWROb2RlKTtcbiAgICAgICAgICAgICAgICBtb3JwaENoaWxkcmVuT25seSA9IHRydWU7XG4gICAgICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKGZyb21Ob2RlKTtcbiAgICAgICAgICAgICAgICB3YWxrRGlzY2FyZGVkQ2hpbGROb2Rlcyhmcm9tTm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBHb2luZyBmcm9tIGFuIGVsZW1lbnQgbm9kZSB0byBhIHRleHQgb3IgY29tbWVudCBub2RlXG4gICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQoZnJvbU5vZGUpO1xuICAgICAgICAgICAgd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMoZnJvbU5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgIG1vcnBoZWROb2RlID0gdG9Ob2RlLiRfX2FjdHVhbGl6ZShkb2MpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VDaGlsZChmcm9tTm9kZSwgbW9ycGhlZE5vZGUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChmcm9tTm9kZVR5cGUgPT0gVEVYVF9OT0RFIHx8IGZyb21Ob2RlVHlwZSA9PSBDT01NRU5UX05PREUpIHsgLy8gVGV4dCBvciBjb21tZW50IG5vZGVcbiAgICAgICAgaWYgKHRvTm9kZVR5cGUgPT0gZnJvbU5vZGVUeXBlKSB7XG4gICAgICAgICAgICBtb3JwaGVkTm9kZS5ub2RlVmFsdWUgPSB0b05vZGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIG1vcnBoZWROb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGV4dCBub2RlIHRvIHNvbWV0aGluZyBlbHNlXG4gICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQoZnJvbU5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VDaGlsZChmcm9tTm9kZSwgYWRkVmlydHVhbE5vZGUodG9Ob2RlKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb3JwaEVsKG1vcnBoZWROb2RlLCB0b05vZGUsIG1vcnBoQ2hpbGRyZW5Pbmx5KTtcblxuICAgIC8vIFdlIG5vdyBuZWVkIHRvIGxvb3Agb3ZlciBhbnkga2V5ZWQgbm9kZXMgdGhhdCBtaWdodCBuZWVkIHRvIGJlXG4gICAgLy8gcmVtb3ZlZC4gV2Ugb25seSBkbyB0aGUgcmVtb3ZhbCBpZiB3ZSBrbm93IHRoYXQgdGhlIGtleWVkIG5vZGVcbiAgICAvLyBuZXZlciBmb3VuZCBhIG1hdGNoLiBXaGVuIGEga2V5ZWQgbm9kZSBpcyBtYXRjaGVkIHVwIHdlIHJlbW92ZVxuICAgIC8vIGl0IG91dCBvZiBmcm9tTm9kZXNMb29rdXAgYW5kIHdlIHVzZSBmcm9tTm9kZXNMb29rdXAgdG8gZGV0ZXJtaW5lXG4gICAgLy8gaWYgYSBrZXllZCBub2RlIGhhcyBiZWVuIG1hdGNoZWQgdXAgb3Igbm90XG4gICAgaWYgKGtleWVkUmVtb3ZhbExpc3QpIHtcbiAgICAgICAga2V5ZWRSZW1vdmFsTGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdmFyIGVsVG9SZW1vdmUgPSBmcm9tTm9kZXNMb29rdXBba2V5XTtcbiAgICAgICAgICAgIGlmIChlbFRvUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShlbFRvUmVtb3ZlLCBlbFRvUmVtb3ZlLnBhcmVudE5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vcnBoZWROb2RlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1vcnBoZG9tO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcmtvL21vcnBoZG9tL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 30 */
/***/ (function(module, exports) {

eval("function syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name, '');\n        }\n    }\n}\n\nmodule.exports = {\n    /**\n     * Needed for IE. Apparently IE doesn't think that \"selected\" is an\n     * attribute when reading over the attributes using selectEl.attributes\n     */\n    OPTION: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value != toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!toEl.$__hasAttribute('value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value != newValue) {\n            fromEl.value = newValue;\n        }\n\n        if (fromEl.firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            if (!newValue && fromEl.firstChild.nodeValue == fromEl.placeholder) {\n                return;\n            }\n\n            fromEl.firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!toEl.$__hasAttribute('multiple')) {\n            var selectedIndex = -1;\n            var i = 0;\n            var curChild = toEl.firstChild;\n            while(curChild) {\n                if (curChild.nodeName == 'OPTION') {\n                    if (curChild.$__hasAttribute('selected')) {\n                        selectedIndex = i;\n                        break;\n                    }\n                    i++;\n                }\n                curChild = curChild.nextSibling;\n            }\n\n            fromEl.selectedIndex = i;\n        }\n    }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL21vcnBoZG9tL3NwZWNpYWxFbEhhbmRsZXJzLmpzPzBiNDciXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsIG5hbWUpIHtcbiAgICBpZiAoZnJvbUVsW25hbWVdICE9PSB0b0VsW25hbWVdKSB7XG4gICAgICAgIGZyb21FbFtuYW1lXSA9IHRvRWxbbmFtZV07XG4gICAgICAgIGlmIChmcm9tRWxbbmFtZV0pIHtcbiAgICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbUVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lLCAnJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qKlxuICAgICAqIE5lZWRlZCBmb3IgSUUuIEFwcGFyZW50bHkgSUUgZG9lc24ndCB0aGluayB0aGF0IFwic2VsZWN0ZWRcIiBpcyBhblxuICAgICAqIGF0dHJpYnV0ZSB3aGVuIHJlYWRpbmcgb3ZlciB0aGUgYXR0cmlidXRlcyB1c2luZyBzZWxlY3RFbC5hdHRyaWJ1dGVzXG4gICAgICovXG4gICAgT1BUSU9OOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsICdzZWxlY3RlZCcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIFwidmFsdWVcIiBhdHRyaWJ1dGUgaXMgc3BlY2lhbCBmb3IgdGhlIDxpbnB1dD4gZWxlbWVudCBzaW5jZSBpdCBzZXRzXG4gICAgICogdGhlIGluaXRpYWwgdmFsdWUuIENoYW5naW5nIHRoZSBcInZhbHVlXCIgYXR0cmlidXRlIHdpdGhvdXQgY2hhbmdpbmcgdGhlXG4gICAgICogXCJ2YWx1ZVwiIHByb3BlcnR5IHdpbGwgaGF2ZSBubyBlZmZlY3Qgc2luY2UgaXQgaXMgb25seSB1c2VkIHRvIHRoZSBzZXQgdGhlXG4gICAgICogaW5pdGlhbCB2YWx1ZS4gIFNpbWlsYXIgZm9yIHRoZSBcImNoZWNrZWRcIiBhdHRyaWJ1dGUsIGFuZCBcImRpc2FibGVkXCIuXG4gICAgICovXG4gICAgSU5QVVQ6IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgJ2NoZWNrZWQnKTtcbiAgICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsICdkaXNhYmxlZCcpO1xuXG4gICAgICAgIGlmIChmcm9tRWwudmFsdWUgIT0gdG9FbC52YWx1ZSkge1xuICAgICAgICAgICAgZnJvbUVsLnZhbHVlID0gdG9FbC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdG9FbC4kX19oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgVEVYVEFSRUE6IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSB0b0VsLnZhbHVlO1xuICAgICAgICBpZiAoZnJvbUVsLnZhbHVlICE9IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBmcm9tRWwudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcm9tRWwuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgLy8gTmVlZGVkIGZvciBJRS4gQXBwYXJlbnRseSBJRSBzZXRzIHRoZSBwbGFjZWhvbGRlciBhcyB0aGVcbiAgICAgICAgICAgIC8vIG5vZGUgdmFsdWUgYW5kIHZpc2UgdmVyc2EuIFRoaXMgaWdub3JlcyBhbiBlbXB0eSB1cGRhdGUuXG4gICAgICAgICAgICBpZiAoIW5ld1ZhbHVlICYmIGZyb21FbC5maXJzdENoaWxkLm5vZGVWYWx1ZSA9PSBmcm9tRWwucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZyb21FbC5maXJzdENoaWxkLm5vZGVWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBTRUxFQ1Q6IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICBpZiAoIXRvRWwuJF9faGFzQXR0cmlidXRlKCdtdWx0aXBsZScpKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgdmFyIGN1ckNoaWxkID0gdG9FbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgd2hpbGUoY3VyQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyQ2hpbGQubm9kZU5hbWUgPT0gJ09QVElPTicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckNoaWxkLiRfX2hhc0F0dHJpYnV0ZSgnc2VsZWN0ZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZyb21FbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWFya28vbW9ycGhkb20vc3BlY2lhbEVsSGFuZGxlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n__webpack_require__(51); // no-op in the browser, but enables extra features on the server\n\nexports.createOut = __webpack_require__(6);\nexports.load = __webpack_require__(32);\nexports.events = __webpack_require__(7);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL3J1bnRpbWUvaW5kZXguanM/YzkwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5yZXF1aXJlKCcuL2Vudi1pbml0Jyk7IC8vIG5vLW9wIGluIHRoZSBicm93c2VyLCBidXQgZW5hYmxlcyBleHRyYSBmZWF0dXJlcyBvbiB0aGUgc2VydmVyXG5cbmV4cG9ydHMuY3JlYXRlT3V0ID0gcmVxdWlyZSgnLi9jcmVhdGVPdXQnKTtcbmV4cG9ydHMubG9hZCA9IHJlcXVpcmUoJy4vbG9hZGVyJyk7XG5leHBvcnRzLmV2ZW50cyA9IHJlcXVpcmUoJy4vZXZlbnRzJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcmtvL3J1bnRpbWUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function load(templatePath) {\n    throw Error('Not found: ' + templatePath);\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL3J1bnRpbWUvbG9hZGVyL2luZGV4LWJyb3dzZXIuanM/NjNlZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxvYWQodGVtcGxhdGVQYXRoKSB7XG4gICAgdGhyb3cgRXJyb3IoJ05vdCBmb3VuZDogJyArIHRlbXBsYXRlUGF0aCk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYXJrby9ydW50aW1lL2xvYWRlci9pbmRleC1icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

eval("var defaultCreateOut = __webpack_require__(6);\nvar extend = __webpack_require__(1);\n\nfunction safeRender(renderFunc, finalData, finalOut, shouldEnd) {\n    try {\n        renderFunc(finalData, finalOut);\n        if (shouldEnd) {\n            finalOut.end();\n        }\n    } catch(err) {\n        setTimeout(function() {\n            finalOut.error(err);\n        }, 0);\n    }\n    return finalOut;\n}\n\nmodule.exports = function(target, renderer) {\n    var renderFunc = renderer && (renderer.renderer || renderer.render || renderer);\n    var createOut = target.createOut || renderer.createOut || defaultCreateOut;\n\n    return extend(target, {\n        createOut: createOut,\n\n        renderToString: function(data, callback) {\n            var localData = data || {};\n            var render = renderFunc || this._;\n            var globalData = localData.$global;\n            var out = createOut(globalData);\n\n            out.global.template = this;\n\n            if (globalData) {\n                localData.$global = undefined;\n            }\n\n            if (callback) {\n                out.on('finish', function() {\n                       callback(null, out.toString(), out);\n                   })\n                   .once('error', callback);\n\n                return safeRender(render, localData, out, true);\n            } else {\n                out.sync();\n                render(localData, out);\n                return out.toString();\n            }\n        },\n\n        renderSync: function(data) {\n            var localData = data || {};\n            var render = renderFunc || this._;\n            var globalData = localData.$global;\n            var out = createOut(globalData);\n            out.sync();\n\n            out.global.template = this;\n\n            if (globalData) {\n                localData.$global = undefined;\n            }\n\n            render(localData, out);\n            return out.$__getResult();\n        },\n\n        /**\n         * Renders a template to either a stream (if the last\n         * argument is a Stream instance) or\n         * provides the output to a callback function (if the last\n         * argument is a Function).\n         *\n         * Supported signatures:\n         *\n         * render(data)\n         * render(data, out)\n         * render(data, stream)\n         * render(data, callback)\n         *\n         * @param  {Object} data The view model data for the template\n         * @param  {AsyncStream/AsyncVDOMBuilder} out A Stream, an AsyncStream/AsyncVDOMBuilder instance, or a callback function\n         * @return {AsyncStream/AsyncVDOMBuilder} Returns the AsyncStream/AsyncVDOMBuilder instance that the template is rendered to\n         */\n        render: function(data, out) {\n            var callback;\n            var finalOut;\n            var finalData;\n            var globalData;\n            var render = renderFunc || this._;\n            var shouldBuffer = this.$__shouldBuffer;\n            var shouldEnd = true;\n\n            if (data) {\n                finalData = data;\n                if ((globalData = data.$global)) {\n                    finalData.$global = undefined;\n                }\n            } else {\n                finalData = {};\n            }\n\n            if (out && out.$__isOut) {\n                finalOut = out;\n                shouldEnd = false;\n                extend(out.global, globalData);\n            } else if (typeof out == 'function') {\n                finalOut = createOut(globalData);\n                callback = out;\n            } else {\n                finalOut = createOut(\n                    globalData, // global\n                    out, // writer(AsyncStream) or parentNode(AsyncVDOMBuilder)\n                    null, // state\n                    shouldBuffer // ignored by AsyncVDOMBuilder\n                );\n            }\n\n            if (callback) {\n                finalOut\n                    .on('finish', function() {\n                        callback(null, finalOut.$__getResult());\n                    })\n                    .once('error', callback);\n            }\n\n            globalData = finalOut.global;\n\n            globalData.template = globalData.template || this;\n\n            return safeRender(render, finalData, finalOut, shouldEnd);\n        }\n    });\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL3J1bnRpbWUvcmVuZGVyYWJsZS5qcz9mMzFiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBkZWZhdWx0Q3JlYXRlT3V0ID0gcmVxdWlyZSgnLi9jcmVhdGVPdXQnKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCdyYXB0b3ItdXRpbC9leHRlbmQnKTtcblxuZnVuY3Rpb24gc2FmZVJlbmRlcihyZW5kZXJGdW5jLCBmaW5hbERhdGEsIGZpbmFsT3V0LCBzaG91bGRFbmQpIHtcbiAgICB0cnkge1xuICAgICAgICByZW5kZXJGdW5jKGZpbmFsRGF0YSwgZmluYWxPdXQpO1xuICAgICAgICBpZiAoc2hvdWxkRW5kKSB7XG4gICAgICAgICAgICBmaW5hbE91dC5lbmQoKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmaW5hbE91dC5lcnJvcihlcnIpO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmFsT3V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgcmVuZGVyZXIpIHtcbiAgICB2YXIgcmVuZGVyRnVuYyA9IHJlbmRlcmVyICYmIChyZW5kZXJlci5yZW5kZXJlciB8fCByZW5kZXJlci5yZW5kZXIgfHwgcmVuZGVyZXIpO1xuICAgIHZhciBjcmVhdGVPdXQgPSB0YXJnZXQuY3JlYXRlT3V0IHx8IHJlbmRlcmVyLmNyZWF0ZU91dCB8fCBkZWZhdWx0Q3JlYXRlT3V0O1xuXG4gICAgcmV0dXJuIGV4dGVuZCh0YXJnZXQsIHtcbiAgICAgICAgY3JlYXRlT3V0OiBjcmVhdGVPdXQsXG5cbiAgICAgICAgcmVuZGVyVG9TdHJpbmc6IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxEYXRhID0gZGF0YSB8fCB7fTtcbiAgICAgICAgICAgIHZhciByZW5kZXIgPSByZW5kZXJGdW5jIHx8IHRoaXMuXztcbiAgICAgICAgICAgIHZhciBnbG9iYWxEYXRhID0gbG9jYWxEYXRhLiRnbG9iYWw7XG4gICAgICAgICAgICB2YXIgb3V0ID0gY3JlYXRlT3V0KGdsb2JhbERhdGEpO1xuXG4gICAgICAgICAgICBvdXQuZ2xvYmFsLnRlbXBsYXRlID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKGdsb2JhbERhdGEpIHtcbiAgICAgICAgICAgICAgICBsb2NhbERhdGEuJGdsb2JhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgb3V0Lm9uKCdmaW5pc2gnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgb3V0LnRvU3RyaW5nKCksIG91dCk7XG4gICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAub25jZSgnZXJyb3InLCBjYWxsYmFjayk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2FmZVJlbmRlcihyZW5kZXIsIGxvY2FsRGF0YSwgb3V0LCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0LnN5bmMoKTtcbiAgICAgICAgICAgICAgICByZW5kZXIobG9jYWxEYXRhLCBvdXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXJTeW5jOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxEYXRhID0gZGF0YSB8fCB7fTtcbiAgICAgICAgICAgIHZhciByZW5kZXIgPSByZW5kZXJGdW5jIHx8IHRoaXMuXztcbiAgICAgICAgICAgIHZhciBnbG9iYWxEYXRhID0gbG9jYWxEYXRhLiRnbG9iYWw7XG4gICAgICAgICAgICB2YXIgb3V0ID0gY3JlYXRlT3V0KGdsb2JhbERhdGEpO1xuICAgICAgICAgICAgb3V0LnN5bmMoKTtcblxuICAgICAgICAgICAgb3V0Lmdsb2JhbC50ZW1wbGF0ZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmIChnbG9iYWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxEYXRhLiRnbG9iYWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlcihsb2NhbERhdGEsIG91dCk7XG4gICAgICAgICAgICByZXR1cm4gb3V0LiRfX2dldFJlc3VsdCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXJzIGEgdGVtcGxhdGUgdG8gZWl0aGVyIGEgc3RyZWFtIChpZiB0aGUgbGFzdFxuICAgICAgICAgKiBhcmd1bWVudCBpcyBhIFN0cmVhbSBpbnN0YW5jZSkgb3JcbiAgICAgICAgICogcHJvdmlkZXMgdGhlIG91dHB1dCB0byBhIGNhbGxiYWNrIGZ1bmN0aW9uIChpZiB0aGUgbGFzdFxuICAgICAgICAgKiBhcmd1bWVudCBpcyBhIEZ1bmN0aW9uKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU3VwcG9ydGVkIHNpZ25hdHVyZXM6XG4gICAgICAgICAqXG4gICAgICAgICAqIHJlbmRlcihkYXRhKVxuICAgICAgICAgKiByZW5kZXIoZGF0YSwgb3V0KVxuICAgICAgICAgKiByZW5kZXIoZGF0YSwgc3RyZWFtKVxuICAgICAgICAgKiByZW5kZXIoZGF0YSwgY2FsbGJhY2spXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gZGF0YSBUaGUgdmlldyBtb2RlbCBkYXRhIGZvciB0aGUgdGVtcGxhdGVcbiAgICAgICAgICogQHBhcmFtICB7QXN5bmNTdHJlYW0vQXN5bmNWRE9NQnVpbGRlcn0gb3V0IEEgU3RyZWFtLCBhbiBBc3luY1N0cmVhbS9Bc3luY1ZET01CdWlsZGVyIGluc3RhbmNlLCBvciBhIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgICAqIEByZXR1cm4ge0FzeW5jU3RyZWFtL0FzeW5jVkRPTUJ1aWxkZXJ9IFJldHVybnMgdGhlIEFzeW5jU3RyZWFtL0FzeW5jVkRPTUJ1aWxkZXIgaW5zdGFuY2UgdGhhdCB0aGUgdGVtcGxhdGUgaXMgcmVuZGVyZWQgdG9cbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24oZGF0YSwgb3V0KSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2s7XG4gICAgICAgICAgICB2YXIgZmluYWxPdXQ7XG4gICAgICAgICAgICB2YXIgZmluYWxEYXRhO1xuICAgICAgICAgICAgdmFyIGdsb2JhbERhdGE7XG4gICAgICAgICAgICB2YXIgcmVuZGVyID0gcmVuZGVyRnVuYyB8fCB0aGlzLl87XG4gICAgICAgICAgICB2YXIgc2hvdWxkQnVmZmVyID0gdGhpcy4kX19zaG91bGRCdWZmZXI7XG4gICAgICAgICAgICB2YXIgc2hvdWxkRW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBmaW5hbERhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGlmICgoZ2xvYmFsRGF0YSA9IGRhdGEuJGdsb2JhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxEYXRhLiRnbG9iYWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaW5hbERhdGEgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG91dCAmJiBvdXQuJF9faXNPdXQpIHtcbiAgICAgICAgICAgICAgICBmaW5hbE91dCA9IG91dDtcbiAgICAgICAgICAgICAgICBzaG91bGRFbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBleHRlbmQob3V0Lmdsb2JhbCwgZ2xvYmFsRGF0YSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGZpbmFsT3V0ID0gY3JlYXRlT3V0KGdsb2JhbERhdGEpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gb3V0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaW5hbE91dCA9IGNyZWF0ZU91dChcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRGF0YSwgLy8gZ2xvYmFsXG4gICAgICAgICAgICAgICAgICAgIG91dCwgLy8gd3JpdGVyKEFzeW5jU3RyZWFtKSBvciBwYXJlbnROb2RlKEFzeW5jVkRPTUJ1aWxkZXIpXG4gICAgICAgICAgICAgICAgICAgIG51bGwsIC8vIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZEJ1ZmZlciAvLyBpZ25vcmVkIGJ5IEFzeW5jVkRPTUJ1aWxkZXJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBmaW5hbE91dFxuICAgICAgICAgICAgICAgICAgICAub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgZmluYWxPdXQuJF9fZ2V0UmVzdWx0KCkpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAub25jZSgnZXJyb3InLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdsb2JhbERhdGEgPSBmaW5hbE91dC5nbG9iYWw7XG5cbiAgICAgICAgICAgIGdsb2JhbERhdGEudGVtcGxhdGUgPSBnbG9iYWxEYXRhLnRlbXBsYXRlIHx8IHRoaXM7XG5cbiAgICAgICAgICAgIHJldHVybiBzYWZlUmVuZGVyKHJlbmRlciwgZmluYWxEYXRhLCBmaW5hbE91dCwgc2hvdWxkRW5kKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYXJrby9ydW50aW1lL3JlbmRlcmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

eval("var EventEmitter = __webpack_require__(4);\nvar vdom = __webpack_require__(39);\nvar VElement = vdom.$__VElement;\nvar VDocumentFragment = vdom.$__VDocumentFragment;\nvar VComment = vdom.$__VComment;\nvar VText = vdom.$__VText;\nvar virtualizeHTML = vdom.$__virtualizeHTML;\nvar RenderResult = __webpack_require__(15);\nvar defaultDocument = vdom.$__defaultDocument;\n\nvar FLAG_FINISHED = 1;\nvar FLAG_LAST_FIRED = 2;\n\nvar EVENT_UPDATE = 'update';\nvar EVENT_FINISH = 'finish';\n\nfunction State(tree) {\n    this.$__remaining = 1;\n    this.$__events = new EventEmitter();\n    this.$__tree = tree;\n    this.$__last = null;\n    this.$__lastCount = 0;\n    this.$__flags = 0;\n}\n\nfunction AsyncVDOMBuilder(globalData, parentNode, state) {\n    if (!parentNode) {\n        parentNode = new VDocumentFragment();\n    }\n\n    if (state) {\n        state.$__remaining++;\n    } else {\n        state = new State(parentNode);\n    }\n\n    this.data = {};\n    this.$__state = state;\n    this.$__parent = parentNode;\n    this.global = globalData || {};\n    this.$__stack = [parentNode];\n    this.$__sync = false;\n    this.$c = null; // Component args\n}\n\nvar proto = AsyncVDOMBuilder.prototype = {\n    $__isOut: true,\n    $__document: defaultDocument,\n\n    element: function(name, attrs, childCount, flags, constId) {\n        var element = new VElement(name, attrs, childCount, flags, constId);\n\n        var parent = this.$__parent;\n\n        if(parent) {\n            parent.$__appendChild(element);\n        }\n\n        return childCount === 0 ? this : element;\n    },\n\n    n: function(node) {\n        // NOTE: We do a shallow clone since we assume the node is being reused\n        //       and a node can only have one parent node.\n        return this.node(node.$__cloneNode());\n    },\n\n    node: function(node) {\n        var parent = this.$__parent;\n        if (parent) {\n            parent.$__appendChild(node);\n        }\n        return this;\n    },\n\n    text: function(text) {\n        var type = typeof text;\n\n        if (type != 'string') {\n            if (text == null) {\n                return;\n            } else if (type == 'object') {\n                if (text.toHTML) {\n                    return this.h(text.toHTML());\n                }\n            }\n\n            text = text.toString();\n        }\n\n        var parent = this.$__parent;\n        if (parent) {\n            var lastChild = parent.lastChild;\n            if (lastChild && lastChild.$__Text) {\n                lastChild.nodeValue += text;\n            } else {\n                parent.$__appendChild(new VText(text));\n            }\n        }\n        return this;\n    },\n\n    comment: function(comment) {\n        return this.node(new VComment(comment));\n    },\n\n    html: function(html) {\n        if (html != null) {\n            var vdomNode = virtualizeHTML(html, this.$__document);\n            this.node(vdomNode);\n        }\n\n        return this;\n    },\n\n    beginElement: function(name, attrs, childCount, flags, constId) {\n        var element = new VElement(name, attrs, childCount, flags, constId);\n        var parent = this.$__parent;\n        if (parent) {\n            parent.$__appendChild(element);\n            this.$__stack.push(element);\n            this.$__parent = element;\n        }\n        return this;\n    },\n\n    endElement: function() {\n        var stack = this.$__stack;\n        stack.pop();\n        this.$__parent = stack[stack.length-1];\n    },\n\n    end: function() {\n        var state = this.$__state;\n\n        this.$__parent = null;\n\n        var remaining = --state.$__remaining;\n\n        if (!(state.$__flags & FLAG_LAST_FIRED) && (remaining - state.$__lastCount === 0)) {\n            state.$__flags |= FLAG_LAST_FIRED;\n            state.$__lastCount = 0;\n            state.$__events.emit('last');\n        }\n\n        if (!remaining) {\n            state.$__flags |= FLAG_FINISHED;\n            state.$__events.emit(EVENT_FINISH, this.$__getResult());\n        }\n\n        return this;\n    },\n\n    error: function(e) {\n        try {\n            this.emit('error', e);\n        } finally {\n            // If there is no listener for the error event then it will\n            // throw a new Error here. In order to ensure that the async fragment\n            // is still properly ended we need to put the end() in a `finally`\n            // block\n            this.end();\n        }\n\n        return this;\n    },\n\n    beginAsync: function(options) {\n        if (this.$__sync) {\n            throw Error('Not allowed');\n        }\n\n        var state = this.$__state;\n\n        if (options) {\n            if (options.last) {\n                state.$__lastCount++;\n            }\n        }\n\n        var documentFragment = this.$__parent.$__appendDocumentFragment();\n        var asyncOut = new AsyncVDOMBuilder(this.global, documentFragment, state);\n\n        state.$__events.emit('beginAsync', {\n           out: asyncOut,\n           parentOut: this\n       });\n\n       return asyncOut;\n    },\n\n    createOut: function(callback) {\n        return new AsyncVDOMBuilder(this.global);\n    },\n\n    flush: function() {\n        var events = this.$__state.$__events;\n\n        if (events.listenerCount(EVENT_UPDATE)) {\n            events.emit(EVENT_UPDATE, new RenderResult(this));\n        }\n    },\n\n    $__getOutput: function() {\n        return this.$__state.$__tree;\n    },\n\n    $__getResult: function() {\n        return this.$__result || (this.$__result = new RenderResult(this));\n    },\n\n    on: function(event, callback) {\n        var state = this.$__state;\n\n        if (event === EVENT_FINISH && (state.$__flags & FLAG_FINISHED)) {\n            callback(this.$__getResult());\n        } else {\n            state.$__events.on(event, callback);\n        }\n\n        return this;\n    },\n\n    once: function(event, callback) {\n        var state = this.$__state;\n\n        if (event === EVENT_FINISH && (state.$__flags & FLAG_FINISHED)) {\n            callback(this.$__getResult());\n            return this;\n        }\n\n        state.$__events.once(event, callback);\n        return this;\n    },\n\n    emit: function(type, arg) {\n        var events = this.$__state.$__events;\n        switch(arguments.length) {\n            case 1:\n                events.emit(type);\n                break;\n            case 2:\n                events.emit(type, arg);\n                break;\n            default:\n                events.emit.apply(events, arguments);\n                break;\n        }\n        return this;\n    },\n\n    removeListener: function() {\n        var events = this.$__state.$__events;\n        events.removeListener.apply(events, arguments);\n        return this;\n    },\n\n    sync: function() {\n        this.$__sync = true;\n    },\n\n    isSync: function() {\n        return this.$__sync;\n    },\n\n    onLast: function(callback) {\n        var state = this.$__state;\n\n        var lastArray = state.$__last;\n\n        if (!lastArray) {\n            lastArray = state.$__last = [];\n            var i = 0;\n            var next = function() {\n                if (i === lastArray.length) {\n                    return;\n                }\n                var _next = lastArray[i++];\n                _next(next);\n            };\n\n            this.once('last', function() {\n                next();\n            });\n        }\n\n        lastArray.push(callback);\n        return this;\n    },\n\n    $__getNode: function(doc) {\n        var node = this.$__VNode;\n        if (!node) {\n            var vdomTree = this.$__getOutput();\n\n            if (!doc) {\n                doc = this.$__document;\n            }\n\n            node = this.$__VNode = vdomTree.actualize(doc);\n        }\n        return node;\n    },\n\n    toString: function() {\n        return this.$__getNode().outerHTML;\n    },\n\n    then: function(fn, fnErr) {\n        var out = this;\n        var promise = new Promise(function(resolve, reject) {\n            out.on('error', reject)\n                .on(EVENT_FINISH, function(result) {\n                    resolve(result);\n                });\n        });\n\n        return Promise.resolve(promise).then(fn, fnErr);\n    },\n\n    catch: function(fnErr) {\n        return this.then(undefined, fnErr);\n    },\n\n    isVDOM: true\n};\n\nproto.e = proto.element;\nproto.be = proto.beginElement;\nproto.ee = proto.endElement;\nproto.t = proto.text;\nproto.h = proto.w = proto.write = proto.html;\n\nmodule.exports = AsyncVDOMBuilder;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL3J1bnRpbWUvdmRvbS9Bc3luY1ZET01CdWlsZGVyLmpzPzUwNmEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cy1saWdodCcpO1xudmFyIHZkb20gPSByZXF1aXJlKCcuL3Zkb20nKTtcbnZhciBWRWxlbWVudCA9IHZkb20uJF9fVkVsZW1lbnQ7XG52YXIgVkRvY3VtZW50RnJhZ21lbnQgPSB2ZG9tLiRfX1ZEb2N1bWVudEZyYWdtZW50O1xudmFyIFZDb21tZW50ID0gdmRvbS4kX19WQ29tbWVudDtcbnZhciBWVGV4dCA9IHZkb20uJF9fVlRleHQ7XG52YXIgdmlydHVhbGl6ZUhUTUwgPSB2ZG9tLiRfX3ZpcnR1YWxpemVIVE1MO1xudmFyIFJlbmRlclJlc3VsdCA9IHJlcXVpcmUoJy4uL1JlbmRlclJlc3VsdCcpO1xudmFyIGRlZmF1bHREb2N1bWVudCA9IHZkb20uJF9fZGVmYXVsdERvY3VtZW50O1xuXG52YXIgRkxBR19GSU5JU0hFRCA9IDE7XG52YXIgRkxBR19MQVNUX0ZJUkVEID0gMjtcblxudmFyIEVWRU5UX1VQREFURSA9ICd1cGRhdGUnO1xudmFyIEVWRU5UX0ZJTklTSCA9ICdmaW5pc2gnO1xuXG5mdW5jdGlvbiBTdGF0ZSh0cmVlKSB7XG4gICAgdGhpcy4kX19yZW1haW5pbmcgPSAxO1xuICAgIHRoaXMuJF9fZXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIHRoaXMuJF9fdHJlZSA9IHRyZWU7XG4gICAgdGhpcy4kX19sYXN0ID0gbnVsbDtcbiAgICB0aGlzLiRfX2xhc3RDb3VudCA9IDA7XG4gICAgdGhpcy4kX19mbGFncyA9IDA7XG59XG5cbmZ1bmN0aW9uIEFzeW5jVkRPTUJ1aWxkZXIoZ2xvYmFsRGF0YSwgcGFyZW50Tm9kZSwgc3RhdGUpIHtcbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgICAgcGFyZW50Tm9kZSA9IG5ldyBWRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBzdGF0ZS4kX19yZW1haW5pbmcrKztcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZSA9IG5ldyBTdGF0ZShwYXJlbnROb2RlKTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICB0aGlzLiRfX3N0YXRlID0gc3RhdGU7XG4gICAgdGhpcy4kX19wYXJlbnQgPSBwYXJlbnROb2RlO1xuICAgIHRoaXMuZ2xvYmFsID0gZ2xvYmFsRGF0YSB8fCB7fTtcbiAgICB0aGlzLiRfX3N0YWNrID0gW3BhcmVudE5vZGVdO1xuICAgIHRoaXMuJF9fc3luYyA9IGZhbHNlO1xuICAgIHRoaXMuJGMgPSBudWxsOyAvLyBDb21wb25lbnQgYXJnc1xufVxuXG52YXIgcHJvdG8gPSBBc3luY1ZET01CdWlsZGVyLnByb3RvdHlwZSA9IHtcbiAgICAkX19pc091dDogdHJ1ZSxcbiAgICAkX19kb2N1bWVudDogZGVmYXVsdERvY3VtZW50LFxuXG4gICAgZWxlbWVudDogZnVuY3Rpb24obmFtZSwgYXR0cnMsIGNoaWxkQ291bnQsIGZsYWdzLCBjb25zdElkKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gbmV3IFZFbGVtZW50KG5hbWUsIGF0dHJzLCBjaGlsZENvdW50LCBmbGFncywgY29uc3RJZCk7XG5cbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuJF9fcGFyZW50O1xuXG4gICAgICAgIGlmKHBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50LiRfX2FwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkQ291bnQgPT09IDAgPyB0aGlzIDogZWxlbWVudDtcbiAgICB9LFxuXG4gICAgbjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAvLyBOT1RFOiBXZSBkbyBhIHNoYWxsb3cgY2xvbmUgc2luY2Ugd2UgYXNzdW1lIHRoZSBub2RlIGlzIGJlaW5nIHJldXNlZFxuICAgICAgICAvLyAgICAgICBhbmQgYSBub2RlIGNhbiBvbmx5IGhhdmUgb25lIHBhcmVudCBub2RlLlxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlKG5vZGUuJF9fY2xvbmVOb2RlKCkpO1xuICAgIH0sXG5cbiAgICBub2RlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLiRfX3BhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50LiRfX2FwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0ZXh0OiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHRleHQ7XG5cbiAgICAgICAgaWYgKHR5cGUgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0ZXh0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGV4dC50b0hUTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaCh0ZXh0LnRvSFRNTCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy4kX19wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBsYXN0Q2hpbGQgPSBwYXJlbnQubGFzdENoaWxkO1xuICAgICAgICAgICAgaWYgKGxhc3RDaGlsZCAmJiBsYXN0Q2hpbGQuJF9fVGV4dCkge1xuICAgICAgICAgICAgICAgIGxhc3RDaGlsZC5ub2RlVmFsdWUgKz0gdGV4dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LiRfX2FwcGVuZENoaWxkKG5ldyBWVGV4dCh0ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNvbW1lbnQ6IGZ1bmN0aW9uKGNvbW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZShuZXcgVkNvbW1lbnQoY29tbWVudCkpO1xuICAgIH0sXG5cbiAgICBodG1sOiBmdW5jdGlvbihodG1sKSB7XG4gICAgICAgIGlmIChodG1sICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB2ZG9tTm9kZSA9IHZpcnR1YWxpemVIVE1MKGh0bWwsIHRoaXMuJF9fZG9jdW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5ub2RlKHZkb21Ob2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBiZWdpbkVsZW1lbnQ6IGZ1bmN0aW9uKG5hbWUsIGF0dHJzLCBjaGlsZENvdW50LCBmbGFncywgY29uc3RJZCkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IG5ldyBWRWxlbWVudChuYW1lLCBhdHRycywgY2hpbGRDb3VudCwgZmxhZ3MsIGNvbnN0SWQpO1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy4kX19wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC4kX19hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuJF9fc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuJF9fcGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZW5kRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFjayA9IHRoaXMuJF9fc3RhY2s7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLiRfX3BhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXTtcbiAgICB9LFxuXG4gICAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy4kX19zdGF0ZTtcblxuICAgICAgICB0aGlzLiRfX3BhcmVudCA9IG51bGw7XG5cbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IC0tc3RhdGUuJF9fcmVtYWluaW5nO1xuXG4gICAgICAgIGlmICghKHN0YXRlLiRfX2ZsYWdzICYgRkxBR19MQVNUX0ZJUkVEKSAmJiAocmVtYWluaW5nIC0gc3RhdGUuJF9fbGFzdENvdW50ID09PSAwKSkge1xuICAgICAgICAgICAgc3RhdGUuJF9fZmxhZ3MgfD0gRkxBR19MQVNUX0ZJUkVEO1xuICAgICAgICAgICAgc3RhdGUuJF9fbGFzdENvdW50ID0gMDtcbiAgICAgICAgICAgIHN0YXRlLiRfX2V2ZW50cy5lbWl0KCdsYXN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlbWFpbmluZykge1xuICAgICAgICAgICAgc3RhdGUuJF9fZmxhZ3MgfD0gRkxBR19GSU5JU0hFRDtcbiAgICAgICAgICAgIHN0YXRlLiRfX2V2ZW50cy5lbWl0KEVWRU5UX0ZJTklTSCwgdGhpcy4kX19nZXRSZXN1bHQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZXJyb3I6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGxpc3RlbmVyIGZvciB0aGUgZXJyb3IgZXZlbnQgdGhlbiBpdCB3aWxsXG4gICAgICAgICAgICAvLyB0aHJvdyBhIG5ldyBFcnJvciBoZXJlLiBJbiBvcmRlciB0byBlbnN1cmUgdGhhdCB0aGUgYXN5bmMgZnJhZ21lbnRcbiAgICAgICAgICAgIC8vIGlzIHN0aWxsIHByb3Blcmx5IGVuZGVkIHdlIG5lZWQgdG8gcHV0IHRoZSBlbmQoKSBpbiBhIGBmaW5hbGx5YFxuICAgICAgICAgICAgLy8gYmxvY2tcbiAgICAgICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYmVnaW5Bc3luYzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy4kX19zeW5jKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignTm90IGFsbG93ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuJF9fc3RhdGU7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxhc3QpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS4kX19sYXN0Q291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkb2N1bWVudEZyYWdtZW50ID0gdGhpcy4kX19wYXJlbnQuJF9fYXBwZW5kRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICB2YXIgYXN5bmNPdXQgPSBuZXcgQXN5bmNWRE9NQnVpbGRlcih0aGlzLmdsb2JhbCwgZG9jdW1lbnRGcmFnbWVudCwgc3RhdGUpO1xuXG4gICAgICAgIHN0YXRlLiRfX2V2ZW50cy5lbWl0KCdiZWdpbkFzeW5jJywge1xuICAgICAgICAgICBvdXQ6IGFzeW5jT3V0LFxuICAgICAgICAgICBwYXJlbnRPdXQ6IHRoaXNcbiAgICAgICB9KTtcblxuICAgICAgIHJldHVybiBhc3luY091dDtcbiAgICB9LFxuXG4gICAgY3JlYXRlT3V0OiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gbmV3IEFzeW5jVkRPTUJ1aWxkZXIodGhpcy5nbG9iYWwpO1xuICAgIH0sXG5cbiAgICBmbHVzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLiRfX3N0YXRlLiRfX2V2ZW50cztcblxuICAgICAgICBpZiAoZXZlbnRzLmxpc3RlbmVyQ291bnQoRVZFTlRfVVBEQVRFKSkge1xuICAgICAgICAgICAgZXZlbnRzLmVtaXQoRVZFTlRfVVBEQVRFLCBuZXcgUmVuZGVyUmVzdWx0KHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAkX19nZXRPdXRwdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kX19zdGF0ZS4kX190cmVlO1xuICAgIH0sXG5cbiAgICAkX19nZXRSZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kX19yZXN1bHQgfHwgKHRoaXMuJF9fcmVzdWx0ID0gbmV3IFJlbmRlclJlc3VsdCh0aGlzKSk7XG4gICAgfSxcblxuICAgIG9uOiBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy4kX19zdGF0ZTtcblxuICAgICAgICBpZiAoZXZlbnQgPT09IEVWRU5UX0ZJTklTSCAmJiAoc3RhdGUuJF9fZmxhZ3MgJiBGTEFHX0ZJTklTSEVEKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sodGhpcy4kX19nZXRSZXN1bHQoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS4kX19ldmVudHMub24oZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBvbmNlOiBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy4kX19zdGF0ZTtcblxuICAgICAgICBpZiAoZXZlbnQgPT09IEVWRU5UX0ZJTklTSCAmJiAoc3RhdGUuJF9fZmxhZ3MgJiBGTEFHX0ZJTklTSEVEKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sodGhpcy4kX19nZXRSZXN1bHQoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLiRfX2V2ZW50cy5vbmNlKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuJF9fc3RhdGUuJF9fZXZlbnRzO1xuICAgICAgICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGV2ZW50cy5lbWl0KHR5cGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGV2ZW50cy5lbWl0KHR5cGUsIGFyZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGV2ZW50cy5lbWl0LmFwcGx5KGV2ZW50cywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy4kX19zdGF0ZS4kX19ldmVudHM7XG4gICAgICAgIGV2ZW50cy5yZW1vdmVMaXN0ZW5lci5hcHBseShldmVudHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzeW5jOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy4kX19zeW5jID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgaXNTeW5jOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJF9fc3luYztcbiAgICB9LFxuXG4gICAgb25MYXN0OiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLiRfX3N0YXRlO1xuXG4gICAgICAgIHZhciBsYXN0QXJyYXkgPSBzdGF0ZS4kX19sYXN0O1xuXG4gICAgICAgIGlmICghbGFzdEFycmF5KSB7XG4gICAgICAgICAgICBsYXN0QXJyYXkgPSBzdGF0ZS4kX19sYXN0ID0gW107XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBsYXN0QXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIF9uZXh0ID0gbGFzdEFycmF5W2krK107XG4gICAgICAgICAgICAgICAgX25leHQobmV4dCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLm9uY2UoJ2xhc3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RBcnJheS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgICRfX2dldE5vZGU6IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuJF9fVk5vZGU7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgdmFyIHZkb21UcmVlID0gdGhpcy4kX19nZXRPdXRwdXQoKTtcblxuICAgICAgICAgICAgaWYgKCFkb2MpIHtcbiAgICAgICAgICAgICAgICBkb2MgPSB0aGlzLiRfX2RvY3VtZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gdGhpcy4kX19WTm9kZSA9IHZkb21UcmVlLmFjdHVhbGl6ZShkb2MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRfX2dldE5vZGUoKS5vdXRlckhUTUw7XG4gICAgfSxcblxuICAgIHRoZW46IGZ1bmN0aW9uKGZuLCBmbkVycikge1xuICAgICAgICB2YXIgb3V0ID0gdGhpcztcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIG91dC5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgICAgICAgICAgLm9uKEVWRU5UX0ZJTklTSCwgZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcm9taXNlKS50aGVuKGZuLCBmbkVycik7XG4gICAgfSxcblxuICAgIGNhdGNoOiBmdW5jdGlvbihmbkVycikge1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgZm5FcnIpO1xuICAgIH0sXG5cbiAgICBpc1ZET006IHRydWVcbn07XG5cbnByb3RvLmUgPSBwcm90by5lbGVtZW50O1xucHJvdG8uYmUgPSBwcm90by5iZWdpbkVsZW1lbnQ7XG5wcm90by5lZSA9IHByb3RvLmVuZEVsZW1lbnQ7XG5wcm90by50ID0gcHJvdG8udGV4dDtcbnByb3RvLmggPSBwcm90by53ID0gcHJvdG8ud3JpdGUgPSBwcm90by5odG1sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFzeW5jVkRPTUJ1aWxkZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWFya28vcnVudGltZS92ZG9tL0FzeW5jVkRPTUJ1aWxkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

eval("var VNode = __webpack_require__(3);\nvar inherit = __webpack_require__(2);\n\nfunction VComment(value) {\n    this.$__VNode(-1 /* no children */);\n    this.nodeValue = value;\n}\n\nVComment.prototype = {\n    nodeType: 8,\n\n    $__actualize: function(doc) {\n        return doc.createComment(this.nodeValue);\n    },\n\n    $__cloneNode: function() {\n        return new VComment(this.nodeValue);\n    }\n};\n\ninherit(VComment, VNode);\n\nmodule.exports = VComment;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL3J1bnRpbWUvdmRvbS9WQ29tbWVudC5qcz9jOTY1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBWTm9kZSA9IHJlcXVpcmUoJy4vVk5vZGUnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgncmFwdG9yLXV0aWwvaW5oZXJpdCcpO1xuXG5mdW5jdGlvbiBWQ29tbWVudCh2YWx1ZSkge1xuICAgIHRoaXMuJF9fVk5vZGUoLTEgLyogbm8gY2hpbGRyZW4gKi8pO1xuICAgIHRoaXMubm9kZVZhbHVlID0gdmFsdWU7XG59XG5cblZDb21tZW50LnByb3RvdHlwZSA9IHtcbiAgICBub2RlVHlwZTogOCxcblxuICAgICRfX2FjdHVhbGl6ZTogZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIHJldHVybiBkb2MuY3JlYXRlQ29tbWVudCh0aGlzLm5vZGVWYWx1ZSk7XG4gICAgfSxcblxuICAgICRfX2Nsb25lTm9kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgVkNvbW1lbnQodGhpcy5ub2RlVmFsdWUpO1xuICAgIH1cbn07XG5cbmluaGVyaXQoVkNvbW1lbnQsIFZOb2RlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWQ29tbWVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYXJrby9ydW50aW1lL3Zkb20vVkNvbW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

eval("var VNode = __webpack_require__(3);\nvar inherit = __webpack_require__(2);\nvar extend = __webpack_require__(1);\n\nfunction VDocumentFragmentClone(other) {\n    extend(this, other);\n    this.$__parentNode = null;\n    this.$__nextSibling = null;\n}\n\nfunction VDocumentFragment(documentFragment) {\n    this.$__VNode(null /* childCount */);\n    this.namespaceURI = null;\n}\n\nVDocumentFragment.prototype = {\n    nodeType: 11,\n\n    $__DocumentFragment: true,\n\n    $__cloneNode: function() {\n        return new VDocumentFragmentClone(this);\n    },\n\n    $__actualize: function(doc) {\n        return doc.createDocumentFragment();\n    }\n};\n\ninherit(VDocumentFragment, VNode);\n\nVDocumentFragmentClone.prototype = VDocumentFragment.prototype;\n\nmodule.exports = VDocumentFragment;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL3J1bnRpbWUvdmRvbS9WRG9jdW1lbnRGcmFnbWVudC5qcz8xYmZlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBWTm9kZSA9IHJlcXVpcmUoJy4vVk5vZGUnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgncmFwdG9yLXV0aWwvaW5oZXJpdCcpO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3JhcHRvci11dGlsL2V4dGVuZCcpO1xuXG5mdW5jdGlvbiBWRG9jdW1lbnRGcmFnbWVudENsb25lKG90aGVyKSB7XG4gICAgZXh0ZW5kKHRoaXMsIG90aGVyKTtcbiAgICB0aGlzLiRfX3BhcmVudE5vZGUgPSBudWxsO1xuICAgIHRoaXMuJF9fbmV4dFNpYmxpbmcgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBWRG9jdW1lbnRGcmFnbWVudChkb2N1bWVudEZyYWdtZW50KSB7XG4gICAgdGhpcy4kX19WTm9kZShudWxsIC8qIGNoaWxkQ291bnQgKi8pO1xuICAgIHRoaXMubmFtZXNwYWNlVVJJID0gbnVsbDtcbn1cblxuVkRvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlID0ge1xuICAgIG5vZGVUeXBlOiAxMSxcblxuICAgICRfX0RvY3VtZW50RnJhZ21lbnQ6IHRydWUsXG5cbiAgICAkX19jbG9uZU5vZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZEb2N1bWVudEZyYWdtZW50Q2xvbmUodGhpcyk7XG4gICAgfSxcblxuICAgICRfX2FjdHVhbGl6ZTogZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIHJldHVybiBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIH1cbn07XG5cbmluaGVyaXQoVkRvY3VtZW50RnJhZ21lbnQsIFZOb2RlKTtcblxuVkRvY3VtZW50RnJhZ21lbnRDbG9uZS5wcm90b3R5cGUgPSBWRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gVkRvY3VtZW50RnJhZ21lbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWFya28vcnVudGltZS92ZG9tL1ZEb2N1bWVudEZyYWdtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

eval("var VNode = __webpack_require__(3);\nvar inherit = __webpack_require__(2);\n\nfunction VText(value) {\n    this.$__VNode(-1 /* no children */);\n    this.nodeValue = value;\n}\n\nVText.prototype = {\n    $__Text: true,\n\n    nodeType: 3,\n\n    $__actualize: function(doc) {\n        return doc.createTextNode(this.nodeValue);\n    },\n\n    $__cloneNode: function() {\n        return new VText(this.nodeValue);\n    }\n};\n\ninherit(VText, VNode);\n\nmodule.exports = VText;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL3J1bnRpbWUvdmRvbS9WVGV4dC5qcz9hYjI5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBWTm9kZSA9IHJlcXVpcmUoJy4vVk5vZGUnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgncmFwdG9yLXV0aWwvaW5oZXJpdCcpO1xuXG5mdW5jdGlvbiBWVGV4dCh2YWx1ZSkge1xuICAgIHRoaXMuJF9fVk5vZGUoLTEgLyogbm8gY2hpbGRyZW4gKi8pO1xuICAgIHRoaXMubm9kZVZhbHVlID0gdmFsdWU7XG59XG5cblZUZXh0LnByb3RvdHlwZSA9IHtcbiAgICAkX19UZXh0OiB0cnVlLFxuXG4gICAgbm9kZVR5cGU6IDMsXG5cbiAgICAkX19hY3R1YWxpemU6IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICByZXR1cm4gZG9jLmNyZWF0ZVRleHROb2RlKHRoaXMubm9kZVZhbHVlKTtcbiAgICB9LFxuXG4gICAgJF9fY2xvbmVOb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWVGV4dCh0aGlzLm5vZGVWYWx1ZSk7XG4gICAgfVxufTtcblxuaW5oZXJpdChWVGV4dCwgVk5vZGUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZUZXh0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcmtvL3J1bnRpbWUvdmRvbS9WVGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// helpers provide a core set of various utility methods\n// that are available in every template\nvar AsyncVDOMBuilder = __webpack_require__(34);\nvar makeRenderable = __webpack_require__(33);\n\n/**\n * Method is for internal usage only. This method\n * is invoked by code in a compiled Marko template and\n * it is used to create a new Template instance.\n * @private\n */\nexports.t = function createTemplate(path) {\n     return new Template(path);\n};\n\nfunction Template(path, func) {\n    this.path = path;\n    this._ = func;\n    this.meta = undefined;\n}\n\nfunction createOut(globalData, parent, state) {\n    return new AsyncVDOMBuilder(globalData, parent, state);\n}\n\nvar Template_prototype = Template.prototype = {\n    createOut: createOut\n};\n\nmakeRenderable(Template_prototype);\n\nexports.Template = Template;\nexports.$__createOut = createOut;\n\n__webpack_require__(6).$__setCreateOut(createOut);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL3J1bnRpbWUvdmRvbS9pbmRleC5qcz9jMmU0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIGhlbHBlcnMgcHJvdmlkZSBhIGNvcmUgc2V0IG9mIHZhcmlvdXMgdXRpbGl0eSBtZXRob2RzXG4vLyB0aGF0IGFyZSBhdmFpbGFibGUgaW4gZXZlcnkgdGVtcGxhdGVcbnZhciBBc3luY1ZET01CdWlsZGVyID0gcmVxdWlyZSgnLi9Bc3luY1ZET01CdWlsZGVyJyk7XG52YXIgbWFrZVJlbmRlcmFibGUgPSByZXF1aXJlKCcuLi9yZW5kZXJhYmxlJyk7XG5cbi8qKlxuICogTWV0aG9kIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5LiBUaGlzIG1ldGhvZFxuICogaXMgaW52b2tlZCBieSBjb2RlIGluIGEgY29tcGlsZWQgTWFya28gdGVtcGxhdGUgYW5kXG4gKiBpdCBpcyB1c2VkIHRvIGNyZWF0ZSBhIG5ldyBUZW1wbGF0ZSBpbnN0YW5jZS5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMudCA9IGZ1bmN0aW9uIGNyZWF0ZVRlbXBsYXRlKHBhdGgpIHtcbiAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZShwYXRoKTtcbn07XG5cbmZ1bmN0aW9uIFRlbXBsYXRlKHBhdGgsIGZ1bmMpIHtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuXyA9IGZ1bmM7XG4gICAgdGhpcy5tZXRhID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPdXQoZ2xvYmFsRGF0YSwgcGFyZW50LCBzdGF0ZSkge1xuICAgIHJldHVybiBuZXcgQXN5bmNWRE9NQnVpbGRlcihnbG9iYWxEYXRhLCBwYXJlbnQsIHN0YXRlKTtcbn1cblxudmFyIFRlbXBsYXRlX3Byb3RvdHlwZSA9IFRlbXBsYXRlLnByb3RvdHlwZSA9IHtcbiAgICBjcmVhdGVPdXQ6IGNyZWF0ZU91dFxufTtcblxubWFrZVJlbmRlcmFibGUoVGVtcGxhdGVfcHJvdG90eXBlKTtcblxuZXhwb3J0cy5UZW1wbGF0ZSA9IFRlbXBsYXRlO1xuZXhwb3J0cy4kX19jcmVhdGVPdXQgPSBjcmVhdGVPdXQ7XG5cbnJlcXVpcmUoJy4uL2NyZWF0ZU91dCcpLiRfX3NldENyZWF0ZU91dChjcmVhdGVPdXQpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcmtvL3J1bnRpbWUvdmRvbS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

eval("var VNode = __webpack_require__(3);\nvar VComment = __webpack_require__(35);\nvar VDocumentFragment = __webpack_require__(36);\nvar VElement = __webpack_require__(17);\nvar VText = __webpack_require__(37);\nvar FLAG_IS_TEXTAREA = 2;\n\nvar defaultDocument = typeof document != 'undefined' && document;\n\nvar FLAG_IS_TEXTAREA = 2;\n\nvar specialHtmlRegexp = /[&<]/;\n\nfunction virtualizeChildNodes(node, vdomParent) {\n    var curChild = node.firstChild;\n    while(curChild) {\n        vdomParent.$__appendChild(virtualize(curChild));\n        curChild = curChild.nextSibling;\n    }\n}\n\nfunction virtualize(node) {\n    switch(node.nodeType) {\n        case 1:\n            var attributes = node.attributes;\n            var attrCount = attributes.length;\n\n            var attrs;\n\n            if (attrCount) {\n                attrs = {};\n\n                for (var i=0; i<attrCount; i++) {\n                    var attr = attributes[i];\n                    attrs[attr.name] = attr.value;\n                }\n            }\n\n            var flags = 0;\n\n            var tagName = node.nodeName;\n            if (tagName === 'TEXTAREA') {\n                flags |= FLAG_IS_TEXTAREA;\n            }\n\n            var vdomEl = new VElement(tagName, attrs, null, flags);\n            vdomEl.$__namespaceURI = node.namespaceURI;\n\n            if (vdomEl.$__isTextArea) {\n                vdomEl.$__value = node.value;\n            } else {\n                virtualizeChildNodes(node, vdomEl);\n            }\n\n            return vdomEl;\n        case 3:\n            return new VText(node.nodeValue);\n        case 8:\n            return new VComment(node.nodeValue);\n        case 11:\n            var vdomDocFragment = new VDocumentFragment();\n            virtualizeChildNodes(node, vdomDocFragment);\n            return vdomDocFragment;\n    }\n}\n\nfunction virtualizeHTML(html, doc) {\n    if (!specialHtmlRegexp.test(html)) {\n        return new VText(html);\n    }\n\n    var container = doc.createElement('body');\n    container.innerHTML = html;\n    var vdomFragment = new VDocumentFragment();\n\n    var curChild = container.firstChild;\n    while(curChild) {\n        vdomFragment.$__appendChild(virtualize(curChild));\n        curChild = curChild.nextSibling;\n    }\n\n    return vdomFragment;\n}\n\nvar Node_prototype = VNode.prototype;\n\n/**\n * Shorthand method for creating and appending a Text node with a given value\n * @param  {String} value The text value for the new Text node\n */\nNode_prototype.t = function(value) {\n    var type = typeof value;\n    var vdomNode;\n\n    if (type !== 'string') {\n        if (value == null) {\n            value = '';\n        } else if (type === 'object') {\n            if (value.toHTML) {\n                vdomNode = virtualizeHTML(value.toHTML(), document);\n            }\n        }\n    }\n\n    this.$__appendChild(vdomNode || new VText(value.toString()));\n    return this.$__finishChild();\n};\n\n/**\n * Shorthand method for creating and appending a Comment node with a given value\n * @param  {String} value The value for the new Comment node\n */\nNode_prototype.c = function(value) {\n    this.$__appendChild(new VComment(value));\n    return this.$__finishChild();\n};\n\nNode_prototype.$__appendDocumentFragment = function() {\n    return this.$__appendChild(new VDocumentFragment());\n};\n\nexports.$__VComment = VComment;\nexports.$__VDocumentFragment = VDocumentFragment;\nexports.$__VElement = VElement;\nexports.$__VText = VText;\nexports.$__virtualize = virtualize;\nexports.$__virtualizeHTML = virtualizeHTML;\nexports.$__defaultDocument = defaultDocument;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL3J1bnRpbWUvdmRvbS92ZG9tLmpzPzIwYTIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFZOb2RlID0gcmVxdWlyZSgnLi9WTm9kZScpO1xudmFyIFZDb21tZW50ID0gcmVxdWlyZSgnLi9WQ29tbWVudCcpO1xudmFyIFZEb2N1bWVudEZyYWdtZW50ID0gcmVxdWlyZSgnLi9WRG9jdW1lbnRGcmFnbWVudCcpO1xudmFyIFZFbGVtZW50ID0gcmVxdWlyZSgnLi9WRWxlbWVudCcpO1xudmFyIFZUZXh0ID0gcmVxdWlyZSgnLi9WVGV4dCcpO1xudmFyIEZMQUdfSVNfVEVYVEFSRUEgPSAyO1xuXG52YXIgZGVmYXVsdERvY3VtZW50ID0gdHlwZW9mIGRvY3VtZW50ICE9ICd1bmRlZmluZWQnICYmIGRvY3VtZW50O1xuXG52YXIgRkxBR19JU19URVhUQVJFQSA9IDI7XG5cbnZhciBzcGVjaWFsSHRtbFJlZ2V4cCA9IC9bJjxdLztcblxuZnVuY3Rpb24gdmlydHVhbGl6ZUNoaWxkTm9kZXMobm9kZSwgdmRvbVBhcmVudCkge1xuICAgIHZhciBjdXJDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICB3aGlsZShjdXJDaGlsZCkge1xuICAgICAgICB2ZG9tUGFyZW50LiRfX2FwcGVuZENoaWxkKHZpcnR1YWxpemUoY3VyQ2hpbGQpKTtcbiAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHZpcnR1YWxpemUobm9kZSkge1xuICAgIHN3aXRjaChub2RlLm5vZGVUeXBlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgdmFyIGF0dHJDb3VudCA9IGF0dHJpYnV0ZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICB2YXIgYXR0cnM7XG5cbiAgICAgICAgICAgIGlmIChhdHRyQ291bnQpIHtcbiAgICAgICAgICAgICAgICBhdHRycyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGF0dHJDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyID0gYXR0cmlidXRlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnNbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSAwO1xuXG4gICAgICAgICAgICB2YXIgdGFnTmFtZSA9IG5vZGUubm9kZU5hbWU7XG4gICAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xuICAgICAgICAgICAgICAgIGZsYWdzIHw9IEZMQUdfSVNfVEVYVEFSRUE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2ZG9tRWwgPSBuZXcgVkVsZW1lbnQodGFnTmFtZSwgYXR0cnMsIG51bGwsIGZsYWdzKTtcbiAgICAgICAgICAgIHZkb21FbC4kX19uYW1lc3BhY2VVUkkgPSBub2RlLm5hbWVzcGFjZVVSSTtcblxuICAgICAgICAgICAgaWYgKHZkb21FbC4kX19pc1RleHRBcmVhKSB7XG4gICAgICAgICAgICAgICAgdmRvbUVsLiRfX3ZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmlydHVhbGl6ZUNoaWxkTm9kZXMobm9kZSwgdmRvbUVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZkb21FbDtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWVGV4dChub2RlLm5vZGVWYWx1ZSk7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVkNvbW1lbnQobm9kZS5ub2RlVmFsdWUpO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgdmFyIHZkb21Eb2NGcmFnbWVudCA9IG5ldyBWRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgdmlydHVhbGl6ZUNoaWxkTm9kZXMobm9kZSwgdmRvbURvY0ZyYWdtZW50KTtcbiAgICAgICAgICAgIHJldHVybiB2ZG9tRG9jRnJhZ21lbnQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2aXJ0dWFsaXplSFRNTChodG1sLCBkb2MpIHtcbiAgICBpZiAoIXNwZWNpYWxIdG1sUmVnZXhwLnRlc3QoaHRtbCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWVGV4dChodG1sKTtcbiAgICB9XG5cbiAgICB2YXIgY29udGFpbmVyID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2JvZHknKTtcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB2YXIgdmRvbUZyYWdtZW50ID0gbmV3IFZEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICB2YXIgY3VyQ2hpbGQgPSBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICB3aGlsZShjdXJDaGlsZCkge1xuICAgICAgICB2ZG9tRnJhZ21lbnQuJF9fYXBwZW5kQ2hpbGQodmlydHVhbGl6ZShjdXJDaGlsZCkpO1xuICAgICAgICBjdXJDaGlsZCA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgIH1cblxuICAgIHJldHVybiB2ZG9tRnJhZ21lbnQ7XG59XG5cbnZhciBOb2RlX3Byb3RvdHlwZSA9IFZOb2RlLnByb3RvdHlwZTtcblxuLyoqXG4gKiBTaG9ydGhhbmQgbWV0aG9kIGZvciBjcmVhdGluZyBhbmQgYXBwZW5kaW5nIGEgVGV4dCBub2RlIHdpdGggYSBnaXZlbiB2YWx1ZVxuICogQHBhcmFtICB7U3RyaW5nfSB2YWx1ZSBUaGUgdGV4dCB2YWx1ZSBmb3IgdGhlIG5ldyBUZXh0IG5vZGVcbiAqL1xuTm9kZV9wcm90b3R5cGUudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgdmFyIHZkb21Ob2RlO1xuXG4gICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUudG9IVE1MKSB7XG4gICAgICAgICAgICAgICAgdmRvbU5vZGUgPSB2aXJ0dWFsaXplSFRNTCh2YWx1ZS50b0hUTUwoKSwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy4kX19hcHBlbmRDaGlsZCh2ZG9tTm9kZSB8fCBuZXcgVlRleHQodmFsdWUudG9TdHJpbmcoKSkpO1xuICAgIHJldHVybiB0aGlzLiRfX2ZpbmlzaENoaWxkKCk7XG59O1xuXG4vKipcbiAqIFNob3J0aGFuZCBtZXRob2QgZm9yIGNyZWF0aW5nIGFuZCBhcHBlbmRpbmcgYSBDb21tZW50IG5vZGUgd2l0aCBhIGdpdmVuIHZhbHVlXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSBmb3IgdGhlIG5ldyBDb21tZW50IG5vZGVcbiAqL1xuTm9kZV9wcm90b3R5cGUuYyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy4kX19hcHBlbmRDaGlsZChuZXcgVkNvbW1lbnQodmFsdWUpKTtcbiAgICByZXR1cm4gdGhpcy4kX19maW5pc2hDaGlsZCgpO1xufTtcblxuTm9kZV9wcm90b3R5cGUuJF9fYXBwZW5kRG9jdW1lbnRGcmFnbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiRfX2FwcGVuZENoaWxkKG5ldyBWRG9jdW1lbnRGcmFnbWVudCgpKTtcbn07XG5cbmV4cG9ydHMuJF9fVkNvbW1lbnQgPSBWQ29tbWVudDtcbmV4cG9ydHMuJF9fVkRvY3VtZW50RnJhZ21lbnQgPSBWRG9jdW1lbnRGcmFnbWVudDtcbmV4cG9ydHMuJF9fVkVsZW1lbnQgPSBWRWxlbWVudDtcbmV4cG9ydHMuJF9fVlRleHQgPSBWVGV4dDtcbmV4cG9ydHMuJF9fdmlydHVhbGl6ZSA9IHZpcnR1YWxpemU7XG5leHBvcnRzLiRfX3ZpcnR1YWxpemVIVE1MID0gdmlydHVhbGl6ZUhUTUw7XG5leHBvcnRzLiRfX2RlZmF1bHREb2N1bWVudCA9IGRlZmF1bHREb2N1bWVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYXJrby9ydW50aW1lL3Zkb20vdmRvbS5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(38);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtvL3Zkb20uanM/OTg4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcnVudGltZS92ZG9tJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcmtvL3Zkb20uanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(self.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [],\n\tfixUrls = __webpack_require__(42);\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\toptions.attrs.type = \"text/css\";\n\n\tattachTagAttrs(styleElement, options.attrs);\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction createLinkElement(options) {\n\tvar linkElement = document.createElement(\"link\");\n\toptions.attrs.type = \"text/css\";\n\toptions.attrs.rel = \"stylesheet\";\n\n\tattachTagAttrs(linkElement, options.attrs);\n\tinsertStyleElement(options, linkElement);\n\treturn linkElement;\n}\n\nfunction attachTagAttrs(element, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\telement.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else if(obj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\") {\n\t\tstyleElement = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, styleElement, options);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t\tif(styleElement.href)\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\n\t\t};\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyleElement.setAttribute(\"media\", media)\n\t}\n\n\tif(styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink(linkElement, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls){\n\t\tcss = fixUrls(css);\n\t}\n\n\tif(sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = linkElement.href;\n\n\tlinkElement.href = URL.createObjectURL(blob);\n\n\tif(oldSrc)\n\t\tURL.revokeObjectURL(oldSrc);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanM/Yjk4MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xudmFyIHN0eWxlc0luRG9tID0ge30sXG5cdG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xuXHRcdHZhciBtZW1vO1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIG1lbW87XG5cdFx0fTtcblx0fSxcblx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIC9tc2llIFs2LTldXFxiLy50ZXN0KHNlbGYubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcblx0fSksXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuXHR9KSxcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXG5cdHNpbmdsZXRvbkNvdW50ZXIgPSAwLFxuXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcCA9IFtdLFxuXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vZml4VXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAodHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgPGhlYWQ+LlxuXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcblx0XHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0KSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCkge1xuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBoZWFkLmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZihsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0XHR9XG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AucHVzaChzdHlsZUVsZW1lbnQpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcblx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YXR0YWNoVGFnQXR0cnMoc3R5bGVFbGVtZW50LCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCk7XG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcblx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhdHRhY2hUYWdBdHRycyhsaW5rRWxlbWVudCwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rRWxlbWVudCk7XG5cdHJldHVybiBsaW5rRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gYXR0YWNoVGFnQXR0cnMoZWxlbWVudCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xuXHR9IGVsc2UgaWYob2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuXHRcdFx0aWYoc3R5bGVFbGVtZW50LmhyZWYpXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcblx0XHRpZihuZXdPYmopIHtcblx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGVFbGVtZW50LCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcblx0XHR9XG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsobGlua0VsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0LyogSWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpe1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmtFbGVtZW50LmhyZWY7XG5cblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKVxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 42 */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\tvar fixedCss = css.replace(/url *\\( *(.+?) *\\)/g, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9maXhVcmxzLmpzPzRlMmQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmwgKlxcKCAqKC4rPykgKlxcKS9nLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIvZml4VXJscy5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(19);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(41)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js!../node_modules/marko-loader/src/code-loader.js?{\\\"code\\\":\\\".count {\\\\n        color:#09c;\\\\n        font-size:3em;\\\\n    }\\\\n    .example-button {\\\\n        font-size:1em;\\\\n        padding:0.5em;\\\\n    }\\\"}!./counter.marko\", function() {\n\t\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js!../node_modules/marko-loader/src/code-loader.js?{\\\"code\\\":\\\".count {\\\\n        color:#09c;\\\\n        font-size:3em;\\\\n    }\\\\n    .example-button {\\\\n        font-size:1em;\\\\n        padding:0.5em;\\\\n    }\\\"}!./counter.marko\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wdWJsaWMvY291bnRlci5tYXJrbz8yNGJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi9ub2RlX21vZHVsZXMvbWFya28tbG9hZGVyL3NyYy9jb2RlLWxvYWRlci5qcz97XFxcImNvZGVcXFwiOlxcXCIuY291bnQge1xcXFxuICAgICAgICBjb2xvcjojMDljO1xcXFxuICAgICAgICBmb250LXNpemU6M2VtO1xcXFxuICAgIH1cXFxcbiAgICAuZXhhbXBsZS1idXR0b24ge1xcXFxuICAgICAgICBmb250LXNpemU6MWVtO1xcXFxuICAgICAgICBwYWRkaW5nOjAuNWVtO1xcXFxuICAgIH1cXFwifSEuL2NvdW50ZXIubWFya29cIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vbm9kZV9tb2R1bGVzL21hcmtvLWxvYWRlci9zcmMvY29kZS1sb2FkZXIuanM/e1xcXCJjb2RlXFxcIjpcXFwiLmNvdW50IHtcXFxcbiAgICAgICAgY29sb3I6IzA5YztcXFxcbiAgICAgICAgZm9udC1zaXplOjNlbTtcXFxcbiAgICB9XFxcXG4gICAgLmV4YW1wbGUtYnV0dG9uIHtcXFxcbiAgICAgICAgZm9udC1zaXplOjFlbTtcXFxcbiAgICAgICAgcGFkZGluZzowLjVlbTtcXFxcbiAgICB9XFxcIn0hLi9jb3VudGVyLm1hcmtvXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi9ub2RlX21vZHVsZXMvbWFya28tbG9hZGVyL3NyYy9jb2RlLWxvYWRlci5qcz97XFxcImNvZGVcXFwiOlxcXCIuY291bnQge1xcXFxuICAgICAgICBjb2xvcjojMDljO1xcXFxuICAgICAgICBmb250LXNpemU6M2VtO1xcXFxuICAgIH1cXFxcbiAgICAuZXhhbXBsZS1idXR0b24ge1xcXFxuICAgICAgICBmb250LXNpemU6MWVtO1xcXFxuICAgICAgICBwYWRkaW5nOjAuNWVtO1xcXFxuICAgIH1cXFwifSEuL2NvdW50ZXIubWFya29cIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXIhLi9+L21hcmtvLWxvYWRlci9zcmMvY29kZS1sb2FkZXIuanM/e1wiY29kZVwiOlwiLmNvdW50IHsvbiAgICAgICAgY29sb3I6IzA5YzsvbiAgICAgICAgZm9udC1zaXplOjNlbTsvbiAgICB9L24gICAgLmV4YW1wbGUtYnV0dG9uIHsvbiAgICAgICAgZm9udC1zaXplOjFlbTsvbiAgICAgICAgcGFkZGluZzowLjVlbTsvbiAgICB9XCJ9IS4vcHVibGljL2NvdW50ZXIubWFya29cbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(45);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3dhcnAxMC9maW5hbGl6ZS5qcz9iN2YyIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcmMvZmluYWxpemUnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vd2FycDEwL2ZpbmFsaXplLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 45 */
/***/ (function(module, exports) {

eval("var isArray = Array.isArray;\n\nfunction resolve(object, path, len) {\n    var current = object;\n    for (var i=0; i<len; i++) {\n        current = current[path[i]];\n    }\n\n    return current;\n}\n\nfunction resolveType(info) {\n    if (info.type === 'Date') {\n        return new Date(info.value);\n    } else {\n        throw new Error('Bad type');\n    }\n}\n\nmodule.exports = function finalize(outer) {\n    if (!outer) {\n        return outer;\n    }\n\n    var assignments = outer.$$;\n    if (assignments) {\n        var object = outer.o;\n        var len;\n\n        if (assignments && (len=assignments.length)) {\n            for (var i=0; i<len; i++) {\n                var assignment = assignments[i];\n\n                var rhs = assignment.r;\n                var rhsValue;\n\n                if (isArray(rhs)) {\n                    rhsValue = resolve(object, rhs, rhs.length);\n                } else {\n                    rhsValue = resolveType(rhs);\n                }\n\n                var lhs = assignment.l;\n                var lhsLast = lhs.length-1;\n\n                if (lhsLast === -1) {\n                    object = outer.o = rhsValue;\n                    break;\n                } else {\n                    var lhsParent = resolve(object, lhs, lhsLast);\n                    lhsParent[lhs[lhsLast]] = rhsValue;\n                }\n            }\n        }\n\n        assignments.length = 0; // Assignments have been applied, do not reapply\n\n        return object == null ? null : object;\n    } else {\n        return outer;\n    }\n\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3dhcnAxMC9zcmMvZmluYWxpemUuanM/NDQ5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbmZ1bmN0aW9uIHJlc29sdmUob2JqZWN0LCBwYXRoLCBsZW4pIHtcbiAgICB2YXIgY3VycmVudCA9IG9iamVjdDtcbiAgICBmb3IgKHZhciBpPTA7IGk8bGVuOyBpKyspIHtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGF0aFtpXV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVUeXBlKGluZm8pIHtcbiAgICBpZiAoaW5mby50eXBlID09PSAnRGF0ZScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGluZm8udmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIHR5cGUnKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmluYWxpemUob3V0ZXIpIHtcbiAgICBpZiAoIW91dGVyKSB7XG4gICAgICAgIHJldHVybiBvdXRlcjtcbiAgICB9XG5cbiAgICB2YXIgYXNzaWdubWVudHMgPSBvdXRlci4kJDtcbiAgICBpZiAoYXNzaWdubWVudHMpIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IG91dGVyLm87XG4gICAgICAgIHZhciBsZW47XG5cbiAgICAgICAgaWYgKGFzc2lnbm1lbnRzICYmIChsZW49YXNzaWdubWVudHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFzc2lnbm1lbnQgPSBhc3NpZ25tZW50c1tpXTtcblxuICAgICAgICAgICAgICAgIHZhciByaHMgPSBhc3NpZ25tZW50LnI7XG4gICAgICAgICAgICAgICAgdmFyIHJoc1ZhbHVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkocmhzKSkge1xuICAgICAgICAgICAgICAgICAgICByaHNWYWx1ZSA9IHJlc29sdmUob2JqZWN0LCByaHMsIHJocy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJoc1ZhbHVlID0gcmVzb2x2ZVR5cGUocmhzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbGhzID0gYXNzaWdubWVudC5sO1xuICAgICAgICAgICAgICAgIHZhciBsaHNMYXN0ID0gbGhzLmxlbmd0aC0xO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxoc0xhc3QgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG91dGVyLm8gPSByaHNWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxoc1BhcmVudCA9IHJlc29sdmUob2JqZWN0LCBsaHMsIGxoc0xhc3QpO1xuICAgICAgICAgICAgICAgICAgICBsaHNQYXJlbnRbbGhzW2xoc0xhc3RdXSA9IHJoc1ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFzc2lnbm1lbnRzLmxlbmd0aCA9IDA7IC8vIEFzc2lnbm1lbnRzIGhhdmUgYmVlbiBhcHBsaWVkLCBkbyBub3QgcmVhcHBseVxuXG4gICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG51bGwgOiBvYmplY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG91dGVyO1xuICAgIH1cblxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vd2FycDEwL3NyYy9maW5hbGl6ZS5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 46 */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL34vYmFzZTY0LWpzL2luZGV4LmpzPzkzOWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL34vYmFzZTY0LWpzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(47)\nvar ieee754 = __webpack_require__(49)\nvar isArray = __webpack_require__(50)\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(46)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL34vYnVmZmVyL2luZGV4LmpzP2E4NWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL34vYnVmZmVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 49 */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL34vaWVlZTc1NC9pbmRleC5qcz80OGMxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL34vaWVlZTc1NC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 50 */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL34vaXNhcnJheS9pbmRleC5qcz81ZWFmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL34vaXNhcnJheS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 51 */
/***/ (function(module, exports) {

eval("/* (ignored) *///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9lbnYtaW5pdCAoaWdub3JlZCk/ZTY5OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAoaWdub3JlZCkgKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Vudi1pbml0IChpZ25vcmVkKVxuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

eval("const counter = __webpack_require__(8);\n\ncounter.renderSync({}).appendTo(document.body);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcHVibGljL21haW4uanM/ZmE3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb3VudGVyID0gcmVxdWlyZSgnLi9jb3VudGVyLm1hcmtvJyk7XG4gXG5jb3VudGVyLnJlbmRlclN5bmMoe30pLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBwdWJsaWMvbWFpbi5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ })
/******/ ]);